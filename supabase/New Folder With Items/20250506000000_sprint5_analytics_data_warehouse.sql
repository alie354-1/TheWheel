-- Migration for Sprint 5: Analytics Data Warehouse Foundation (Idempotent)

-- Ensure the set_updated_at function exists (assuming it was created in a previous migration)
-- CREATE OR REPLACE FUNCTION public.set_updated_at() ...

-- Table for storing trackable user events
CREATE TABLE IF NOT EXISTS public.analytics_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    event_name text NOT NULL,
    user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    company_id uuid REFERENCES public.companies(id) ON DELETE CASCADE,
    payload jsonb,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Add indexes for common query patterns (Idempotent Check)
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_events_event_name' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_events_event_name ON public.analytics_events(event_name);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_events_user_id' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_events_user_id ON public.analytics_events(user_id);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_events_company_id' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_events_company_id ON public.analytics_events(company_id);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_events_created_at' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_events_created_at ON public.analytics_events(created_at);
END IF; END $$;

COMMENT ON TABLE public.analytics_events IS 'Stores individual trackable events generated by user interactions or system processes.';
-- Comments on columns... (omitted for brevity, assume they are correct)

-- Table for storing pre-computed metrics and aggregates
CREATE TABLE IF NOT EXISTS public.analytics_aggregates (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    metric_name text NOT NULL,
    dimensions jsonb NOT NULL DEFAULT '{}'::jsonb,
    value jsonb,
    calculated_at timestamptz NOT NULL DEFAULT now(),
    time_period_start timestamptz,
    time_period_end timestamptz
);

-- Add indexes for querying aggregates (Idempotent Check)
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_aggregates_metric_name' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_aggregates_metric_name ON public.analytics_aggregates(metric_name);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_aggregates_dimensions' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_aggregates_dimensions ON public.analytics_aggregates USING gin (dimensions);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_aggregates_calculated_at' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_aggregates_calculated_at ON public.analytics_aggregates(calculated_at);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_aggregates_time_period' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_aggregates_time_period ON public.analytics_aggregates(time_period_start, time_period_end);
END IF; END $$;

COMMENT ON TABLE public.analytics_aggregates IS 'Stores pre-calculated metrics for faster reporting and dashboard loading.';
-- Comments on columns...

-- Table for saved custom reports
CREATE TABLE IF NOT EXISTS public.analytics_reports (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    description text,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    company_id uuid REFERENCES public.companies(id) ON DELETE CASCADE,
    configuration jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Add indexes (Idempotent Check)
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_reports_user_id' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_reports_user_id ON public.analytics_reports(user_id);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_reports_company_id' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_reports_company_id ON public.analytics_reports(company_id);
END IF; END $$;

-- Apply the updated_at trigger (Idempotent Check)
DO $$
BEGIN
   IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'set_updated_at') THEN
      IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_analytics_reports_updated_at') THEN
         CREATE TRIGGER set_analytics_reports_updated_at
         BEFORE UPDATE ON public.analytics_reports
         FOR EACH ROW
         EXECUTE FUNCTION public.set_updated_at();
      END IF;
   END IF;
END $$;

COMMENT ON TABLE public.analytics_reports IS 'Stores definitions and configurations for user-created custom reports.';
-- Comments on columns...

-- Table for user-configured dashboards
CREATE TABLE IF NOT EXISTS public.analytics_dashboards (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    description text,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    company_id uuid REFERENCES public.companies(id) ON DELETE CASCADE,
    layout jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Add indexes (Idempotent Check)
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_dashboards_user_id' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_dashboards_user_id ON public.analytics_dashboards(user_id);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_analytics_dashboards_company_id' AND n.nspname = 'public') THEN
    CREATE INDEX idx_analytics_dashboards_company_id ON public.analytics_dashboards(company_id);
END IF; END $$;

-- Apply the updated_at trigger (Idempotent Check)
DO $$
BEGIN
   IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'set_updated_at') THEN
      IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_analytics_dashboards_updated_at') THEN
         CREATE TRIGGER set_analytics_dashboards_updated_at
         BEFORE UPDATE ON public.analytics_dashboards
         FOR EACH ROW
         EXECUTE FUNCTION public.set_updated_at();
      END IF;
   END IF;
END $$;

COMMENT ON TABLE public.analytics_dashboards IS 'Stores definitions for user-customized dashboards.';
-- Comments on columns...

-- Junction table linking dashboards and reports
CREATE TABLE IF NOT EXISTS public.analytics_dashboard_reports (
    dashboard_id uuid NOT NULL REFERENCES public.analytics_dashboards(id) ON DELETE CASCADE,
    report_id uuid NOT NULL REFERENCES public.analytics_reports(id) ON DELETE CASCADE,
    position jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamptz NOT NULL DEFAULT now(),
    PRIMARY KEY (dashboard_id, report_id)
);

COMMENT ON TABLE public.analytics_dashboard_reports IS 'Links reports to dashboards and defines their position and size within the layout.';
-- Comments on columns...

-- Enable RLS for the new tables (Postgres <14 compatible)
ALTER TABLE public.analytics_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.analytics_aggregates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.analytics_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.analytics_dashboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.analytics_dashboard_reports ENABLE ROW LEVEL SECURITY;


-- Basic RLS Policies (Idempotent Check)
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Allow users to manage their own reports' AND polrelid = 'public.analytics_reports'::regclass) THEN
    CREATE POLICY "Allow users to manage their own reports" ON public.analytics_reports FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
END IF; END $$;

DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Allow users to manage their own dashboards' AND polrelid = 'public.analytics_dashboards'::regclass) THEN
    CREATE POLICY "Allow users to manage their own dashboards" ON public.analytics_dashboards FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
END IF; END $$;

DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Allow users to manage report links for their dashboards' AND polrelid = 'public.analytics_dashboard_reports'::regclass) THEN
    CREATE POLICY "Allow users to manage report links for their dashboards" ON public.analytics_dashboard_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.analytics_dashboards d WHERE d.id = dashboard_id AND d.user_id = auth.uid())) WITH CHECK (EXISTS (SELECT 1 FROM public.analytics_dashboards d WHERE d.id = dashboard_id AND d.user_id = auth.uid()));
END IF; END $$;

DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Allow users to insert their own events' AND polrelid = 'public.analytics_events'::regclass) THEN
    CREATE POLICY "Allow users to insert their own events" ON public.analytics_events FOR INSERT WITH CHECK (auth.uid() = user_id);
END IF; END $$;

DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Allow users to select their own events' AND polrelid = 'public.analytics_events'::regclass) THEN
    CREATE POLICY "Allow users to select their own events" ON public.analytics_events FOR SELECT USING (auth.uid() = user_id);
END IF; END $$;

DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Allow authenticated users to select aggregates' AND polrelid = 'public.analytics_aggregates'::regclass) THEN
    CREATE POLICY "Allow authenticated users to select aggregates" ON public.analytics_aggregates FOR SELECT USING (auth.role() = 'authenticated');
END IF; END $$;


-- Grant usage permissions (Generally safe to re-run)
GRANT USAGE ON SCHEMA public TO supabase_admin;
GRANT ALL ON TABLE public.analytics_events TO supabase_admin;
GRANT ALL ON TABLE public.analytics_aggregates TO supabase_admin;
GRANT ALL ON TABLE public.analytics_reports TO supabase_admin;
GRANT ALL ON TABLE public.analytics_dashboards TO supabase_admin;
GRANT ALL ON TABLE public.analytics_dashboard_reports TO supabase_admin;

GRANT USAGE ON SCHEMA public TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.analytics_events TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.analytics_aggregates TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.analytics_reports TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.analytics_dashboards TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.analytics_dashboard_reports TO authenticated;
