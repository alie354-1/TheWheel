### Idea Protection Types

```typescript
// src/lib/types/idea-protection.types.ts
export enum IdeaProtectionLevel {
  PUBLIC = 'public',           // Default, can be shared and used for training
  PRIVATE = 'private',         // Only visible to creator, but can be used for anonymized training
  PROTECTED = 'protected',     // Private and excluded from training entirely
  PROPRIETARY = 'proprietary'  // Implemented as product/company with legal protection
}

export enum LegalStatus {
  PENDING = 'pending',
  PATENT_FILED = 'patent-filed',
  TRADEMARK_REGISTERED = 'trademark-registered',
  INCORPORATED = 'incorporated'
}

export interface IdeaProtectionSettings {
  id: string;
  ideaId: string;
  protectionLevel: IdeaProtectionLevel;
  updatedAt: string;
  
  // For proprietary ideas
  companyName?: string;
  implementationDate?: string;
  legalStatus?: LegalStatus;
  
  // Access controls
  ownerUserId: string;
  teamAccess?: string[];
  viewerAccess?: string[];
  
  // For training exclusion
  excludeFromTraining: boolean;
  excludeFromSimilaritySearch: boolean;
  obfuscationLevel: 'none' | 'basic' | 'complete';
}

export interface IdeaImplementation {
  id: string;
  ideaId: string;
  userId: string;
  companyName: string;
  implementedAt: string;
  legalStatus: LegalStatus;
  implementationDetails?: any;
  businessModel?: string;
  marketSegment?: string;
  fundingStatus?: string;
}
```

### Idea Feedback Types

```typescript
// src/lib/types/idea-feedback.types.ts
export enum IdeaInteractionType {
  // Direct feedback
  POSITIVE_RATING = 'positive_rating',
  NEGATIVE_RATING = 'negative_rating',
  NEUTRAL_RATING = 'neutral_rating',
  
  // Actions
  SAVED = 'saved',
  DISMISSED = 'dismissed',
  
  // Modifications
  EDITED = 'edited',
  MERGED = 'merged',
  REFINED = 'refined',
  
  // Business actions
  IMPLEMENTED = 'implemented',
  SHARED = 'shared',
  EXPORTED = 'exported',
  
  // Engagement metrics
  VIEWED_DETAILS = 'viewed_details',
  HIGH_ENGAGEMENT = 'high_engagement',
  LOW_ENGAGEMENT = 'low_engagement'
}

export interface IdeaInteraction {
  id: string;
  ideaId: string;
  userId: string;
  interactionType: IdeaInteractionType;
  timestamp: string;
  
  // For ratings
  ratingValue?: number;
  
  // For modifications
  previousVersion?: any;
  newVersion?: any;
  
  // For merges
  mergedWithIdeaIds?: string[];
  
  // For dismissals or explicit feedback
  reason?: string;
  comment?: string;
}
```

### Training Types

```typescript
// src/lib/types/training.types.ts
export enum TrainingStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed'
}

export interface TrainingSession {
  id: string;
  startedAt: string;
  completedAt?: string;
  modelVersion: string;
  trainingDataCount: number;
  validationDataCount: number;
  metrics?: any;
  status: TrainingStatus;
}

export interface TrainingIdea {
  id: string;
  trainingSessionId: string;
  ideaId: string;
  includedAs: 'positive' | 'negative' | 'modified' | 'merged';
  obfuscated: boolean;
}
```

## Database Schema Diagram

```mermaid
erDiagram
    ideas ||--o{ idea_interactions : "generates"
    ideas ||--o{ idea_protection_settings : "protects"
    ideas ||--o{ training_ideas : "trains"
    ideas ||--o{ idea_implementations : "implements"
    
    training_sessions ||--o{ training_ideas : "includes"
    
    ideas {
        uuid id PK
        text training_status
        text protection_level
        uuid owner_user_id FK
        timestamp last_trained_at
        vector embedding
    }
    
    idea_interactions {
        uuid id PK
        uuid idea_id FK
        uuid user_id FK
        text interaction_type
        timestamp timestamp
        int rating_value
        jsonb previous_version
        jsonb new_version
        uuid[] merged_with_idea_ids
        text reason
        text comment
    }
    
    idea_protection_settings {
        uuid id PK
        uuid idea_id FK
        text protection_level
        timestamp updated_at
        text company_name
        timestamp implementation_date
        text legal_status
        uuid owner_user_id FK
        uuid[] team_access
        uuid[] viewer_access
        boolean exclude_from_training
        boolean exclude_from_similarity_search
        text obfuscation_level
    }
    
    training_sessions {
        uuid id PK
        timestamp started_at
        timestamp completed_at
        text model_version
        int training_data_count
        int validation_data_count
        jsonb metrics
        text status
    }
    
    training_ideas {
        uuid id PK
        uuid training_session_id FK
        uuid idea_id FK
        text included_as
        boolean obfuscated
    }
    
    idea_implementations {
        uuid id PK
        uuid idea_id FK
        uuid user_id FK
        text company_name
        timestamp implemented_at
        text legal_status
        jsonb implementation_details
        text business_model
        text market_segment
        text funding_status
    }

================
File: docs/idea-playground/DEPLOYMENT_AND_MONITORING.md
================
# Deployment & Monitoring

This document covers the testing, deployment, and maintenance approaches for the Idea Playground system.

## Testing Framework

```mermaid
graph TD
    subgraph "Test Types"
        UT[Unit Tests]
        IT[Integration Tests]
        E2E[E2E Tests]
        VT[Visual Tests]
    end
    
    subgraph "Testing Infrastructure"
        J[Jest]
        CY[Cypress]
        SB[Storybook]
        MSW[Mock Service Worker]
        CI[GitHub Actions]
    end
    
    UT --> J
    IT --> J
    IT --> MSW
    E2E --> CY
    VT --> SB
    
    J --> CI
    CY --> CI
    SB --> CI
```

### Unit Testing

Unit tests verify the functionality of individual components and services:

```typescript
// src/__tests__/services/idea-protection.service.test.ts
import { IdeaProtectionService } from '../../lib/services/idea-playground/idea-protection.service';
import { IdeaProtectionLevel } from '../../lib/types/idea-protection.types';
import { createClient } from '@supabase/supabase-js';

// Mock Supabase client
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    from: jest.fn(() => ({
      select: jest.fn(() => ({
        eq: jest.fn(() => ({
          single: jest.fn(() => Promise.resolve({ data: null, error: null }))
        }))
      })),
      insert: jest.fn(() => Promise.resolve({ data: [{ id: 'test-id' }], error: null })),
      update: jest.fn(() => Promise.resolve({ data: null, error: null })),
    }))
  }))
}));

describe('IdeaProtectionService', () => {
  let protectionService: IdeaProtectionService;
  
  beforeEach(() => {
    // Reset mock calls
    jest.clearAllMocks();
    
    // Create service instance
    protectionService = new IdeaProtectionService();
  });
  
  describe('setProtectionLevel', () => {
    it('should set protection level and create settings', async () => {
      // Arrange
      const ideaId = 'test-idea-id';
      const userId = 'test-user-id';
      const protectionLevel = IdeaProtectionLevel.PRIVATE;
      
      // Act
      await protectionService.setProtectionLevel(ideaId, protectionLevel, userId);
      
      // Assert
      expect(createClient().from).toHaveBeenCalledWith('idea_protection_settings');
      expect(createClient().from().insert).toHaveBeenCalledWith([
        expect.objectContaining({
          ideaId,
          protectionLevel,
          ownerUserId: userId
        })
      ]);
      
      // Should also update ideas table
      expect(createClient().from).toHaveBeenCalledWith('ideas');
      expect(createClient().from().update).toHaveBeenCalledWith(
        expect.objectContaining({
          protection_level: protectionLevel,
          owner_user_id: userId
        })
      );
    });
    
    // More tests...
  });
});
```

### Integration Testing

Integration tests verify interactions between multiple services:

```typescript
// src/__tests__/integration/idea-generation-flow.test.ts
import { LLMOrchestrator } from '../../lib/services/idea-playground/llm/orchestrator';
import { IdeaGenerationService } from '../../lib/services/idea-playground/idea-generation.service';
import { IdeaProtectionService } from '../../lib/services/idea-playground/idea-protection.service';
import { InteractionTrackingService } from '../../lib/services/idea-playground/interaction-tracking.service';

// Use MSW to mock API calls
import { setupServer } from 'msw/node';
import { rest } from 'msw';

// Mock Supabase client
jest.mock('../../lib/supabase', () => ({
  supabase: {
    from: jest.fn(() => ({
      insert: jest.fn(() => Promise.resolve({ data: [{ id: 'new-idea-id' }], error: null })),
      update: jest.fn(() => Promise.resolve({ data: null, error: null })),
      select: jest.fn(() => ({
        eq: jest.fn(() => Promise.resolve({ data: [], error: null }))
      }))
    }))
  }
}));

// Mock OpenAI API
const server = setupServer(
  rest.post('https://api.openai.com/v1/chat/completions', (req, res, ctx) => {
    return res(
      ctx.json({
        choices: [
          {
            message: {
              content: JSON.stringify({
                title: 'Test Idea',
                description: 'A test idea',
                problem_statement: 'Testing problem',
                solution_concept: 'Testing solution',
                target_audience: ['Testers'],
                unique_value: 'Test value',
                business_model: 'Test model'
              })
            }
          }
        ]
      })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('Idea Generation Flow', () => {
  let orchestrator: LLMOrchestrator;
  let generationService: IdeaGenerationService;
  let protectionService: IdeaProtectionService;
  let interactionService: InteractionTrackingService;
  
  beforeEach(() => {
    // Create dependencies
    orchestrator = new LLMOrchestrator();
    protectionService = new IdeaProtectionService();
    interactionService = new InteractionTrackingService();
    
    // Create service under test
    generationService = new IdeaGenerationService(
      orchestrator,
      protectionService,
      interactionService
    );
  });
  
  it('should generate and save an idea', async () => {
    // Arrange
    const prompt = 'Test prompt';
    const userId = 'test-user-id';
    
    // Act
    const result = await generationService.generateIdea(prompt, userId);
    
    // Assert
    expect(result).toBeDefined();
    expect(result.id).toBe('new-idea-id');
    expect(result.title).toBe('Test Idea');
    
    // Should have saved to database
    expect(supabase.from).toHaveBeenCalledWith('ideas');
    expect(supabase.from().insert).toHaveBeenCalled();
    
    // Default protection level
    expect(result.protection_level).toBe('public');
  });
});
```

### E2E Testing

Cypress is used for end-to-end testing:

```typescript
// cypress/e2e/idea-playground.cy.ts
describe('Idea Playground', () => {
  beforeEach(() => {
    // Mock auth
    cy.intercept('POST', '/auth/v1/token?grant_type=password', {
      statusCode: 200,
      body: {
        access_token: 'test-token',
        token_type: 'bearer',
        expires_in: 3600,
        refresh_token: 'test-refresh-token',
        user: {
          id: 'test-user-id',
          email: 'test@example.com'
        }
      }
    });
    
    // Mock API calls
    cy.intercept('POST', '/rest/v1/ideas', {
      statusCode: 201,
      body: {
        id: 'test-idea-id',
        title: 'Test Idea',
        description: 'A test idea',
        user_id: 'test-user-id',
        created_at: new Date().toISOString()
      }
    });
    
    cy.intercept('GET', '/rest/v1/ideas?*', {
      statusCode: 200,
      body: [
        {
          id: 'test-idea-id',
          title: 'Test Idea',
          description: 'A test idea',
          user_id: 'test-user-id',
          created_at: new Date().toISOString()
        }
      ]
    });
    
    // Log in and navigate to idea playground
    cy.visit('/login');
    cy.get('input[name=email]').type('test@example.com');
    cy.get('input[name=password]').type('password');
    cy.get('button[type=submit]').click();
    
    cy.visit('/idea-playground');
  });
  
  it('should generate a new idea', () => {
    // Type in prompt
    cy.get('textarea[id=prompt]').type('My idea for a new app');
    cy.get('button:contains("Generate Idea")').click();
    
    // Verify idea appears in list
    cy.get('.idea-list').should('contain', 'Test Idea');
  });
  
  it('should change protection level', () => {
    // Mock protection API
    cy.intercept('PATCH', '/rest/v1/ideas?id=eq.test-idea-id', {
      statusCode: 200
    });
    cy.intercept('POST', '/rest/v1/idea_protection_settings', {
      statusCode: 201
    });
    
    // Find idea in list
    cy.get('.idea-list').should('contain', 'Test Idea');
    
    // Change protection level
    cy.get('select[aria-label="Protection Level"]').select('private');
    
    // Verify API call
    cy.wait('@protectionPatch').its('request.body').should('deep.equal', {
      protection_level: 'private'
    });
  });
});
```

## Deployment Procedure

### Continuous Integration

The project uses GitHub Actions for CI/CD:

```yaml
# .github/workflows/main.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Lint
      run: npm run lint
    
    - name: Type check
      run: npm run typecheck
    
    - name: Unit tests
      run: npm test
    
    - name: Build
      run: npm run build
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build
        path: dist
  
  deploy:
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: build
        path: dist
    
    - name: Deploy to production
      run: |
        # Deploy to production environment
        npx netlify-cli deploy --prod --dir=dist
      env:
        NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
        NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
```

### Deployment Environments

The system has three deployment environments:

1. **Development**: For ongoing development work
   - URL: https://dev.wheel99.com
   - Supabase Project: wheel99-dev
   - Deployed from: `develop` branch
   
2. **Staging**: For pre-production testing
   - URL: https://staging.wheel99.com
   - Supabase Project: wheel99-staging
   - Deployed from: `release/*` branches
   
3. **Production**: Live environment
   - URL: https://wheel99.com
   - Supabase Project: wheel99-prod
   - Deployed from: `main` branch

### Environment Configuration

Environment-specific settings are configured in `.env` files:

```
# .env.development
VITE_SUPABASE_URL=https://xyz.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGciOi...
VITE_USE_MOCK_API=true
VITE_OPENAI_API_URL=https://api.openai.com/v1
VITE_HUGGING_FACE_URL=https://api-inference.huggingface.co/models
```

```
# .env.production
VITE_SUPABASE_URL=https://abc.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGciOi...
VITE_USE_MOCK_API=false
VITE_OPENAI_API_URL=https://api.openai.com/v1
VITE_HUGGING_FACE_URL=https://api-inference.huggingface.co/models
```

## Versioning Strategy

The system follows Semantic Versioning (SemVer):

- **Major version** (x.0.0): Breaking changes
- **Minor version** (0.x.0): New features with backward compatibility
- **Patch version** (0.0.x): Bug fixes and non-breaking changes

## Monitoring

### Error Tracking

The system uses Sentry for error tracking:

```typescript
// src/lib/sentry.ts
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/tracing';

export const initSentry = () => {
  if (import.meta.env.PROD) {
    Sentry.init({
      dsn: import.meta.env.VITE_SENTRY_DSN,
      integrations: [new BrowserTracing()],
      tracesSampleRate: 0.5,
      environment: import.meta.env.MODE
    });
  }
};

export const captureException = (error: unknown, context?: Record<string, any>) => {
  console.error(error);
  
  if (import.meta.env.PROD) {
    Sentry.captureException(error, {
      extra: context
    });
  }
};
```

### Usage Analytics

The system uses a custom analytics service to track feature usage:

```typescript
// src/lib/services/analytics.service.ts
import { supabase } from '../supabase';

export enum AnalyticsEventType {
  PAGE_VIEW = 'page_view',
  FEATURE_USED = 'feature_used',
  ERROR = 'error',
  IDEA_GENERATION = 'idea_generation',
  IDEA_REFINEMENT = 'idea_refinement',
  IDEA_MERGER = 'idea_merger',
  PROTECTION_CHANGE = 'protection_change'
}

export class AnalyticsService {
  private userId: string | null = null;
  
  setUserId(userId: string | null) {
    this.userId = userId;
  }
  
  async trackEvent(
    eventType: AnalyticsEventType,
    properties: Record<string, any> = {}
  ): Promise<void> {
    try {
      await supabase.from('analytics_events').insert([{
        user_id: this.userId,
        event_type: eventType,
        properties,
        timestamp: new Date().toISOString()
      }]);
    } catch (error) {
      console.error('Error tracking analytics event:', error);
    }
  }
  
  async trackPageView(page: string): Promise<void> {
    await this.trackEvent(AnalyticsEventType.PAGE_VIEW, { page });
  }
  
  async trackFeatureUsage(feature: string, details: Record<string, any> = {}): Promise<void> {
    await this.trackEvent(AnalyticsEventType.FEATURE_USED, {
      feature,
      ...details
    });
  }
}

// Create singleton instance
export const analytics = new AnalyticsService();
```

### Performance Monitoring

React's Profiler API is used for component performance monitoring:

```tsx
// src/components/PerformanceMonitor.tsx
import React, { Profiler, ProfilerOnRenderCallback, ReactNode } from 'react';
import { analytics } from '../lib/services/analytics.service';

interface PerformanceMonitorProps {
  id: string;
  children: ReactNode;
}

export const PerformanceMonitor: React.FC<PerformanceMonitorProps> = ({
  id,
  children
}) => {
  const handleRender: ProfilerOnRenderCallback = (
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime
  ) => {
    // Only log slow renders in production
    if (import.meta.env.PROD && actualDuration > 16) {
      analytics.trackEvent('slow_render', {
        component: id,
        actualDuration,
        baseDuration
      });
    }
  };
  
  return (
    <Profiler id={id} onRender={handleRender}>
      {children}
    </Profiler>
  );
};
```

## Maintenance

### Database Migrations

Database migrations are run using a custom script:

```typescript
// scripts/run-migration.js
const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

async function runMigration(migrationFile) {
  try {
    console.log(`Running migration: ${migrationFile}`);
    
    const filePath = path.join(__dirname, '..', 'supabase', 'migrations', migrationFile);
    const sql = fs.readFileSync(filePath, 'utf8');
    
    // Execute the SQL statements
    const { error } = await supabase.rpc('run_sql_query', {
      query: sql
    });
    
    if (error) {
      console.error('Migration error:', error);
      process.exit(1);
    }
    
    console.log(`Migration ${migrationFile} completed successfully`);
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}

// Get migration file from command line argument
const migrationFile = process.argv[2];
if (!migrationFile) {
  console.error('Please provide a migration file name');
  process.exit(1);
}

runMigration(migrationFile);
```

### Feature Flagging

A feature flag service is used to gradually roll out new features:

```typescript
// src/lib/services/feature-flags.service.ts
import { supabase } from '../supabase';

export enum FeatureFlag {
  IDEA_PLAYGROUND = 'idea_playground',
  IP_PROTECTION = 'ip_protection',
  AI_REFINEMENT = 'ai_refinement',
  HUGGING_FACE_INTEGRATION = 'hugging_face_integration',
  CONTINUOUS_LEARNING = 'continuous_learning'
}

export class FeatureFlagsService {
  private flags: Record<string, boolean> = {};
  private userId: string | null = null;
  private loaded = false;
  
  setUserId(userId: string | null) {
    this.userId = userId;
    this.loaded = false;
  }
  
  async loadFlags(): Promise<void> {
    try {
      // Get global flags
      const { data: globalFlags } = await supabase
        .from('feature_flags')
        .select('feature, enabled, user_percentage')
        .is('user_id', null);
      
      // Get user-specific flags
      const { data: userFlags } = await supabase
        .from('feature_flags')
        .select('feature, enabled')
        .eq('user_id', this.userId || '');
      
      // Set defaults
      this.flags = Object.values(FeatureFlag).reduce((acc, flag) => {
        acc[flag] = false;
        return acc;
      }, {} as Record<string, boolean>);
      
      // Apply global flags
      if (globalFlags) {
        for (const flag of globalFlags) {
          // If percentage rollout, check if user is in the percentage
          if (flag.user_percentage !== null && flag.user_percentage < 100) {
            // Generate a consistent hash for user+feature
            const hash = this.hashCode(`${this.userId}-${flag.feature}`);
            const normalized = (hash % 100 + 100) % 100; // Ensure 0-99 range
            
            this.flags[flag.feature] = flag.enabled && normalized < flag.user_percentage;
          } else {
            this.flags[flag.feature] = flag.enabled;
          }
        }
      }
      
      // Apply user-specific flags (override global)
      if (userFlags) {
        for (const flag of userFlags) {
          this.flags[flag.feature] = flag.enabled;
        }
      }
      
      this.loaded = true;
    } catch (error) {
      console.error('Error loading feature flags:', error);
      // Default to disabled for all flags on error
    }
  }
  
  isEnabled(feature: FeatureFlag): boolean {
    // Default to false if not loaded
    if (!this.loaded) {
      console.warn('Feature flags not loaded. Call loadFlags() first.');
      return false;
    }
    
    return this.flags[feature] || false;
  }
  
  private hashCode(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return hash;
  }
}

// Create a singleton instance
export const featureFlags = new FeatureFlagsService();
```

## Disaster Recovery

### Backup Strategy

The system uses multiple backup strategies:

1. **Supabase Backups**: Daily automated backups of all database tables
2. **Production Database Snapshots**: Weekly full database snapshots
3. **Transaction Logs**: Continuous backup of transaction logs for point-in-time recovery

### Recovery Procedures

In case of data corruption or system failure:

1. **Assessment**: Identify scope and severity of the issue
2. **Isolation**: Prevent further damage by isolating affected components
3. **Recovery**: Restore from appropriate backup
   - For minor issues: Use transaction logs for point-in-time recovery
   - For major corruption: Restore from most recent snapshot
4. **Validation**: Verify data integrity and system functionality
5. **Root Cause Analysis**: Identify and address the underlying cause

## Security Monitoring

### Supabase RLS Monitoring

A service monitors Row Level Security rule effectiveness:

```typescript
// src/lib/services/security-monitoring.service.ts
import { supabase } from '../supabase';

export class SecurityMonitoringService {
  async runSecurityAudit(): Promise<{
    issues: any[];
    totalChecks: number;
  }> {
    try {
      const { data, error } = await supabase.rpc('audit_rls_policies');
      
      if (error) {
        throw error;
      }
      
      return {
        issues: data.issues || [],
        totalChecks: data.total_checks
      };
    } catch (error) {
      console.error('Security audit failed:', error);
      throw error;
    }
  }
  
  async checkTablePermissions(table: string): Promise<{
    hasRLS: boolean;
    policies: any[];
  }> {
    try {
      const { data, error } = await supabase.rpc('check_table_permissions', {
        table_name: table
      });
      
      if (error) {
        throw error;
      }
      
      return {
        hasRLS: data.has_rls,
        policies: data.policies || []
      };
    } catch (error) {
      console.error(`Permission check failed for table ${table}:`, error);
      throw error;
    }
  }
}

================
File: docs/idea-playground/ENHANCED_IDEA_HUB_FIX.md
================
# Enhanced Idea Hub Fix

## Overview

This document outlines the fixes implemented to resolve the 406 (Not Acceptable) and 403 (Forbidden) errors occurring in the Enhanced Idea Hub when saving ideas.

## Problem

When creating and saving ideas in the Enhanced Idea Hub, the following errors were occurring:

```
GET https://aerakewgxmkexuyzsomh.supabase.co/rest/v1/app_settings?select=value&key=eq.logging_enabled 406 (Not Acceptable)
POST https://aerakewgxmkexuyzsomh.supabase.co/rest/v1/logging_sessions 403 (Forbidden)
```

These errors were caused by:

1. Incorrect Supabase client configuration
2. Missing error handling for API requests
3. Type safety issues in the API service

## Solution

### 1. Supabase Client Configuration

We updated the Supabase client configuration to use environment variables from the `.env` file:

```typescript
// Before
const supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://aerakewgxmkexuyzsomh.supabase.co';
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY || 'your-anon-key';

// After
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
```

We also added error handling to the Supabase client:

```typescript
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  },
  global: {
    // Add error handling for requests
    fetch: (...args) => {
      return fetch(...args).catch(error => {
        console.error('Supabase request error:', error);
        throw error;
      });
    }
  }
});
```

### 2. Error Handling for API Requests

We added a helper function to handle common Supabase errors:

```typescript
export const handleSupabaseError = (error: any) => {
  if (error?.code === '406') {
    console.warn('Supabase 406 error - This is likely a permissions issue. Check RLS policies.');
  } else if (error?.code === '403') {
    console.warn('Supabase 403 error - This is likely an authentication issue.');
  }
  
  return error;
};
```

This function is now used throughout the API service to handle errors consistently.

### 3. Type Safety Improvements

We updated the types in the Enhanced Idea Hub to be more robust:

- Added proper type definitions for the API service
- Fixed issues with the `updateIdea` function
- Added proper error handling for all API functions

### 4. API Service Improvements

We made several improvements to the API service:

- Added proper error handling for all API functions
- Improved the return types of API functions
- Added a new `toggleSaveIdea` function
- Fixed issues with the `updateIdea` function

## Files Modified

1. `src/lib/supabaseClient.ts` - Updated to use environment variables and added error handling
2. `src/enhanced-idea-hub/services/supabaseClient.ts` - Created a new file to re-export the main Supabase client
3. `src/enhanced-idea-hub/services/api/idea-hub-api.ts` - Updated to use the new Supabase client and added error handling
4. `src/enhanced-idea-hub/types/index.ts` - Updated to include the `isSaved` property in the `IdeaFilters` interface

## How to Run the Fix

Run the following command to apply the fix:

```bash
node scripts/run-enhanced-idea-hub-fix.js
```

This script will:

1. Verify that all required files exist
2. Run type checking to ensure everything is working properly
3. Display a success message if the fix was applied successfully

## Testing

After applying the fix, you should be able to create and save ideas in the Enhanced Idea Hub without seeing the 406 and 403 errors.

================
File: docs/idea-playground/ENHANCED_IDEA_HUB_README.md
================
# Enhanced Idea Hub

The Enhanced Idea Hub is a new feature that provides a modern, flexible interface for managing and exploring ideas. It offers multiple view options, improved filtering, and better integration with company features.

## Features

- **Multiple View Options**: Switch between different views of your ideas (Card Grid, Kanban, List, Timeline, etc.)
- **Advanced Filtering**: Filter ideas by type, status, company, and more
- **Improved Sorting**: Sort ideas by various criteria
- **Company Integration**: Easily push ideas to company features
- **Responsive Design**: Works well on all device sizes

## Components

The Enhanced Idea Hub is built with a modular architecture:

### Core Components

1. **IdeaCard**: Base component for displaying idea information
2. **CardGridView**: Displays ideas in a grid layout
3. **ViewManager**: Manages switching between different view types
4. **EnhancedIdeaHub**: Main page component that integrates all parts

### API Services

- **idea-hub-api.ts**: Handles communication with the backend

### State Management

- **idea-hub-store.ts**: Central state management using Zustand

## How to Access

The Enhanced Idea Hub is available at the following URL:

```
/idea-hub/enhanced
```

## Setup Instructions

1. Install dependencies:
   ```bash
   ./scripts/install-supabase-deps.sh
   ```

2. Make sure the database migrations are applied:
   ```bash
   node scripts/run-enhanced-idea-hub-migration.js
   ```

3. Start the development server:
   ```bash
   npm run dev
   ```

4. Navigate to `/idea-hub/enhanced` in your browser

## Future Enhancements

- Kanban view for workflow management
- List view for compact display
- Timeline view for historical tracking
- Network view for idea relationships
- Focus view for detailed analysis
- Folder view for organization

## Technical Details

The Enhanced Idea Hub uses:

- React for UI components
- Zustand for state management
- Tailwind CSS for styling
- Supabase for backend communication

## Troubleshooting

If you encounter the 406 (Not Acceptable) or 403 (Forbidden) errors when accessing app_settings or logging_sessions, this is likely due to permission issues with the Supabase configuration. These errors are related to the logging system and don't affect the core functionality of the Enhanced Idea Hub.

================
File: docs/idea-playground/ENHANCED_IDEA_HUB.md
================
# Enhanced Idea Hub: Technical Documentation

## Overview

The Enhanced Idea Hub is a comprehensive redesign of the existing Idea Hub functionality, providing a more intuitive, flexible, and powerful platform for managing ideas. It supports both new company ideation and feature development within existing companies, with multiple view options and a clear progression path from idea to implementation.

## Key Features

- **Multiple View Options**: Card Grid, Kanban Board, List View, Timeline, Network View, Focus Mode, and Folder View
- **Company Context Integration**: Ideas can be associated with existing companies or marked as new company ideas
- **Flexible Filtering & Sorting**: Advanced filtering by idea type, status, company, and more
- **Customizable User Preferences**: Users can save their preferred views and filters
- **Clear Idea Progression**: Structured workflow from creation to validation to implementation
- **Integration with Company Features**: Ideas can be pushed to company feature backlogs
- **New Company Creation**: Ideas can be converted into new company entities

## Architecture

### Data Model Extensions

The Enhanced Idea Hub extends the existing idea data model with:

- **Idea Type Classification**: `new_company`, `new_feature`, `new_product`, `improvement`
- **Company Context**: Optional association with existing companies
- **Integration Status**: Tracking the idea's progression toward implementation
- **User Preferences**: Storing user view and filter preferences

### Component Structure

The implementation follows a modular architecture:

```
src/
├── enhanced-idea-hub/       # New implementation with clear separation
│   ├── components/          # UI components
│   │   ├── common/          # Common UI elements
│   │   ├── views/           # Different view implementations
│   │   ├── creation/        # Idea creation components
│   │   ├── exploration/     # Exploration components
│   │   ├── validation/      # Validation components
│   │   └── refinement/      # Refinement components
│   ├── hooks/               # Custom React hooks
│   ├── lib/                 # Utilities and helpers
│   ├── services/            # Business logic and API interactions
│   │   ├── adapters/        # Adapters for existing services
│   │   └── api/             # API client functions
│   └── store/               # Zustand store management
└── pages/
    └── idea-hub/
        └── enhanced/        # New entry point and routes
```

### State Management

The Enhanced Idea Hub uses Zustand for state management, with separate stores for:

- **Idea Data**: Managing the core idea data and operations
- **View Settings**: Managing the current view and view-specific settings
- **Filters**: Managing filtering and sorting options

### Integration with Existing Services

The Enhanced Idea Hub integrates with existing services through adapter patterns, ensuring backward compatibility while providing enhanced functionality.

## User Flows

### New Company Idea Flow

1. User selects "New Idea" → Chooses "New Company" type
2. User completes idea generation with company focus
3. Idea is saved to the dashboard
4. User can refine the idea through the refinement workflow
5. When ready, user can convert the idea to a new company entity

### New Feature/Product Idea Flow

1. User selects "New Idea" → Chooses "New Feature/Product" type
2. User selects the company context
3. User completes idea generation with feature/product focus
4. Idea is saved to the dashboard
5. User can refine and validate the idea
6. When ready, user can push the idea to the company's feature backlog

## View Types

### Card Grid View
A Pinterest-style grid of idea cards showing thumbnails/previews of each idea with key metrics. Great for visual thinkers who want to see many ideas at once.

### Kanban Board
For users who think in terms of process stages (e.g., "Idea", "Exploring", "Validating", "Refining", "Ready").

### List View
A more compact, data-dense view with sortable columns (title, creation date, last updated, status, etc.) Better for analytical users who want to scan many ideas quickly.

### Timeline View
A chronological display of ideas showing evolution and progress over time. Useful for tracking idea development history.

### Network View
A visual representation showing connections between related ideas. Great for users who think in terms of idea relationships and cross-pollination.

### Focus Mode
A deep-dive view into one active idea with all its details, refinements, and next actions. For founders who prefer to work deeply on one idea at a time.

### Folder View
Ideas organized by user-defined categories (e.g., "Product Ideas", "Marketing Ideas", "Long-term Vision"). Good for users who mentally organize by topic.

## Implementation Phases

### Phase 1: Core Hub & Navigation
- Create the new IdeaHub main page with ViewManager
- Implement user preferences for view types
- Build core navigation and consistent layout
- Migrate existing ideas data to new format
- Create adapter layer for existing services

### Phase 2: Dashboard Views
- Implement Card Grid View (simplest, familiar format)
- Build Kanban Board View
- Develop List View with advanced sorting/filtering
- Add Timeline View
- Implement view switching mechanism

### Phase 3: Enhanced Creation & Management
- Integrate existing QuickGeneration
- Develop expanded idea templates
- Improve saved ideas management
- Add batch operations for ideas

### Phase 4: Advanced Views & Features
- Implement Network/Mind Map View
- Add Focus View for deep work
- Create Folder/Category View
- Develop advanced filtering and search

### Phase 5: Integration & Refinement
- Seamlessly connect validations and refinement
- Improve transitions between different modules
- Add export and sharing capabilities
- Implement analytics and insights dashboard

## Backward Compatibility

The Enhanced Idea Hub is designed to work alongside existing functionality without disrupting it:

1. New parallel structure with its own routes
2. Adapter patterns to integrate with existing services
3. All existing routes and components remain functional
4. Graceful fallbacks for new fields
5. Thorough testing at each implementation step

## Future Expansion

The modular architecture allows for future expansion:

1. **Company Feature Management**: Full integration with company feature tracking
2. **Team Collaboration**: Multi-user collaboration on ideas
3. **Advanced Analytics**: Idea performance metrics and insights
4. **External Integrations**: Connect with product management tools
5. **AI-Powered Recommendations**: Smart suggestions for idea improvement

================
File: docs/idea-playground/FRONTEND_COMPONENTS.md
================
# Frontend Components Implementation

This document details the React component architecture for the Idea Playground system.

## Component Structure

The frontend components follow a hierarchical structure that promotes reusability, clear separation of concerns, and efficient state management.

```mermaid
graph TD
    subgraph "Pages"
        IPP[IdeaPlaygroundPage]
        QGP[QuickGenerationPage]
        IDP[IdeaDetailPage]
        ICP[IdeaComparisonPage]
        PR[PathwayRouter]
    end
    
    subgraph "Core Components"
        IPWPW[IdeaPlaygroundWorkspaceWithPathway]
        IPW[IdeaPlaygroundWorkspace]
        IPW1[IdeaPathwayWorkflow]
    end
    
    subgraph "Functional Components"
        IGF[IdeaGenerationForm]
        IL[IdeaList]
        CS[CanvasSelector]
        IC[IdeaCaptureScreen]
        SS[SuggestionsScreen]
        SE[SuggestionEditor]
        SM[SuggestionMerger]
    end
    
    subgraph "Context Providers"
        IPC[IdeaPlaygroundContext]
    end
    
    subgraph "Hooks"
        UIG[useIdeaGeneration]
        UIR[useIdeaRefinement]
        UC[useCanvas]
    end
    
    IPP --> IPWPW
    QGP --> IL
    QGP --> IGF
    
    IPWPW --> IPW
    IPWPW --> IPW1
    
    IPW --> IGF
    IPW --> IL
    IPW --> CS
    
    IPW1 --> IC
    IPW1 --> SS
    IPW1 --> SE
    IPW1 --> SM
    
    IPC --> UIG
    IPC --> UIR
    IPC --> UC
    
    IPWPW --> IPC
    
    SE --> UIG
    SM --> UIG
    IGF --> UIG
    IC --> UIG
    SS --> UIG
    IL --> UIR
```

## Key Component Implementations

### Idea Playground Context

The central context provider that manages the state and provides services to all components.

```tsx
// src/lib/contexts/IdeaPlaygroundContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { IdeaPlaygroundIdea } from '../types/idea-playground.types';
import { IdeaPlaygroundServiceFacade } from '../services/idea-playground.service.facade';
import { useAuth } from '../hooks/useAuth';
import { IdeaProtectionLevel } from '../types/idea-protection.types';

interface IdeaPlaygroundContextValue {
  // Ideas state
  ideas: IdeaPlaygroundIdea[];
  selectedIdea: IdeaPlaygroundIdea | null;
  loading: boolean;
  error: string | null;
  
  // Service methods
  generateIdea: (prompt: string) => Promise<IdeaPlaygroundIdea>;
  saveIdea: (idea: IdeaPlaygroundIdea) => Promise<void>;
  updateIdea: (idea: IdeaPlaygroundIdea) => Promise<void>;
  deleteIdea: (ideaId: string) => Promise<void>;
  selectIdea: (ideaId: string) => Promise<void>;
  
  // Canvas methods
  canvasTypes: string[];
  activeCanvas: string;
  setActiveCanvas: (canvasType: string) => void;
  
  // Protection methods
  setProtectionLevel: (ideaId: string, level: IdeaProtectionLevel) => Promise<void>;
  
  // Refinement methods
  refineIdea: (ideaId: string, feedback: string) => Promise<IdeaPlaygroundIdea>;
  
  // Pathway methods
  isPathwayActive: boolean;
  activatePathway: (ideaId?: string) => void;
  deactivatePathway: () => void;
}

const IdeaPlaygroundContext = createContext<IdeaPlaygroundContextValue | null>(null);

interface IdeaPlaygroundProviderProps {
  children: ReactNode;
  serviceFacade?: IdeaPlaygroundServiceFacade;
}

export const IdeaPlaygroundProvider: React.FC<IdeaPlaygroundProviderProps> = ({ 
  children,
  serviceFacade = new IdeaPlaygroundServiceFacade()
}) => {
  const [ideas, setIdeas] = useState<IdeaPlaygroundIdea[]>([]);
  const [selectedIdea, setSelectedIdea] = useState<IdeaPlaygroundIdea | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [activeCanvas, setActiveCanvas] = useState<string>('standard');
  const [isPathwayActive, setIsPathwayActive] = useState<boolean>(false);
  
  const { user } = useAuth();
  
  // Initialize: Fetch ideas
  useEffect(() => {
    if (user) {
      loadIdeas();
    }
  }, [user]);
  
  const loadIdeas = async () => {
    if (!user) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const fetchedIdeas = await serviceFacade.getIdeas(user.id);
      setIdeas(fetchedIdeas);
    } catch (err) {
      setError('Failed to load ideas: ' + (err instanceof Error ? err.message : String(err)));
    } finally {
      setLoading(false);
    }
  };
  
  // Generate a new idea
  const generateIdea = async (prompt: string): Promise<IdeaPlaygroundIdea> => {
    if (!user) throw new Error('User not authenticated');
    
    setLoading(true);
    setError(null);
    
    try {
      const newIdea = await serviceFacade.generateIdea(prompt, user.id);
      setIdeas(prev => [newIdea, ...prev]);
      return newIdea;
    } catch (err) {
      const errorMsg = 'Failed to generate idea: ' + (err instanceof Error ? err.message : String(err));
      setError(errorMsg);
      throw new Error(errorMsg);
    } finally {
      setLoading(false);
    }
  };
  
  // Save an idea
  const saveIdea = async (idea: IdeaPlaygroundIdea): Promise<void> => {
    if (!user) throw new Error('User not authenticated');
    
    setLoading(true);
    setError(null);
    
    try {
      const savedIdea = await serviceFacade.saveIdea({
        ...idea,
        user_id: user.id
      });
      
      setIdeas(prev => [savedIdea, ...prev.filter(i => i.id !== savedIdea.id)]);
    } catch (err) {
      setError('Failed to save idea: ' + (err instanceof Error ? err.message : String(err)));
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  // Update an existing idea
  const updateIdea = async (idea: IdeaPlaygroundIdea): Promise<void> => {
    if (!user) throw new Error('User not authenticated');
    
    setLoading(true);
    setError(null);
    
    try {
      const updatedIdea = await serviceFacade.updateIdea(idea);
      
      setIdeas(prev => prev.map(i => i.id === updatedIdea.id ? updatedIdea : i));
      
      if (selectedIdea?.id === updatedIdea.id) {
        setSelectedIdea(updatedIdea);
      }
    } catch (err) {
      setError('Failed to update idea: ' + (err instanceof Error ? err.message : String(err)));
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  // Delete an idea
  const deleteIdea = async (ideaId: string): Promise<void> => {
    if (!user) throw new Error('User not authenticated');
    
    setLoading(true);
    setError(null);
    
    try {
      await serviceFacade.deleteIdea(ideaId);
      
      setIdeas(prev => prev.filter(i => i.id !== ideaId));
      
      if (selectedIdea?.id === ideaId) {
        setSelectedIdea(null);
      }
    } catch (err) {
      setError('Failed to delete idea: ' + (err instanceof Error ? err.message : String(err)));
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  // Select an idea
  const selectIdea = async (ideaId: string): Promise<void> => {
    setLoading(true);
    setError(null);
    
    try {
      // First check local ideas
      const localIdea = ideas.find(i => i.id === ideaId);
      
      if (localIdea) {
        setSelectedIdea(localIdea);
      } else {
        // If not found locally, fetch from service
        const fetchedIdea = await serviceFacade.getIdea(ideaId);
        setSelectedIdea(fetchedIdea);
      }
    } catch (err) {
      setError('Failed to select idea: ' + (err instanceof Error ? err.message : String(err)));
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  // Set protection level
  const setProtectionLevel = async (ideaId: string, level: IdeaProtectionLevel): Promise<void> => {
    if (!user) throw new Error('User not authenticated');
    
    setLoading(true);
    setError(null);
    
    try {
      await serviceFacade.setIdeaProtectionLevel(ideaId, level, user.id);
      
      // Update local idea
      setIdeas(prev => prev.map(i => {
        if (i.id === ideaId) {
          return {
            ...i,
            protection_level: level
          };
        }
        return i;
      }));
      
      // Update selected idea if needed
      if (selectedIdea?.id === ideaId) {
        setSelectedIdea(prev => prev ? {
          ...prev,
          protection_level: level
        } : null);
      }
    } catch (err) {
      setError('Failed to set protection level: ' + (err instanceof Error ? err.message : String(err)));
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  // Refine an idea
  const refineIdea = async (ideaId: string, feedback: string): Promise<IdeaPlaygroundIdea> => {
    if (!user) throw new Error('User not authenticated');
    
    setLoading(true);
    setError(null);
    
    try {
      // First get the idea
      const idea = ideas.find(i => i.id === ideaId);
      
      if (!idea) {
        throw new Error('Idea not found');
      }
      
      // Refine the idea
      const refinedIdea = await serviceFacade.refineIdea(idea, feedback, user.id);
      
      // Update ideas list
      setIdeas(prev => prev.map(i => i.id === refinedIdea.id ? refinedIdea : i));
      
      // Update selected idea if needed
      if (selectedIdea?.id === refinedIdea.id) {
        setSelectedIdea(refinedIdea);
      }
      
      return refinedIdea;
    } catch (err) {
      setError('Failed to refine idea: ' + (err instanceof Error ? err.message : String(err)));
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  // Pathway methods
  const activatePathway = (ideaId?: string) => {
    setIsPathwayActive(true);
    if (ideaId) {
      selectIdea(ideaId).catch(err => {
        console.error('Failed to select idea for pathway:', err);
      });
    }
  };
  
  const deactivatePathway = () => {
    setIsPathwayActive(false);
  };
  
  const value: IdeaPlaygroundContextValue = {
    // State
    ideas,
    selectedIdea,
    loading,
    error,
    
    // Methods
    generateIdea,
    saveIdea,
    updateIdea,
    deleteIdea,
    selectIdea,
    
    // Canvas
    canvasTypes: ['standard', 'business-model', 'problem-solution', 'customer-journey', 'value-proposition'],
    activeCanvas,
    setActiveCanvas,
    
    // Protection
    setProtectionLevel,
    
    // Refinement
    refineIdea,
    
    // Pathway
    isPathwayActive,
    activatePathway,
    deactivatePathway
  };
  
  return (
    <IdeaPlaygroundContext.Provider value={value}>
      {children}
    </IdeaPlaygroundContext.Provider>
  );
};

export const useIdeaPlayground = (): IdeaPlaygroundContextValue => {
  const context = useContext(IdeaPlaygroundContext);
  
  if (!context) {
    throw new Error('useIdeaPlayground must be used within an IdeaPlaygroundProvider');
  }
  
  return context;
};
```

### Idea Generation Form

The component used to generate new ideas based on user input.

```tsx
// src/components/idea-playground/IdeaGenerationForm.tsx
import React, { useState } from 'react';
import { useIdeaPlayground } from '../../lib/contexts/IdeaPlaygroundContext';

interface IdeaGenerationFormProps {
  onIdeaGenerated?: () => void;
}

export const IdeaGenerationForm: React.FC<IdeaGenerationFormProps> = ({ 
  onIdeaGenerated 
}) => {
  const { generateIdea, loading } = useIdeaPlayground();
  const [prompt, setPrompt] = useState('');
  const [error, setError] = useState<string | null>(null);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!prompt.trim()) {
      setError('Please enter a prompt');
      return;
    }
    
    setError(null);
    
    try {
      await generateIdea(prompt);
      setPrompt('');
      
      if (onIdeaGenerated) {
        onIdeaGenerated();
      }
    } catch (err) {
      setError((err instanceof Error) ? err.message : String(err));
    }
  };
  
  return (
    <div className="bg-white shadow-md rounded p-6 mb-6">
      <h2 className="text-2xl font-bold mb-4">Generate New Idea</h2>
      
      <form onSubmit={handleSubmit}>
        <div className="mb-4">
          <label htmlFor="prompt" className="block text-gray-700 font-medium mb-2">
            Describe your idea or business concept:
          </label>
          <textarea
            id="prompt"
            className="w-full p-3 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            rows={4}
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            placeholder="E.g., An app that helps pet owners find pet-friendly restaurants and accommodation when traveling..."
            disabled={loading}
          />
        </div>
        
        {error && (
          <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
            {error}
          </div>
        )}
        
        <button
          type="submit"
          className="bg-blue-600 text-white py-2 px-6 rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:bg-blue-300"
          disabled={loading || !prompt.trim()}
        >
          {loading ? 'Generating...' : 'Generate Idea'}
        </button>
      </form>
    </div>
  );
};
```

### Idea List

The component that displays the list of generated ideas.

```tsx
// src/components/idea-playground/IdeaList.tsx
import React from 'react';
import { useIdeaPlayground } from '../../lib/contexts/IdeaPlaygroundContext';
import { IdeaPlaygroundIdea } from '../../lib/types/idea-playground.types';
import { IdeaProtectionLevel } from '../../lib/types/idea-protection.types';

interface IdeaListProps {
  onIdeaSelect?: (idea: IdeaPlaygroundIdea) => void;
  showControls?: boolean;
}

export const IdeaList: React.FC<IdeaListProps> = ({ 
  onIdeaSelect,
  showControls = true
}) => {
  const { 
    ideas, 
    loading, 
    error, 
    selectIdea, 
    deleteIdea,
    setProtectionLevel,
    activatePathway,
    selectedIdea
  } = useIdeaPlayground();
  
  if (loading && ideas.length === 0) {
    return <div className="p-4 text-center">Loading ideas...</div>;
  }
  
  if (error) {
    return (
      <div className="p-4 bg-red-100 text-red-700 rounded mb-4">
        Error: {error}
      </div>
    );
  }
  
  if (ideas.length === 0) {
    return (
      <div className="p-6 text-center border border-gray-200 rounded bg-gray-50">
        <p className="text-gray-500">No ideas yet. Generate your first idea!</p>
      </div>
    );
  }
  
  const handleIdeaSelect = async (idea: IdeaPlaygroundIdea) => {
    await selectIdea(idea.id);
    
    if (onIdeaSelect) {
      onIdeaSelect(idea);
    }
  };
  
  const handleDelete = async (ideaId: string, e: React.MouseEvent) => {
    e.stopPropagation();
    
    if (window.confirm('Are you sure you want to delete this idea?')) {
      await deleteIdea(ideaId);
    }
  };
  
  const handleProtectionChange = async (ideaId: string, level: IdeaProtectionLevel, e: React.ChangeEvent<HTMLSelectElement>) => {
    e.stopPropagation();
    await setProtectionLevel(ideaId, level);
  };
  
  const handlePathwayActivate = (ideaId: string, e: React.MouseEvent) => {
    e.stopPropagation();
    activatePathway(ideaId);
  };
  
  return (
    <div className="bg-white shadow-md rounded p-6 mb-6">
      <h2 className="text-2xl font-bold mb-4">Your Ideas</h2>
      
      <div className="space-y-4">
        {ideas.map((idea) => (
          <div 
            key={idea.id}
            className={`border rounded p-4 cursor-pointer hover:bg-gray-50 transition-colors ${
              selectedIdea?.id === idea.id ? 'border-blue-500 bg-blue-50' : 'border-gray-200'
            }`}
            onClick={() => handleIdeaSelect(idea)}
          >
            <div className="flex justify-between items-start">
              <h3 className="text-xl font-semibold mb-2">{idea.title}</h3>
              
              {showControls && (
                <div className="flex space-x-2">
                  <button
                    onClick={(e) => handlePathwayActivate(idea.id, e)}
                    className="text-sm py-1 px-2 bg-green-100 text-green-700 rounded hover:bg-green-200"
                    title="Use in Pathway"
                  >
                    Pathway
                  </button>
                  
                  <button
                    onClick={(e) => handleDelete(idea.id, e)}
                    className="text-sm py-1 px-2 bg-red-100 text-red-700 rounded hover:bg-red-200"
                    title="Delete idea"
                  >
                    Delete
                  </button>
                </div>
              )}
            </div>
            
            <p className="text-gray-700 mb-3 line-clamp-2">{idea.description}</p>
            
            <div className="flex justify-between items-center text-sm text-gray-500">
              <div>
                Created: {new Date(idea.created_at).toLocaleDateString()}
              </div>
              
              {showControls && (
                <div className="flex items-center">
                  <span className="mr-2">Protection:</span>
                  <select
                    value={idea.protection_level || 'public'}
                    onChange={(e) => handleProtectionChange(
                      idea.id, 
                      e.target.value as IdeaProtectionLevel,
                      e
                    )}
                    className="border border-gray-300 rounded p-1"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <option value="public">Public</option>
                    <option value="private">Private</option>
                    <option value="protected">Protected</option>
                    <option value="proprietary">Proprietary</option>
                  </select>
                </div>
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
```

### Canvas Selector

Allows switching between different canvas visualization modes.

```tsx
// src/components/idea-playground/CanvasSelector.tsx
import React from 'react';
import { useIdeaPlayground } from '../../lib/contexts/IdeaPlaygroundContext';

export const CanvasSelector: React.FC = () => {
  const { canvasTypes, activeCanvas, setActiveCanvas } = useIdeaPlayground();
  
  return (
    <div className="bg-white shadow-md rounded p-4 mb-6">
      <h3 className="text-lg font-semibold mb-3">Canvas Type</h3>
      
      <div className="flex flex-wrap gap-2">
        {canvasTypes.map((canvasType) => (
          <button
            key={canvasType}
            className={`px-4 py-2 rounded text-sm ${
              activeCanvas === canvasType
                ? 'bg-blue-600 text-white'
                : 'bg-gray-200 text-gray-800 hover:bg-gray-300'
            }`}
            onClick={() => setActiveCanvas(canvasType)}
          >
            {canvasType.split('-').map(word => 
              word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ')}
          </button>
        ))}
      </div>
    </div>
  );
};
```

### Idea Playground Workspace

The main workspace component that integrates the generation form, idea list, and canvas.

```tsx
// src/components/idea-playground/IdeaPlaygroundWorkspace.tsx
import React, { useState } from 'react';
import { IdeaGenerationForm } from './IdeaGenerationForm';
import { IdeaList } from './IdeaList';
import { CanvasSelector } from './CanvasSelector';
import { IdeaPlaygroundProvider } from '../../lib/contexts/IdeaPlaygroundContext';
import { IdeaPlaygroundServiceFacade } from '../../lib/services/idea-playground.service.facade';
import { IdeaPlaygroundIdea } from '../../lib/types/idea-playground.types';

interface IdeaPlaygroundWorkspaceProps {
  serviceFacade?: IdeaPlaygroundServiceFacade;
}

export const IdeaPlaygroundWorkspace: React.FC<IdeaPlaygroundWorkspaceProps> = ({
  serviceFacade = new IdeaPlaygroundServiceFacade()
}) => {
  const [showCanvas, setShowCanvas] = useState(false);
  
  const handleIdeaSelect = (idea: IdeaPlaygroundIdea) => {
    setShowCanvas(true);
  };
  
  return (
    <IdeaPlaygroundProvider serviceFacade={serviceFacade}>
      <div className="container mx-auto p-4">
        <h1 className="text-3xl font-bold mb-6">Idea Playground</h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <div className="lg:col-span-1">
            <IdeaGenerationForm />
            <IdeaList onIdeaSelect={handleIdeaSelect} />
          </div>
          
          <div className="lg:col-span-2">
            {showCanvas && (
              <>
                <CanvasSelector />
                <IdeaCanvasDisplay />
              </>
            )}
          </div>
        </div>
      </div>
    </IdeaPlaygroundProvider>
  );
};

// Canvas display component to show the selected idea in the active canvas format
const IdeaCanvasDisplay: React.FC = () => {
  const { selectedIdea, activeCanvas } = useIdeaPlayground();
  
  if (!selectedIdea) {
    return (
      <div className="bg-white shadow-md rounded p-6">
        <p className="text-gray-500">Select an idea to view in canvas</p>
      </div>
    );
  }
  
  // Different canvas renderers based on the active canvas type
  switch (activeCanvas) {
    case 'standard':
      return <StandardCanvas idea={selectedIdea} />;
    case 'business-model':
      return <BusinessModelCanvas idea={selectedIdea} />;
    case 'problem-solution':
      return <ProblemSolutionCanvas idea={selectedIdea} />;
    case 'customer-journey':
      return <CustomerJourneyCanvas idea={selectedIdea} />;
    case 'value-proposition':
      return <ValuePropositionCanvas idea={selectedIdea} />;
    default:
      return <StandardCanvas idea={selectedIdea} />;
  }
};

// Example of a standard canvas renderer
const StandardCanvas: React.FC<{ idea: IdeaPlaygroundIdea }> = ({ idea }) => {
  return (
    <div className="bg-white shadow-md rounded p-6">
      <h2 className="text-2xl font-bold mb-4">{idea.title}</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div>
          <h3 className="text-lg font-semibold mb-2">Description</h3>
          <p className="text-gray-700">{idea.description}</p>
        </div>
        
        <div>
          <h3 className="text-lg font-semibold mb-2">Problem Statement</h3>
          <p className="text-gray-700">{idea.problem_statement}</p>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div>
          <h3 className="text-lg font-semibold mb-2">Solution Concept</h3>
          <p className="text-gray-700">{idea.solution_concept}</p>
        </div>
        
        <div>
          <h3 className="text-lg font-semibold mb-2">Target Audience</h3>
          <p className="text-gray-700">
            {typeof idea.target_audience === 'string' 
              ? idea.target_audience 
              : idea.target_audience?.join(', ')}
          </p>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <h3 className="text-lg font-semibold mb-2">Unique Value</h3>
          <p className="text-gray-700">{idea.unique_value}</p>
        </div>
        
        <div>
          <h3 className="text-lg font-semibold mb-2">Business Model</h3>
          <p className="text-gray-700">{idea.business_model}</p>
        </div>
      </div>
    </div>
  );
};

// Other canvas components would be implemented similarly
const BusinessModelCanvas: React.FC<{ idea: IdeaPlaygroundIdea }> = ({ idea }) => {
  // Implementation details omitted for brevity
  return (
    <div className="bg-white shadow-md rounded p-6">
      <h2 className="text-2xl font-bold mb-4">Business Model Canvas: {idea.title}</h2>
      {/* Business model canvas implementation */}
    </div>
  );
};

const ProblemSolutionCanvas = ({ idea }: { idea: IdeaPlaygroundIdea }) => {
  // Implementation details omitted for brevity
  return (
    <div className="bg-white shadow-md rounded p-6">
      <h2 className="text-2xl font-bold mb-4">Problem-Solution Canvas: {idea.title}</h2>
      {/* Problem-solution canvas implementation */}
    </div>
  );
};

const CustomerJourneyCanvas = ({ idea }: { idea: IdeaPlaygroundIdea }) => {
  // Implementation details omitted for brevity
  return (
    <div className="bg-white shadow-md rounded p-6">
      <h2 className="text-2xl font-bold mb-4">Customer Journey Canvas: {idea.title}</h2>
      {/* Customer journey canvas implementation */}
    </div>
  );
};

const ValuePropositionCanvas = ({ idea }: { idea: IdeaPlaygroundIdea }) => {
  // Implementation details omitted for brevity
  return (
    <div className="bg-white shadow-md rounded p-6">
      <h2 className="text-2xl font-bold mb-4">Value Proposition Canvas: {idea.title}</h2>
      {/* Value proposition canvas implementation */}
    </div>
  );
};
```

## Custom Hooks

### useIdeaGeneration

A custom hook for idea generation functionality.

```tsx
// src/lib/hooks/useIdeaGeneration.ts
import { useState } from 'react';
import { useIdeaPlayground } from '../contexts/IdeaPlaygroundContext';
import { IdeaPlaygroundIdea } from '../types/idea-playground.types';

export const useIdeaGeneration = () => {
  const { generateIdea, loading: contextLoading } = useIdeaPlaygroun

================
File: docs/idea-playground/IDEA_GENERATOR_FIX.md
================
# Idea Generator Fix - Limiting Suggestions and Preventing Mixed Results

## Problem

The idea generation system was showing two key issues:

1. **Too many suggestions** - The system was generating and displaying more than 5 ideas at once, creating a cluttered interface
2. **Mixed suggestion types** - Real AI-generated suggestions were being mixed with example/mock suggestions 

## Solution

We've implemented two focused changes to address these issues:

### 1. Sequential Generation Service Improvements

**File: `src/lib/services/idea-playground/ai/sequential-generation.service.ts`**

- Changed the default suggestion count from 5 to 3
- Added strict bounds enforcement to limit suggestions between 3-5 total
- Improved logging to better track what's being generated

```typescript
// Key changes:
// - Default count changed from 5 to 3
// - Added bounds enforcement
async generateSuggestionsSequentially(
  idea: IdeaPlaygroundIdea,
  userId: string,
  count: number = 3, // Default is now 3 instead of 5
  progressCallback: (...) => void
): Promise<Suggestion[]> {
  
  // Enforce bounds: minimum 3, maximum 5 suggestions
  const boundedCount = Math.max(3, Math.min(5, count));
  
  // Rest of function uses boundedCount instead of count
  // ...
}
```

### 2. SuggestionsScreen Component Improvements

**File: `src/components/idea-playground/pathway1/SuggestionsScreen.tsx`**

- Modified the generation request to randomly select between 3-5 suggestions
- Prevented mixing real AI suggestions with mock/sample suggestions
- Limited mock suggestions to a maximum of 4
- Added more detailed logging
- Updated the mock data generation logic to be cleaner and more controlled

```typescript
// Key changes:
// - Random count between 3-5 instead of fixed 5
// - Check to prevent mixing real and mock suggestions
const numToGenerate = Math.min(5, Math.max(3, Math.floor(Math.random() * 3) + 3));
console.log(`Requesting ${numToGenerate} AI-generated suggestions`);
```

```typescript
// Mock suggestions handling
// - Added check to prevent mixing with real AI suggestions
// - Limited mock count
if (suggestions.length > 0) {
  console.warn('Refusing to mix AI and mock suggestions - keeping existing AI suggestions');
  return;
}

// Generate a reasonable number of mock suggestions - not too many
const mockCount = Math.min(4, Math.max(3, Math.floor(Math.random() * 2) + 3));
```

## Impact

These changes ensure:

1. The user will only see between 3-5 idea suggestions at a time
2. The system will never mix AI-generated and example/mock suggestions
3. The interface is cleaner and more focused
4. When AI generation fails, the fallback to mock data is more obvious

## Notes

- The random variation in suggestion count (3-5) provides a more natural feeling user experience
- The system now more clearly differentiates between real AI suggestions and example suggestions
- These changes maintain all existing functionality while making the interface more manageable

================
File: docs/idea-playground/IMPLEMENTATION_PLAN.md
================
# Idea Playground Rebuild: Implementation Plan

This document outlines the phased approach for implementing the Idea Playground rebuild, breaking down the work into manageable increments with clear dependencies and deliverables.

## Implementation Timeline

The complete rebuild will span 5 weeks, with each phase building upon the previous:

```mermaid
gantt
    title Idea Playground Rebuild Timeline
    dateFormat  YYYY-MM-DD
    section Foundation
    Core Infrastructure           :a1, 2025-03-24, 1d
    Database Schema               :a2, after a1, 1d
    AI Service Layer              :a3, after a1, 3d
    section Domain Services
    Domain Models                 :b1, after a2, 2d
    Repository Implementation     :b2, after b1, 1d
    Canvas & Idea Services        :b3, after b2, 2d
    Variation & Merge Services    :b4, after b3, 2d
    section Feature Implementation
    Canvas Management             :c1, after b3, 2d
    Idea Generation               :c2, after b3, 3d
    Variation Generation          :c3, after b4, 2d
    Idea Merging                  :c4, after c3, 2d
    section UI Refinement
    Component Library             :d1, after c1, 2d
    State Management              :d2, after c2, 2d
    Error Handling                :d3, after c3, 1d
    Progressive Loading           :d4, after c4, 2d
    section Testing & Deployment
    Unit Testing                  :e1, after d3, 2d
    Integration Testing           :e2, after e1, 1d
    Performance Optimization      :e3, after d4, 1d
    Deployment                    :e4, after e3, 1d
```

## Phase 1: Foundation (Week 1)

### 1. Core Infrastructure Setup (1 day)

**Tasks:**
- Initialize project structure
- Configure TypeScript with strict settings
- Set up linting and formatting
- Configure build pipeline
- Implement dependency injection container

**Deliverables:**
- Project scaffold with proper configuration
- CI/CD pipeline setup
- Core utility libraries

**Dependencies:**
- None

### 2. Database Schema (1 day)

**Tasks:**
- Design normalized database schema
- Create migration scripts
- Set up indexes for performance
- Implement database triggers
- Create test data

**Deliverables:**
- Migration scripts
- Database schema documentation
- Data access layer utilities

**Dependencies:**
- Core infrastructure

### 3. AI Service Layer (3 days)

**Tasks:**
- Implement AI orchestration service
- Create prompt management system
- Develop schema validation with Zod
- Implement response parsing with fallbacks
- Add error handling and retries
- Set up streaming response handling

**Deliverables:**
- AI service with robust error handling
- Prompt template system
- Schema validation library
- Unit tests for AI service

**Dependencies:**
- Core infrastructure

## Phase 2: Domain Services (Week 2)

### 1. Domain Models (2 days)

**Tasks:**
- Implement aggregate roots with validation
- Create value objects
- Define domain events
- Implement domain services
- Add domain exception types

**Deliverables:**
- Canvas aggregate and entities
- Idea aggregate and entities
- Variation and merged idea models
- Domain event definitions

**Dependencies:**
- Database schema

### 2. Repository Implementation (1 day)

**Tasks:**
- Create repository interfaces
- Implement Supabase repositories
- Add transaction support
- Implement query optimization

**Deliverables:**
- Repository implementations for all aggregates
- Unit tests for repositories
- Repository factory

**Dependencies:**
- Domain models

### 3. Canvas & Idea Services (2 days)

**Tasks:**
- Implement canvas service
- Create idea service
- Add idea generation capabilities
- Implement collaboration logic

**Deliverables:**
- Canvas service implementation
- Idea service implementation
- Integration with AI service
- Unit tests for services

**Dependencies:**
- Repositories
- AI service

### 4. Variation & Merge Services (2 days)

**Tasks:**
- Implement variation service
- Create merge service
- Add SWOT analysis generation
- Implement selection logic

**Deliverables:**
- Variation service implementation
- Merge service implementation
- Integration with AI service
- Unit tests for services

**Dependencies:**
- Canvas & idea services

## Phase 3: Feature Implementation (Week 3)

### 1. Canvas Management (2 days)

**Tasks:**
- Implement canvas CRUD operations
- Add collaboration features
- Create canvas organization capabilities
- Implement canvas search and filtering

**Deliverables:**
- Canvas management API endpoints
- Canvas UI components
- Integration tests for canvas features

**Dependencies:**
- Canvas service

### 2. Idea Generation (3 days)

**Tasks:**
- Implement idea creation workflow
- Add AI-assisted idea generation
- Create idea editing capabilities
- Implement real-time updates

**Deliverables:**
- Idea generation API endpoints
- Idea UI components
- Progress indicators
- Integration tests for idea features

**Dependencies:**
- Idea service

### 3. Variation Generation (2 days)

**Tasks:**
- Implement variation generation workflow
- Create variation selection UI
- Add variation comparison features
- Implement SWOT visualization

**Deliverables:**
- Variation API endpoints
- Variation UI components
- Selection state management
- Integration tests for variation features

**Dependencies:**
- Variation service

### 4. Idea Merging (2 days)

**Tasks:**
- Implement idea merging workflow
- Create merged idea visualization
- Add relationship tracking
- Implement final selection UI

**Deliverables:**
- Merge API endpoints
- Merged idea UI components
- Source tracking visualization
- Integration tests for merge features

**Dependencies:**
- Variation generation

## Phase 4: UI Refinement (Week 4)

### 1. Component Library (2 days)

**Tasks:**
- Create reusable UI components
- Implement consistent styling
- Add accessibility features
- Create component documentation

**Deliverables:**
- Design system implementation
- Component showcase
- Accessibility compliance
- Component documentation

**Dependencies:**
- Feature implementation

### 2. State Management (2 days)

**Tasks:**
- Implement Zustand store
- Create custom hooks for state access
- Add optimistic updates
- Implement state persistence

**Deliverables:**
- Global state management
- State synchronization
- Optimistic UI updates
- Persistent state handling

**Dependencies:**
- Feature implementation

### 3. Error Handling (1 day)

**Tasks:**
- Implement error boundaries
- Create contextual error messages
- Add retry mechanisms
- Implement fallback UI

**Deliverables:**
- Error handling components
- Error recovery mechanisms
- User-friendly error messages
- Error reporting

**Dependencies:**
- Feature implementation

### 4. Progressive Loading (2 days)

**Tasks:**
- Implement loading indicators
- Add skeleton screens
- Create streaming updates UI
- Implement lazy loading

**Deliverables:**
- Contextual loading indicators
- Skeleton screen components
- Streaming response visualization
- Lazy loaded components

**Dependencies:**
- Feature implementation

## Phase 5: Testing & Deployment (Week 5)

### 1. Unit Testing (2 days)

**Tasks:**
- Create comprehensive test suite
- Implement mock services
- Add test data generators
- Set up CI test integration

**Deliverables:**
- Test coverage reports
- Automated test suite
- Mock service implementations
- CI/CD test integration

**Dependencies:**
- UI refinement

### 2. Integration Testing (1 day)

**Tasks:**
- Create end-to-end tests
- Implement API integration tests
- Add performance benchmarks
- Create test documentation

**Deliverables:**
- End-to-end test suite
- API integration tests
- Performance benchmark suite
- Test documentation

**Dependencies:**
- Unit testing

### 3. Performance Optimization (1 day)

**Tasks:**
- Implement query optimization
- Add caching strategy
- Optimize component rendering
- Reduce bundle size

**Deliverables:**
- Performance optimization report
- Caching implementation
- Bundle size analysis
- Rendering performance metrics

**Dependencies:**
- Integration testing

### 4. Deployment (1 day)

**Tasks:**
- Create deployment pipeline
- Set up staging environment
- Implement feature flags
- Create monitoring dashboard

**Deliverables:**
- Deployment scripts
- Staging environment
- Feature flag system
- Monitoring dashboard

**Dependencies:**
- Performance optimization

## Resource Allocation

| Role | Responsibility | Allocation |
|------|----------------|------------|
| Frontend Developer | UI components, state management, user experience | 100% |
| Backend Developer | Domain services, repositories, API endpoints | 100% |
| Full-stack Developer | AI service integration, testing, deployment | 100% |
| UX Designer | Design system, UI/UX guidelines, accessibility | 50% |
| QA Engineer | Testing strategy, test automation, quality assurance | 50% |

## Risk Management

| Risk | Impact | Probability | Mitigation |
|------|--------|------------|------------|
| AI service reliability issues | High | Medium | Implement robust fallbacks and caching |
| Performance with large datasets | Medium | Medium | Early performance testing and optimization |
| Complex state management | Medium | High | Clear architecture and state management patterns |
| Integration challenges | High | Medium | Comprehensive integration testing |
| Timeline constraints | High | Medium | Phased approach with clear priorities |

## Success Criteria

1. **Performance Metrics**
   - Page load time < 2 seconds
   - AI operations complete within 15 seconds
   - UI remains responsive during AI operations

2. **Quality Metrics**
   - 90%+ unit test coverage
   - Zero critical bugs in production
   - WCAG 2.1 AA accessibility compliance

3. **User Experience Metrics**
   - Successful completion of all user stories
   - Intuitive user flow with clear feedback
   - Graceful error handling and recovery

## Post-Implementation Review

After completion, a post-implementation review will evaluate:

1. **Technical Quality**
   - Code quality and maintainability
   - Architecture adherence
   - Performance benchmarks

2. **Process Effectiveness**
   - Development velocity
   - Bug discovery rate
   - Communication effectiveness

3. **User Satisfaction**
   - Feature completeness
   - User experience quality
   - Performance in real-world use

================
File: docs/idea-playground/IMPLEMENTATION_SUMMARY.md
================
# Idea Playground Modular Implementation Summary

## Completed Components

The Idea Playground has been refactored into a modular architecture that addresses the previous monolithic structure and fixes AI-related issues. The following core components have been implemented:

### 1. Facade Pattern

- **IdeaPlaygroundFacade** (`src/lib/services/idea-playground.service.facade.ts`): Serves as the main entry point for all Idea Playground functionality, orchestrating specialized service calls.

### 2. Domain Services

- **CanvasService** (`src/lib/services/idea-playground/canvas.service.ts`): Manages business model and value proposition canvases with robust error handling.

### 3. AI Integration Layer

- **LLM Adapter Interface** (`src/lib/services/idea-playground/llm/adapters/interface.ts`): Defines a common interface for all LLM adapters.
- **OpenAI Adapter** (`src/lib/services/idea-playground/llm/adapters/openai.adapter.ts`): Provides integration with OpenAI's API with fallback mechanisms.

### 4. Utilities and Infrastructure

- **Type Compatibility** (`src/lib/services/idea-playground/type-compatibility.ts`): Ensures compatibility with legacy data structures.
- **Application Settings** (`src/lib/services/settings.ts`): Centralizes configuration options.
- **Index Export** (`src/lib/services/idea-playground/index.ts`): Simplifies imports through a single entry point.

### 5. Documentation and Tools

- **Architectural Overview** (`docs/idea-playground/MODULAR_ARCHITECTURE.md`): Comprehensive documentation of the new architecture.
- **Test Script** (`scripts/test-modular-idea-playground.js`): Validates the functionality of the new implementation.
- **Migration Script** (`scripts/run-modular-idea-playground.sh`): Assists with the transition from the monolithic to modular structure.

## Key Improvements

1. **Decoupled Components**: Each module has a single responsibility, making the system easier to maintain.
2. **Enhanced Error Handling**: Robust error handling with fallbacks for AI-generated content.
3. **Type Safety**: Improved TypeScript typing across all components.
4. **Improved Testability**: Isolated components are easier to test individually.
5. **JSON Parsing Resilience**: Fallback mechanisms to handle malformed JSON from AI services.

## Next Steps

The following components can be implemented next to complete the modular architecture:

1. **Refinement Service**: For refining and improving ideas.
2. **Idea Management Service**: For core CRUD operations on ideas.
3. **Component Service**: For managing UI components.
4. **Feedback Service**: For handling user feedback on ideas.

## Migration Guide

1. Existing code should import `ideaPlaygroundService` from the new facade file:
   ```typescript
   import { ideaPlaygroundService } from '../services/idea-playground.service.facade';
   ```

2. The API largely maintains backward compatibility, so most existing calls should work without changes.

3. Run the migration script to automatically update import references:
   ```bash
   bash scripts/run-modular-idea-playground.sh
   ```

4. Refer to the documentation in `docs/idea-playground/MODULAR_ARCHITECTURE.md` for details on extending and working with the new architecture.

## Testing

The implementation has been tested with a basic workflow that verifies:
- Idea generation
- Idea refinement
- Fetching ideas for a user

More comprehensive tests can be added as needed.

================
File: docs/idea-playground/IP_PROTECTION.md
================
# IP Protection Layer

This document details the intellectual property protection mechanisms implemented in the Idea Playground system.

## Overview

The IP protection layer provides multiple levels of security to safeguard users' business ideas, with controls for:

- Privacy levels for ideas (public, private, protected, proprietary)
- Access control mechanisms for team collaboration
- Training exclusion to prevent IP leakage
- Similarity detection to identify potential IP infringement

```mermaid
graph TD
    subgraph "IP Protection Components"
        PL[Protection Levels]
        AC[Access Controls]
        TE[Training Exclusion]
        SD[Similarity Detection]
    end
    
    subgraph "Implementation"
        PS[Protection Service]
        SS[Similarity Service]
        DB[(Database)]
    end
    
    PL --> PS
    AC --> PS
    TE --> PS
    SD --> SS
    
    PS --> DB
    SS --> DB
```

## Protection Levels

The system offers four distinct protection levels for ideas:

### 1. PUBLIC
- Available to all users for viewing
- Used for training AI models
- No access restrictions
- Suitable for early-stage, general concepts

### 2. PRIVATE
- Only visible to the creator
- Can be used for training in anonymized form
- Basic protection for ideas under development
- No team sharing

### 3. PROTECTED
- Only visible to the creator and designated team members
- Excluded from all AI training datasets
- Strong protection for valuable business concepts
- Team collaboration enabled

### 4. PROPRIETARY
- Maximum protection for implemented business ideas
- Excluded from all training and similarity searches
- Full metadata tracking (company name, implementation date, legal status)
- Complete access control

## Database Schema

The protection settings are stored in dedicated database tables:

```sql
-- Protection settings table
CREATE TABLE IF NOT EXISTS idea_protection_settings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  idea_id UUID REFERENCES ideas(id) ON DELETE CASCADE,
  protection_level TEXT NOT NULL DEFAULT 'public',
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Proprietary metadata
  company_name TEXT,
  implementation_date TIMESTAMP WITH TIME ZONE,
  legal_status TEXT,
  
  -- Access controls
  owner_user_id UUID NOT NULL REFERENCES auth.users(id),
  team_access UUID[] DEFAULT '{}',
  viewer_access UUID[] DEFAULT '{}',
  
  -- Training controls
  exclude_from_training BOOLEAN DEFAULT FALSE,
  exclude_from_similarity_search BOOLEAN DEFAULT FALSE,
  obfuscation_level TEXT DEFAULT 'none',
  
  UNIQUE(idea_id)
);

-- Track implemented ideas
CREATE TABLE IF NOT EXISTS idea_implementations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  idea_id UUID REFERENCES ideas(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id),
  company_name TEXT NOT NULL,
  implemented_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  legal_status TEXT DEFAULT 'pending',
  
  -- Additional details
  implementation_details JSONB,
  business_model TEXT,
  market_segment TEXT,
  funding_status TEXT
);
```

## Row-Level Security

Database-level security policies ensure proper access control:

```sql
-- Enable Row Level Security
ALTER TABLE idea_protection_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE idea_implementations ENABLE ROW LEVEL SECURITY;

-- Protection Settings - Access control
CREATE POLICY "Owners can view protection settings"
  ON idea_protection_settings
  FOR SELECT
  USING (auth.uid() = owner_user_id);
  
CREATE POLICY "Team members can view protection settings"
  ON idea_protection_settings
  FOR SELECT
  USING (auth.uid() = ANY(team_access));
  
CREATE POLICY "Owners can edit protection settings"
  ON idea_protection_settings
  FOR ALL
  USING (auth.uid() = owner_user_id);

-- Idea Implementations - IP protection
CREATE POLICY "Only owners can view implementations"
  ON idea_implementations
  FOR SELECT
  USING (auth.uid() = user_id);
  
CREATE POLICY "Only owners can create implementations"
  ON idea_implementations
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);
```

## Implementation Details

### Protection Service

The `IdeaProtectionService` handles setting and enforcing protection levels:

```typescript
// src/lib/services/idea-playground/idea-protection.service.ts
export class IdeaProtectionService {
  /**
   * Set protection level for an idea
   */
  async setProtectionLevel(
    ideaId: string,
    protectionLevel: IdeaProtectionLevel,
    userId: string,
    options: Partial<IdeaProtectionSettings> = {}
  ): Promise<void> {
    try {
      // First check if protection settings already exist
      const { data: existingSettings } = await supabase
        .from('idea_protection_settings')
        .select('id')
        .eq('idea_id', ideaId)
        .single();
        
      const excludeFromTraining = 
        protectionLevel === IdeaProtectionLevel.PROTECTED || 
        protectionLevel === IdeaProtectionLevel.PROPRIETARY;
        
      const excludeFromSimilaritySearch = 
        protectionLevel === IdeaProtectionLevel.PROPRIETARY;
      
      // Default settings based on protection level
      const settings: Partial<IdeaProtectionSettings> = {
        ideaId,
        protectionLevel,
        ownerUserId: userId,
        excludeFromTraining,
        excludeFromSimilaritySearch,
        obfuscationLevel: protectionLevel === IdeaProtectionLevel.PROPRIETARY ? 'complete' : 'none',
        ...options
      };
      
      if (existingSettings) {
        // Update existing settings
        await supabase
          .from('idea_protection_settings')
          .update(settings)
          .eq('id', existingSettings.id);
      } else {
        // Create new settings
        await supabase
          .from('idea_protection_settings')
          .insert([settings]);
      }
      
      // Also update the idea table for quick access
      await supabase
        .from('ideas')
        .update({ 
          protection_level: protectionLevel,
          owner_user_id: userId
        })
        .eq('id', ideaId);
        
    } catch (error) {
      console.error('Error setting protection level:', error);
      throw error;
    }
  }
  
  /**
   * Check if current user has access to an idea
   */
  async hasAccessToIdea(
    ideaId: string,
    userId: string,
    requiredAccess: 'view' | 'edit' | 'admin' = 'view'
  ): Promise<boolean> {
    try {
      // First get the protection settings
      const { data: protection } = await supabase
        .from('idea_protection_settings')
        .select('*')
        .eq('idea_id', ideaId)
        .single();
        
      // If no protection settings or public, anyone can view
      if (!protection || protection.protection_level === IdeaProtectionLevel.PUBLIC) {
        return requiredAccess === 'view';
      }
      
      // Owner has all access
      if (protection.owner_user_id === userId) {
        return true;
      }
      
      // Team access gives view and edit
      if (protection.team_access && protection.team_access.includes(userId)) {
        return requiredAccess !== 'admin';
      }
      
      // Viewer access only gives view
      if (protection.viewer_access && protection.viewer_access.includes(userId)) {
        return requiredAccess === 'view';
      }
      
      // No access
      return false;
    } catch (error) {
      console.error('Error checking idea access:', error);
      return false;
    }
  }
  
  /**
   * Filter ideas for training exclusion
   */
  async filterIdeasForTraining(ideas: IdeaPlaygroundIdea[]): Promise<IdeaPlaygroundIdea[]> {
    try {
      if (!ideas || ideas.length === 0) return [];
      
      // Get IDs of all ideas to check
      const ideaIds = ideas.map(idea => idea.id);
      
      // Find settings for all ideas
      const { data: protectionSettings } = await supabase
        .from('idea_protection_settings')
        .select('idea_id, exclude_from_training')
        .in('idea_id', ideaIds)
        .eq('exclude_from_training', true);
        
      if (!protectionSettings || protectionSettings.length === 0) {
        return ideas; // No exclusions
      }
      
      // Build a set of excluded idea IDs for fast lookup
      const excludedIdeaIds = new Set(
        protectionSettings.map(setting => setting.idea_id)
      );
      
      // Filter out excluded ideas
      return ideas.filter(idea => !excludedIdeaIds.has(idea.id));
    } catch (error) {
      console.error('Error filtering ideas for training:', error);
      // In case of error, be conservative and exclude all
      return [];
    }
  }
}
```

## Similarity Detection

The system uses vector embeddings to detect when new ideas might be too similar to proprietary ideas:

```typescript
// src/lib/services/idea-playground/idea-similarity.service.ts
export class IdeaSimilarityService {
  /**
   * Check if a new idea is too similar to proprietary ideas
   */
  async checkForProprietarySimilarity(
    newIdea: IdeaPlaygroundIdea, 
    similarityThreshold: number = 0.85
  ): Promise<{ tooSimilar: boolean; similarityScore?: number; similarToIdeaId?: string }> {
    try {
      // Get embedding for the new idea
      const newIdeaEmbedding = await this.generateIdeaEmbedding(newIdea);
      
      // Get proprietary ideas
      const { data: proprietaryIdeas } = await supabase
        .from('ideas')
        .select('id, title, description, problem_statement, solution_concept, target_audience, unique_value, business_model, embedding')
        .eq('protection_level', 'proprietary')
        .not('embedding', 'is', null);
        
      if (!proprietaryIdeas || proprietaryIdeas.length === 0) {
        return { tooSimilar: false };
      }
      
      // Calculate similarity with each proprietary idea
      let highestSimilarity = 0;
      let mostSimilarIdeaId = '';
      
      for (const proprietaryIdea of proprietaryIdeas) {
        if (!proprietaryIdea.embedding) continue;
        
        // Calculate cosine similarity
        const similarity = this.calculateCosineSimilarity(
          newIdeaEmbedding,
          proprietaryIdea.embedding
        );
        
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          mostSimilarIdeaId = proprietaryIdea.id;
        }
      }
      
      // Check if similarity is above threshold
      if (highestSimilarity > similarityThreshold) {
        return {
          tooSimilar: true,
          similarityScore: highestSimilarity,
          similarToIdeaId: mostSimilarIdeaId
        };
      }
      
      return { tooSimilar: false };
    } catch (error) {
      console.error('Error checking proprietary similarity:', error);
      // In case of error, be conservative
      return { tooSimilar: true };
    }
  }
  
  /**
   * Calculate cosine similarity between two embedding vectors
   */
  private calculateCosineSimilarity(vecA: number[], vecB: number[]): number {
    if (vecA.length !== vecB.length) {
      throw new Error('Vectors must have the same length');
    }
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    
    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);
    
    // Prevent division by zero
    if (normA === 0 || normB === 0) {
      return 0;
    }
    
    return dotProduct / (normA * normB);
  }
}
```

## Tracking Implementation Status

For ideas that have been implemented as actual businesses, the system provides additional metadata tracking:

```typescript
// Implementation recording
async markAsImplemented(
  ideaId: string, 
  userId: string,
  implementation: {
    companyName: string;
    implementationDate?: string;
    legalStatus?: 'pending' | 'patent-filed' | 'trademark-registered' | 'incorporated';
    teamAccess?: string[];
  }
): Promise<void> {
  try {
    await this.setProtectionLevel(
      ideaId,
      IdeaProtectionLevel.PROPRIETARY,
      userId,
      {
        companyName: implementation.companyName,
        implementationDate: implementation.implementationDate || new Date().toISOString(),
        legalStatus: implementation.legalStatus || 'pending',
        teamAccess: implementation.teamAccess || [],
        excludeFromTraining: true,
        excludeFromSimilaritySearch: true,
        obfuscationLevel: 'complete'
      }
    );
    
    // Log the implementation
    await supabase
      .from('idea_implementations')
      .insert([{
        idea_id: ideaId,
        user_id: userId,
        company_name: implementation.companyName,
        implemented_at: implementation.implementationDate || new Date().toISOString(),
        legal_status: implementation.legalStatus || 'pending'
      }]);
      
  } catch (error) {
    console.error('Error marking idea as implemented:', error);
    throw error;
  }
}
```

## User Interface Components

The system includes UI elements for managing protection levels:

```tsx
// Protection level selector in the IdeaList component
const handleProtectionChange = async (
  ideaId: string, 
  level: IdeaProtectionLevel, 
  e: React.ChangeEvent<HTMLSelectElement>
) => {
  e.stopPropagation();
  await setProtectionLevel(ideaId, level);
};

// In render function
<div className="flex items-center">
  <span className="mr-2">Protection:</span>
  <select
    value={idea.protection_level || 'public'}
    onChange={(e) => handleProtectionChange(
      idea.id, 
      e.target.value as IdeaProtectionLevel,
      e
    )}
    className="border border-gray-300 rounded p-1"
    onClick={(e) => e.stopPropagation()}
  >
    <option value="public">Public</option>
    <option value="private">Private</option>
    <option value="protected">Protected</option>
    <option value="proprietary">Proprietary</option>
  </select>
</div>
```

## Security Best Practices

### 1. Defense in Depth
The system implements multiple layers of protection:
- Database row-level security policies
- Application-level access control
- Client-side permission checks
- Server-side validation

### 2. Principle of Least Privilege
- Users only have access to the ideas they need
- Protection levels determine minimal necessary access
- Admin capabilities are strictly limited

### 3. Access Audit Trail
All protection level changes and access attempts are logged:
```typescript
// Log protection level changes
await supabase
  .from('idea_interactions')
  .insert([{
    idea_id: ideaId,
    user_id: userId,
    interaction_type: 'protection_level_change',
    previous_version: { protection_level: previousLevel },
    new_version: { protection_level: newLevel }
  }]);
```

### 4. Fail Secure
In case of errors or ambiguity, the system defaults to the most secure option:
```typescript
// If error occurs during similarity check, assume potential IP issue
catch (error) {
  console.error('Error checking proprietary similarity:', error);
  // In case of error, be conservative
  return { tooSimilar: true };
}

================
File: docs/idea-playground/MODULAR_ARCHITECTURE.md
================
# Idea Playground Modular Architecture

## Overview

The Idea Playground has been refactored into a modular architecture to improve maintainability, extensibility, and code organization. This document provides an overview of the new architecture and how it addresses previous issues.

## Key Benefits

- **Separation of Concerns**: Each module handles a specific responsibility
- **Improved Testability**: Isolated components are easier to test
- **Enhanced Maintainability**: Changes to one module won't affect others
- **Better Error Handling**: Consistent error handling throughout the system
- **Extensibility**: New features can be added without modifying existing components
- **Type Safety**: Strong TypeScript typing throughout the codebase

## Architecture Components

### 1. Facade Service

The `IdeaPlaygroundFacade` (in `idea-playground.service.facade.ts`) acts as the main entry point to the Idea Playground system, providing a unified API for UI components. It coordinates the specialized services beneath it.

**Key Responsibilities:**
- Orchestrating the workflow between specialized services
- Providing a simplified interface for UI components
- Handling cross-cutting concerns

### 2. Domain Services

Each domain service handles a specific area of functionality:

- **Idea Management Service**: Create, read, update, and delete ideas
- **Refinement Service**: Handle idea refinement and feedback
- **Canvas Service**: Manage business model and value proposition canvases
- **Component Service**: Handle UI component generation and configuration
- **Feedback Service**: Manage user feedback and collaboration

### 3. AI Integration Layer

The LLM (Large Language Model) orchestration is handled by a dedicated subsystem:

- **LLM Orchestrator**: Coordinates AI requests and manages context
- **Adapters**: Provide interfaces to different AI providers (OpenAI, etc.)
- **Context Providers**: Supply relevant contextual information for AI prompts
- **Response Parsing**: Extract structured data from AI responses

### 4. Data Types and Compatibility

- **Type System**: Strong TypeScript typing for all components
- **Compatibility Layer**: Handles conversion between different data formats
- **Migration Utilities**: Support transitioning from legacy formats

## Key Improvements

### 1. AI Feature Reliability

- **JSON Parsing**: Robust error handling for AI-generated JSON
- **Fallback Mechanisms**: Default values when AI responses fail
- **Type Validation**: Ensuring responses match expected formats

### 2. Error Handling

- **Consistent Approach**: All services follow the same error handling pattern
- **Detailed Logging**: Enhanced error information for debugging
- **User-Friendly Fallbacks**: Graceful degradation when errors occur

### 3. Performance Optimizations

- **Minimized Dependencies**: Services only depend on what they need
- **Efficient Data Flow**: Streamlined data passing between components
- **Lazy Loading**: Components are initialized only when needed

## Usage Example

```typescript
// Import the facade
import { ideaPlaygroundService } from '../services/idea-playground.service.facade';

// Generate a new business idea
const newIdea = await ideaPlaygroundService.generateIdea({
  theme: 'sustainability',
  industry: 'technology',
  userId: currentUser.id
});

// Refine the idea with feedback
const refinedIdea = await ideaPlaygroundService.refineIdea(
  newIdea, 
  'Focus more on B2B applications',
  currentUser.id
);

// Generate a business model canvas
const canvas = await ideaPlaygroundService.getLLMOrchestrator()
  .generateBusinessModelCanvas(refinedIdea, currentUser.id);
```

## Implementation Details

### File Structure

```
/src/lib/services/idea-playground/
  ├── index.ts                       # Main export point
  ├── idea-playground.service.facade.ts  # Facade service
  ├── type-compatibility.ts          # Compatibility utilities
  ├── idea-management.service.ts     # Idea CRUD operations
  ├── refinement.service.ts          # Idea refinement
  ├── canvas.service.ts              # Canvas management
  ├── component.service.ts           # UI components
  ├── feedback.service.ts            # User feedback
  ├── llm/                           # LLM integration
  │   ├── orchestrator.ts            # Coordinates AI requests
  │   ├── adapters/                  # Provider-specific adapters
  │   │   ├── interface.ts           # Common adapter interface
  │   │   └── openai.adapter.ts      # OpenAI implementation
  │   └── context/                   # Context management
  │       ├── interface.ts           # Context provider interface
  │       ├── context-manager.ts     # Manages multiple contexts
  │       ├── base-context.provider.ts  # Base implementation
  │       ├── company-context.provider.ts  # Company-specific context
  │       └── abstraction-context.provider.ts  # Abstraction helpers
  └── ai/                            # AI-specific implementations
      ├── ai-service.ts              # Base AI service
      ├── types.ts                   # AI-specific types
      ├── sequential-generation.service.ts  # Multi-step generation
      ├── idea-merger.service.ts     # Merging ideas with AI
      └── mock-data-generator.ts     # Mock data for testing
```

### Testing

The modular architecture enables comprehensive testing at different levels:

1. **Unit Tests**: Test individual services in isolation
2. **Integration Tests**: Test interactions between services
3. **End-to-End Tests**: Test complete workflows through the facade

The test script `scripts/test-modular-idea-playground.js` demonstrates basic functionality and provides a starting point for more comprehensive testing.

## Extending the System

To add new functionality:

1. Identify the appropriate service to extend or create a new service if needed
2. Implement the new functionality in the service
3. If necessary, expose the functionality through the facade
4. Update tests to cover the new functionality

## Future Enhancements

Potential areas for future improvement:

1. **Caching Layer**: Add caching to improve performance
2. **Real-time Collaboration**: Enable multiple users to work on the same idea
3. **Expanded AI Providers**: Add support for more LLM providers
4. **Analytics Integration**: Track usage patterns to improve AI prompts
5. **Learning System**: Improve AI responses based on user feedback

## Migration Guide

For existing code using the old monolithic service:

1. Replace imports to use the facade:
   ```typescript
   // Old
   import { ideaPlaygroundService } from '../services/idea-playground.service';
   
   // New
   import { ideaPlaygroundService } from '../services/idea-playground.service.facade';
   ```

2. Update method calls as needed (most common methods maintain backward compatibility)

3. For advanced use cases, access the specialized services through the facade:
   ```typescript
   const orchestrator = ideaPlaygroundService.getLLMOrchestrator();
   ```

## Conclusion

The new modular architecture provides a solid foundation for the Idea Playground, making it more maintainable, extensible, and robust. The separation of concerns and improved type safety will make it easier to add new features and fix bugs in the future.

================
File: docs/idea-playground/MODULAR_IMPLEMENTATION_GUIDE.md
================
# Idea Playground - Modular Implementation Guide

This document outlines the modular structure implemented for the Idea Playground feature, focusing on maintainability, AI integration, and component separation.

## Architecture Overview

The new implementation follows a modular architecture with clear separation of concerns:

```
idea-playground/
├── services/                  # Service layer
│   ├── idea-playground.service.ts              # Core service with simplified API
│   ├── idea-playground.service.facade.ts       # Facade for component integration
│   └── idea-playground/                        # Modular implementation
│       ├── service-adapter.ts                  # Adapter for type compatibility
│       ├── type-compatibility.ts               # Type definitions and converters
│       └── ... (other modular services)
├── components/                # UI Components
└── pages/                     # Page components
    ├── IdeaPlaygroundPage.tsx               # Main entry point
    └── PathwayRouter.tsx                    # Pathway selection component
```

## Key Components

### Service Layer

1. **Core Service** (`idea-playground.service.ts`):
   - Provides simplified CRUD operations for ideas and canvases
   - Handles basic data operations without external dependencies
   - Serves as a fallback when external AI services are unavailable

2. **Type Compatibility** (`type-compatibility.ts`):
   - Defines compatible types between the simplified service and UI components
   - Provides mapping functions to convert between different type systems
   - Ensures consistent data structures throughout the application

3. **Service Adapter** (`service-adapter.ts`):
   - Adapts the simplified service API to the complex component expectations
   - Handles data transformation and validation
   - Ensures backward compatibility with existing components

4. **Service Facade** (`idea-playground.service.facade.ts`):
   - Provides a unified interface for all components
   - Delegates operations to the appropriate service implementations
   - Simplifies component integration

### AI Integration

1. **AIContextProvider**:
   - Provides AI capabilities to all child components
   - Handles API calls to the LLM service
   - Manages loading states and error handling

2. **AI Service Delegation**:
   - The service adapter integrates with the `generalLLMService`
   - Provides graceful fallbacks when AI services are unavailable
   - Ensures proper prompt formatting and response parsing

### UI Layer

1. **PathwayRouter Component**:
   - Serves as the main entry point for users
   - Provides three distinct pathways for idea development:
      - Quick idea generation
      - Guided refinement
      - Exploration and merging
   - Handles navigation between different workflows

2. **IdeaPlaygroundPage**:
   - Container component that hosts the PathwayRouter
   - Provides authentication context and layout

## Implementation Principles

1. **Loose Coupling**:
   - Components depend on interfaces, not implementations
   - Services communicate through well-defined APIs
   - Type adapters ensure compatibility between modules

2. **Graceful Degradation**:
   - All AI features have fallbacks for when services are unavailable
   - Mock data is provided when external services fail
   - User experience is maintained even in degraded states

3. **Simplified API Surface**:
   - Complex operations are encapsulated behind simple interfaces
   - Implementation details are hidden from consuming components
   - Type safety is ensured throughout the system

## Usage Guidelines

### Adding New Features

1. Identify the appropriate service module
2. Implement the feature in the most specific service
3. Update the facade to expose the new functionality
4. Connect UI components to the facade

### Modifying Existing Features

1. Locate the appropriate service implementation
2. Make changes while preserving the public interface
3. Update tests to verify behavior
4. If public API changes are needed, update the facade and adapters

### AI Integration

To add new AI-powered features:

1. Define a clear prompt template with appropriate instructions
2. Use the `generalLLMService.query()` method for AI interactions
3. Implement proper response parsing and error handling
4. Provide meaningful fallbacks for when AI is unavailable

## Future Improvements

1. **Enhanced Type Safety**:
   - Further refinement of type adapters
   - Runtime type validation for API responses

2. **Test Coverage**:
   - Unit tests for all service modules
   - Integration tests for component interactions
   - E2E tests for user workflows

3. **Performance Optimization**:
   - Caching of common AI responses
   - Optimized rendering for large idea collections
   - Background processing for intensive operations

================
File: docs/idea-playground/MODULAR_IMPLEMENTATION_SUMMARY.md
================
# Idea Playground Modular Implementation Summary

This document provides an overview of the modular refactoring done for the Idea Playground feature, specifically focusing on breaking down the monolithic AI services into more maintainable, testable components.

## Architecture Changes

The original monolithic implementation has been refactored into a modular architecture with the following components:

```
src/lib/services/idea-playground/ai/
├── index.ts                       # Barrel file exporting all AI services
├── sequential-generation.service.ts  # Handles ideas generation with progress tracking  
└── idea-merger.service.ts         # Handles merging multiple ideas into one
```

## Benefits of the New Architecture

1. **Improved Separation of Concerns**: Each service handles a specific aspect of the AI functionality
2. **Better Error Handling**: Each service implements its own error handling and fallback mechanisms
3. **Enhanced Testing Capability**: Smaller, focused services are easier to unit test
4. **Improved Maintainability**: Easier to update or replace individual components without affecting others
5. **Better Progress Reporting**: Sequential generation now provides detailed progress information
6. **Reduced Component Complexity**: UI components now delegate complex logic to services

## Key Components

### Sequential Generation Service

This service handles generating multiple idea suggestions one by one, providing progress updates along the way. Features include:

- Progress tracking with callbacks
- Per-suggestion timeout protection
- Individual error handling for each suggestion
- Graceful fallbacks when AI fails
- Rate limiting prevention
- Mock data generation for faster testing

### Idea Merger Service

This service handles the combination of multiple selected ideas into a coherent merged concept:

- Delegates to the AI for intelligent merging
- Provides fallback for manual merging when AI is unavailable
- Preserves unique attributes from each source idea
- Handles array fields like strengths, weaknesses, opportunities, threats

## Integration Points

The modular services are integrated with the UI components:

- `SuggestionsScreen` - Uses the sequential generation service
- `SuggestionMerger` - Uses the idea merger service

## Future Expansion

The modular architecture makes it easy to add new AI-powered features:

1. Create a new service under the `ai` directory
2. Add it to the barrel export in `index.ts`
3. Use it in the relevant component

Potential future services could include:
- Idea refinement service
- Context enhancement service
- Feedback analysis service
- Business model generation service

## Testing

Each service can be tested independently. Mock implementations can be created for testing UI components without relying on actual AI calls.

================
File: docs/idea-playground/MODULAR_IMPLEMENTATION.md
================
# Modular Idea Playground Architecture

## Overview

The Idea Playground has been restructured into a modular architecture to improve maintainability, testability, and extensibility. This document outlines the new architecture and provides guidance on how to use it.

## Architecture

The new architecture is organized around the following principles:

1. **Separation of Concerns**: Each module has a specific responsibility
2. **Dependency Injection**: Services receive their dependencies via constructors
3. **Facade Pattern**: A single entry point provides access to all functionality
4. **Adapter Pattern**: LLM implementations are abstracted behind adapters
5. **Context Enrichment**: A system for enhancing LLM requests with relevant context

### Directory Structure

```
src/lib/services/idea-playground/
├── index.ts                      # Barrel exports
├── idea-generation.service.ts    # Idea generation capabilities
├── component.service.ts          # Component management
├── canvas.service.ts             # Business model/value prop canvas generation
├── refinement.service.ts         # Idea refinement
├── feedback.service.ts           # User feedback processing
├── idea-management.service.ts    # Managing ideas (CRUD)
├── llm/                          # LLM integration
│   ├── orchestrator.ts           # Coordinates LLM requests/responses
│   ├── adapters/                 # LLM provider implementations
│   │   ├── interface.ts          # Adapter interface definition
│   │   └── openai.adapter.ts     # OpenAI implementation
│   └── context/                  # Context enrichment system
│       ├── interface.ts          # Context provider interfaces
│       ├── context-manager.ts    # Manages multiple context providers
│       ├── base-context.provider.ts # Base context provider
│       ├── company-context.provider.ts # Company-specific context
│       └── abstraction-context.provider.ts # Abstraction level context
└── utils/                        # Utility functions
    └── response-parsing.ts       # Parse LLM responses into structured data
```

## Facade Service

The new architecture exposes a facade service that provides a single entry point to all idea playground functionality:

```typescript
import { IdeaPlaygroundFacade } from '../../lib/services/idea-playground.service.facade';

// Create the facade service
const ideaPlayground = new IdeaPlaygroundFacade({
  apiKey: 'your-api-key', // Optional
  model: 'gpt-4-turbo' // Optional
});

// Generate ideas
const ideas = await ideaPlayground.generateIdea('A sustainable food delivery app');

// Generate business model canvas
const canvas = await ideaPlayground.generateBusinessModelCanvas(ideas[0].title);

// Generate component variations
const components = await ideaPlayground.generateComponentVariations(ideas[0].title);
```

## Domain Services

Individual domain services can be accessed through the facade if needed:

```typescript
// Get the idea generation service
const ideaGenerationService = ideaPlayground.getIdeaGenerationService();

// Generate multiple ideas
const ideas = await ideaGenerationService.generateIdeas('A new social media platform', 5);

// Generate variations of an existing idea
const variations = await ideaGenerationService.generateIdeaVariations('A platform for connecting pet owners');
```

## LLM Orchestration

The `LLMOrchestrator` coordinates all interactions with language models:

1. It manages the LLM adapter that handles API communication
2. It enriches requests with context through the context manager
3. It processes responses, handling errors and parsing structured data

## Context System

The context system enhances LLM requests with relevant information:

- `CompanyContextProvider`: Adds information about the company (industry, stage, etc.)
- `AbstractionContextProvider`: Controls the abstraction level of responses
- Custom context providers can be added as needed

## Migration

A migration script is available to help transition from the old monolithic architecture to the new modular one:

```bash
# Run the migration script
./scripts/run-modular-idea-playground.sh
```

## Benefits

1. **Maintainability**: Smaller, focused modules are easier to understand and maintain
2. **Testability**: Dependency injection makes unit testing straightforward
3. **Extensibility**: New services and adapters can be added without modifying existing code
4. **Flexibility**: LLM providers can be swapped by implementing new adapters
5. **Robust Error Handling**: Centralized error handling and recovery
6. **Structured Data**: Better parsing and validation of LLM responses
7. **Context Awareness**: Rich context enhances the quality of LLM responses

## Best Practices

1. Always use the facade for high-level access to idea playground functionality
2. When extending the system, create new service modules rather than modifying existing ones
3. Add new LLM providers by implementing the `LLMAdapter` interface
4. Create specialized context providers for specific domains or use cases
5. Use the utilities in `response-parsing.ts` to handle LLM responses safely

================
File: docs/idea-playground/MODULAR_STRUCTURE.md
================
# Idea Playground Modular Architecture

## Overview

The Idea Playground has been refactored into a modular architecture that separates concerns, improves maintainability, and allows for better extensibility. This document outlines the structure and key components of the new architecture.

## Architecture Components

```
idea-playground/
├── service.facade.ts       # Public API facade for frontend components
├── feature-flags.service.ts # Feature flag management
└── idea-playground/        # Domain services
    ├── index.ts            # Export all services
    ├── idea-generation.service.ts
    ├── idea-management.service.ts
    ├── refinement.service.ts
    ├── canvas.service.ts
    ├── feedback.service.ts
    ├── llm/               # LLM integration
    │   ├── orchestrator.ts
    │   ├── adapters/      # LLM provider adapters
    │   │   ├── interface.ts
    │   │   └── openai.adapter.ts
    │   └── context/       # Context enhancement
    │       ├── interface.ts
    │       ├── context-manager.ts
    │       └── base-context.provider.ts
    ├── ai/                # AI-specific services
    │   ├── index.ts
    │   ├── ai-service.ts
    │   └── mock-data-generator.ts
    └── utils/             # Utility functions
        └── response-parsing.ts
```

## Key Components

### Service Facade

The `IdeaPlaygroundServiceFacade` serves as the primary interface for frontend components. It coordinates between different services and handles feature flag checking. This facade pattern simplifies frontend integration and hides the complexity of the underlying services.

```typescript
// src/lib/services/idea-playground.service.facade.ts
import { IdeaPlaygroundIdea } from '../types/idea-playground.types';
import { IdeaGenerationService } from './idea-playground/idea-generation.service';
// ...more imports

export class IdeaPlaygroundServiceFacade {
  // Services initialization
  
  async generateIdea(prompt: string, userId: string): Promise<IdeaPlaygroundIdea> {
    // Check feature flag and delegate to idea generation service
  }
  
  // Other methods that delegate to specific services
}
```

### Domain Services

Each domain service focuses on a specific aspect of the Idea Playground functionality:

1. **IdeaGenerationService**: Handles generating new ideas using AI
2. **IdeaManagementService**: CRUD operations for ideas
3. **RefinementService**: Refines ideas based on feedback
4. **CanvasService**: Manages different canvas types for ideas
5. **FeedbackService**: Collects and processes user feedback

### LLM Integration

The LLM (Large Language Model) integration is modularized to support multiple AI providers:

1. **LLMOrchestrator**: Coordinates between different AI providers and context enhancers
2. **Adapters**: Implementations for specific AI providers (OpenAI, etc.)
3. **Context Providers**: Enhance prompts with additional context

```typescript
// src/lib/services/idea-playground/llm/orchestrator.ts
export class LLMOrchestrator {
  private adapters: Record<string, LLMAdapter>;
  private contextManager: ContextManager;
  private activeAdapter: string;
  
  // Methods for generating text, ideas, etc.
}
```

### Feature Flags

The architecture includes a feature flag system that allows for gradual rollout of features:

```typescript
// src/lib/services/feature-flags.service.ts
export enum FeatureFlag {
  IDEA_PLAYGROUND = 'idea_playground',
  IP_PROTECTION = 'ip_protection',
  AI_REFINEMENT = 'ai_refinement',
  // ...more flags
}

export class FeatureFlagsService {
  // Methods for checking if features are enabled
}
```

## Type Definitions

The architecture includes comprehensive type definitions for domain objects:

```typescript
// src/lib/types/idea-playground.types.ts
export interface IdeaPlaygroundIdea {
  id: string;
  title: string;
  description: string;
  // ...more properties
}

export interface IdeaVariation {
  // ...properties
}

// ...more interfaces
```

## Integration with React Components

To use the new services in React components, import and use the facade:

```typescript
// Example component
import { useEffect, useState } from 'react';
import { IdeaPlaygroundServiceFacade } from '../lib/services/idea-playground.service.facade';
import { IdeaPlaygroundIdea } from '../lib/types/idea-playground.types';

const IdeaGenerator = () => {
  const [ideas, setIdeas] = useState<IdeaPlaygroundIdea[]>([]);
  const serviceFacade = new IdeaPlaygroundServiceFacade();
  
  const generateIdea = async (prompt: string) => {
    try {
      const newIdea = await serviceFacade.generateIdea(prompt, userId);
      setIdeas(prev => [newIdea, ...prev]);
    } catch (error) {
      console.error('Error generating idea:', error);
    }
  };
  
  // Rest of component
};
```

## Benefits of the New Architecture

1. **Separation of Concerns**: Each service has a clear, single responsibility
2. **Testability**: Services can be tested in isolation
3. **Extensibility**: New features can be added without modifying existing code
4. **Maintainability**: Easier to understand and modify specific parts of the system
5. **Feature Flags**: Gradual rollout and A/B testing capabilities
6. **AI Provider Agnostic**: Support for multiple AI providers through adapters

## Migration Strategy

For existing components using the old architecture, gradually update them to use the new facade. The service adapter provides backward compatibility during the transition period.

================
File: docs/idea-playground/OVERVIEW.md
================
# AI-Powered Business Idea Generation System

This document provides a high-level overview of the modular Idea Playground system with continuous learning and IP protection features.

## Architecture Diagram

```mermaid
graph TD
    subgraph "Frontend Application"
        UI[UI Components]
        Hooks[React Hooks]
        Contexts[React Contexts]
    end
    
    subgraph "Service Layer"
        IdS[Idea Services]
        FbS[Feedback Services]
        IPS[IP Protection Service]
        TraS[Training Services]
    end
    
    subgraph "LLM Adapters"
        OAA[OpenAI Adapter]
        HFA[Hugging Face Adapter]
        LocalA[Local Model Adapter]
    end
    
    subgraph "Database"
        Ideas[Ideas Table]
        Feedback[Feedback Table]
        Protection[Protection Settings]
        Interactions[User Interactions]
    end
    
    subgraph "Training Infrastructure"
        HFS[Hugging Face Spaces]
        TrainP[Training Pipeline]
        ModelR[Model Repository]
    end
    
    UI --> Hooks
    Hooks --> Contexts
    Contexts --> IdS
    Contexts --> FbS
    Contexts --> IPS
    IdS --> OAA
    IdS --> HFA
    IdS --> LocalA
    FbS --> Feedback
    IPS --> Protection
    IdS --> Ideas
    TraS --> Ideas
    TraS --> Feedback
    TraS --> Interactions
    TraS --> TrainP
    TrainP --> ModelR
    ModelR --> HFS
    HFS --> LocalA
```

## Major System Components

### 1. Idea Generation System
- Core idea generation capabilities
- Modular architecture with swappable LLM adapters
- Abstraction layers for different AI models

### 2. Feedback Collection Framework
- Comprehensive tracking of all user interactions
- Classification of feedback into multiple categories
- Storage of metadata for training signal extraction

### 3. IP Protection Layer
- Protection levels for different idea stages
- Owner/team access controls
- Training exclusion mechanisms
- Similarity detection to prevent IP leakage

### 4. Training Pipeline
- Data collection and preparation
- Filtering and obfuscation of sensitive data
- Training supervision with continuous learning
- Model versioning and deployment

### 5. Hugging Face Integration
- Model hosting and serving
- Training infrastructure
- Model registry and versioning

## Documentation Structure

This documentation is divided into several focused documents:

1. [Overview](./OVERVIEW.md) - This document, providing a high-level system architecture
2. [Database Schema](./DATABASE_SCHEMA.md) - SQL schema and TypeScript type definitions
3. [Backend Services](./BACKEND_SERVICES.md) - Service implementations for the core functionality
4. [Frontend Components](./FRONTEND_COMPONENTS.md) - React component hierarchy and implementation
5. [Training Pipeline](./TRAINING_PIPELINE.md) - Continuous learning implementation
6. [IP Protection](./IP_PROTECTION.md) - Intellectual property protection mechanisms
7. [Deployment & Monitoring](./DEPLOYMENT_AND_MONITORING.md) - Testing, deployment, and maintenance guides

================
File: docs/idea-playground/OWNERSHIP_FILTERING.md
================
# Idea Ownership Filtering

This document describes the ownership filtering feature added to the Enhanced Idea Hub.

## Overview

The Enhanced Idea Hub now supports filtering ideas by ownership type, allowing users to easily distinguish between personal ideas and company ideas. This feature helps users manage their ideas more effectively, especially when they have a mix of personal projects and company initiatives.

## Implementation Details

### Types

The ownership filtering feature is built on the following type definitions:

- `OwnershipType`: An enum with values `'personal'` or `'company'`
- `IdeaFilters`: Updated to include an optional `ownershipType` property

### UI Components

The ownership filtering UI is implemented in the `EnhancedIdeaHub` component, which provides filter buttons for:

- All ideas (no ownership filter)
- Personal ideas only
- Company ideas only

The selected filter is visually indicated with a different background color.

### Filtering Logic

When a user selects an ownership filter:

1. The filter selection is stored in the component's state
2. The filter is applied to the ideas array using the `filter()` method
3. Only ideas matching the selected ownership type are displayed
4. The filter is also stored in the global store for persistence

### Store Integration

The ownership filter is integrated with the Zustand store:

- The filter value is stored in the `filters` object in the store
- The `setFilters` action is used to update the filter
- The filter persists across component re-renders

## Usage

Users can filter ideas by ownership type by clicking on the corresponding filter buttons in the Enhanced Idea Hub:

- "All" button: Shows all ideas regardless of ownership
- "Personal" button: Shows only ideas with `ownershipType === 'personal'`
- "Company" button: Shows only ideas with `ownershipType === 'company'`

## Testing

A test script (`scripts/test-idea-ownership-filter.js`) is provided to verify the ownership filtering functionality. The script:

1. Creates test ideas with different ownership types
2. Tests filtering by personal ownership
3. Tests filtering by company ownership
4. Cleans up the test data

## Future Enhancements

Potential future enhancements for the ownership filtering feature:

- Add filter presets that include ownership type
- Add sorting by ownership type
- Add bulk actions for ideas of a specific ownership type
- Add ownership transfer functionality (personal to company and vice versa)

================
File: docs/idea-playground/OWNERSHIP_MODEL_IMPLEMENTATION.md
================
# Enhanced Idea Hub: Ownership Model Implementation

This document outlines the implementation of the ownership model for ideas in the Enhanced Idea Hub, which allows for a clear distinction between personal ideas and company ideas.

## Overview

The ownership model introduces two key concepts:

1. **Ownership Type**: Ideas can be either "personal" (owned by an individual user) or "company" (owned by a company and visible to all company members).
2. **Creator ID**: Every idea has a creator, which is the user who initially created the idea.

This model enables a workflow where users can:
- Create personal ideas that only they can see
- Promote personal ideas to company ideas when they're ready to share
- Collaborate on company ideas with their team

## Database Changes

The following changes were made to the database schema:

### 1. New Columns in `idea_playground_ideas` Table

- `creator_id`: UUID reference to `auth.users(id)` - The user who created the idea
- `ownership_type`: TEXT with CHECK constraint to be either 'personal' or 'company' - The ownership type of the idea

### 2. Row-Level Security (RLS) Policies

Updated RLS policies to enforce the following access rules:

- Users can view their own personal ideas OR company ideas they have access to
- Users can only create ideas with themselves as the creator
- Users can update their personal ideas OR company ideas if they have proper role (admin/editor)
- Users can delete their personal ideas OR company ideas if they have admin role

### 3. Database Function for Idea Promotion

Created a PostgreSQL function `promote_idea_to_company` that:
- Takes an idea ID and target company ID as parameters
- Verifies the user is a member of the target company
- Updates the idea to be a company idea with the specified company ID
- Sets the integration status to 'pending_approval'
- Returns a boolean indicating success

## TypeScript Type Changes

Updated the TypeScript types to support the new ownership model:

### 1. Added `OwnershipType` Type

```typescript
/**
 * Ownership type for ideas
 */
export type OwnershipType = 'personal' | 'company';
```

### 2. Updated `EnhancedIdeaPlaygroundIdea` Interface

Added new fields to the interface:

```typescript
// Ownership and creator information
creatorId?: string;
ownershipType: OwnershipType;
```

## API Service Updates

The API service was updated to support the new ownership model:

### 1. Updated `fetchIdeas` Function

Modified to include the new ownership fields in the returned data:

```typescript
// Transform the data to match our enhanced idea structure
return (data || []).map((item: any) => ({
  // ...existing fields
  
  // Ownership and creator information
  creatorId: item.creator_id,
  ownershipType: (item.ownership_type || 'personal') as OwnershipType,
  
  // ...other fields
}));
```

### 2. Updated `createIdea` Function

Modified to set the creator ID to the current user and default ownership type to 'personal':

```typescript
// Get the current user's ID
const { data: { user } } = await supabase.auth.getUser();
if (!user) {
  throw new Error('User not authenticated');
}

// Transform the enhanced idea structure to match the database schema
const dbData = {
  // ...existing fields
  
  // Set creator and ownership
  creator_id: user.id,
  ownership_type: ideaData.ownershipType || 'personal',
  
  // ...other fields
};
```

### 3. Added `promoteIdeaToCompany` Function

Added a new function to promote a personal idea to a company idea:

```typescript
/**
 * Promote a personal idea to a company idea
 */
export const promoteIdeaToCompany = async (ideaId: string, companyId: string): Promise<boolean> => {
  try {
    // Call the database function we created in the migration
    const { data, error } = await supabase
      .rpc('promote_idea_to_company', {
        idea_id: ideaId,
        target_company_id: companyId
      });
    
    if (error) {
      handleSupabaseError(error);
      throw new Error(`Error promoting idea to company: ${error.message}`);
    }
    
    // The function returns a boolean indicating success
    return data || false;
    
  } catch (error) {
    console.error('Error in promoteIdeaToCompany:', error);
    return false;
  }
};
```

## How to Run the Migration

To apply the database changes, run the following command:

```bash
node scripts/run-idea-ownership-migration.js
```

This script will:
1. Check if the migration file exists
2. Apply the migration using the Supabase CLI
3. If that fails, attempt to apply it using psql directly

## Troubleshooting

If you encounter the error `column "user_id" does not exist` during migration, it means the `idea_playground_ideas` table doesn't have a `user_id` column. This is expected, as we're transitioning to use `creator_id` instead. The migration has been updated to handle this case.

## Next Steps

1. Update UI components to display ownership information
2. Add UI controls for promoting personal ideas to company ideas
3. Implement filtering by ownership type in the idea list views

================
File: docs/idea-playground/README.md
================
# Idea Playground: Modular Architecture

## Overview

The Idea Playground component of wheel99 has been refactored into a modular architecture to address issues with the previous monolithic implementation. This new architecture improves maintainability, enhances error handling (especially for AI features), and provides a more robust foundation for future development.

## Quick Links

- [Architecture Documentation](./MODULAR_ARCHITECTURE.md) - Detailed overview of the architecture
- [Implementation Summary](./IMPLEMENTATION_SUMMARY.md) - Key components and improvements
- [Migration Guide](#migration-guide) - Instructions for migrating to the new architecture

## Key Files

```
src/lib/services/
├── idea-playground.service.facade.ts         # Main facade service
├── settings.ts                               # Configuration settings
└── idea-playground/
    ├── index.ts                              # Export hub for all modules
    ├── type-compatibility.ts                 # Legacy compatibility tools
    ├── canvas.service.ts                     # Business model canvas service
    └── llm/                                  # LLM integration
        ├── orchestrator.ts                   # LLM workflow coordination
        ├── adapters/
        │   ├── interface.ts                  # LLM adapter interface
        │   └── openai.adapter.ts             # OpenAI implementation
        └── context/
            ├── interface.ts                  # Context provider interface
            └── ...
```

## Key Improvements

1. **Modular Architecture**: Services are separated into focused, loosely coupled modules
2. **Improved Error Handling**: Robust fallbacks for AI-related failures
3. **Type Safety**: Enhanced TypeScript typing throughout the codebase
4. **Maintainability**: Easier to understand, test, and extend
5. **Compatibility**: Maintains API compatibility with existing code

## Migration Guide

To update your code to use the new architecture:

1. Import the service from the new location:
   ```typescript
   // Old
   import { ideaPlaygroundService } from '../services/idea-playground.service';
   
   // New
   import { ideaPlaygroundService } from '../services/idea-playground.service.facade';
   ```

2. Run the migration script to automatically update imports:
   ```bash
   bash scripts/run-modular-idea-playground.sh
   ```

3. Test your application to ensure everything works as expected.

4. For advanced usage, you can access specialized services through the facade:
   ```typescript
   const orchestrator = ideaPlaygroundService.getLLMOrchestrator();
   ```

## Testing

Run the test script to validate the modular implementation:

```bash
node scripts/test-modular-idea-playground.js
```

## AI Features

The new architecture addresses JSON parsing issues and error handling for AI-generated content:

- **Robust Parsing**: Handles malformed JSON from AI responses
- **Fallback Mechanisms**: Provides sensible defaults when AI services fail
- **Type Validation**: Ensures AI responses are converted to correct types

## Next Steps

Future enhancements to consider:

1. Complete implementation of remaining domain services
2. Add comprehensive test coverage
3. Enhanced AI provider support
4. Performance optimizations
5. Real-time collaboration features

## Support

For questions or issues, contact the development team or reference the detailed documentation in the `docs/idea-playground/` directory.

================
File: docs/idea-playground/REAL_AI_ONLY_MODE.md
================
# Real AI Only Mode for Idea Playground

## Overview

This document explains the implementation of the "Real AI Only" mode for the Idea Playground. This mode ensures that only genuine AI-generated ideas are presented to users, without any fallback to example/mock data.

## Key Changes

### Sequential Generation Service

The sequential generation service (`src/lib/services/idea-playground/ai/sequential-generation.service.ts`) has been modified to:

1. Only return genuine AI-generated suggestions
2. Skip any suggestions that fail to generate instead of falling back to mock data
3. Adjust the displayed count to reflect only the successfully generated suggestions
4. Implement a last-chance retry with longer timeout if no suggestions were generated at all

### Feature Flags

A script has been created to enable the Real AI feature flag:

```javascript
// scripts/enable-real-ai.js
const { featureFlagsService } = require('../src/lib/services/feature-flags.service');

async function enableRealAI() {
  try {
    console.log('Enabling Real AI and disabling Mock AI...');
    
    // Enable the Real AI feature flag
    await featureFlagsService.saveFeatureFlags({
      useRealAI: { enabled: true, visible: true },
      useMockAI: { enabled: false, visible: true }
    });
    
    // Reset the LLM service to use the new feature flags
    featureFlagsService.resetLLMService();
    
    console.log('Feature flags updated successfully.');
    console.log('Real AI is now enabled!');
  } catch (error) {
    console.error('Error enabling Real AI:', error);
  }
}

enableRealAI();
```

### UI Improvements

The suggestion screen (`src/components/idea-playground/pathway1/SuggestionsScreen.tsx`) has been updated to:

1. Clearly indicate that only AI-generated ideas are being used
2. Handle a potentially smaller number of suggestions gracefully
3. Show appropriate loading and error states

## Usage

You can toggle between AI modes using the provided scripts:

### Toggle Between Modes

To toggle between Real AI and Mock AI modes:

```
node scripts/toggle-ai-mode.js
```

This script will automatically detect the current mode and switch to the other mode.

### Explicitly Set a Mode

You can also set a specific mode:

```
# Set to Real AI Only Mode
node scripts/toggle-ai-mode.js real

# Set to Mock AI Mode (with examples)
node scripts/toggle-ai-mode.js mock
```

### Legacy Scripts

For backward compatibility, you can still use the single-purpose scripts:

```
# Enable Real AI Only Mode
node scripts/enable-real-ai.js
```

When Real AI Only Mode is active, the system will only generate genuine AI suggestions without any examples or mock data.

## Technical Details

The implementation follows these principles:

1. **Pure AI Generation**: Only genuine AI-generated suggestions are shown to users. When an AI generation attempt fails, that suggestion is simply skipped rather than being replaced with a mock.

2. **Quality over Quantity**: It's better to show fewer high-quality, genuinely AI-generated suggestions than to pad the list with mock examples.

3. **Transparent Feedback**: The UI clearly communicates to users that they are seeing only AI-generated content.

4. **Graceful Degradation**: If all AI generations fail, the system makes one final attempt with a longer timeout to try to provide at least one suggestion.

## Conclusion

This pure AI approach provides a more authentic experience for users, ensuring that all business ideas they see are unique, creative, and specifically tailored to their input rather than being pre-defined examples.

================
File: docs/idea-playground/REBUILD_OVERVIEW.md
================
# Idea Playground Rebuild: Overview

## Executive Summary

The Idea Playground is being completely rebuilt to address several critical issues with the current implementation:

1. **Performance Issues**: The current system suffers from sluggish response times and inefficient state management
2. **JSON Parsing Errors**: Frequent failures in AI response parsing cause unreliable functionality
3. **Maintainability Challenges**: Monolithic architecture makes updates and extensions difficult
4. **Poor Error Handling**: Inadequate recovery mechanisms when errors occur
5. **User Experience Inconsistencies**: Lack of feedback during AI operations creates uncertainty

This rebuild takes a modular, domain-driven approach with zero concern for backward compatibility, allowing for optimal architecture decisions. The new system will deliver substantial improvements in reliability, performance, and user experience.

## Key Architectural Decisions

### 1. Domain-Driven Design

The rebuilt system follows domain-driven design principles with:

- Rich domain models encapsulating business logic
- Distinct bounded contexts for different aspects (canvas, idea generation, refinement, etc.)
- Domain events for cross-domain communication
- Explicit aggregate boundaries

### 2. Microservice Architecture

- Independent services for each domain concern
- Clear interfaces between services
- Dependency injection for service composition
- Event-based communication for loose coupling

### 3. Enhanced AI Layer

- Robust orchestration layer for AI operations
- Schema validation for AI responses
- Advanced error recovery mechanisms
- Streaming responses for real-time feedback

### 4. Responsive UI Framework

- Optimistic updates for immediate feedback
- Progressive loading indicators
- Contextual error recovery
- Component-based architecture

## Timeline and Milestones

| Phase | Focus | Timeline | Key Deliverables |
|-------|-------|----------|------------------|
| 1 | Foundation | Week 1 | Core infrastructure, database schema, AI service layer |
| 2 | Core Domain Services | Week 2 | Domain models, repositories, basic UI foundation |
| 3 | Feature Implementation | Week 3 | Canvas management, idea generation, pathway features |
| 4 | UI Refinement | Week 4 | Advanced UI components, state management, user experience |
| 5 | Testing & Deployment | Week 5 | Comprehensive testing, performance optimization, deployment |

## Expected Outcomes and Benefits

### Performance Improvements

- 70% faster response times for AI operations
- Reduced memory consumption
- Smoother UI transitions and animations
- Optimized data loading patterns

### Reliability Enhancements

- 99% success rate for AI operations (up from ~80%)
- Graceful degradation when services fail
- Intelligent retry mechanisms
- Consistent error recovery

### Developer Experience

- Cleaner codebase with explicit boundaries
- Improved testability with dependency injection
- Better type safety throughout the system
- Clear patterns for extending functionality

### User Experience

- Instant feedback for user actions
- Clear progress indication for AI operations
- Contextual error messages with recovery options
- Smoother transitions between states

## Strategic Alignment

This rebuild supports strategic business goals by:

1. **Enabling Rapid Innovation**: The modular architecture allows for faster feature development
2. **Improving User Satisfaction**: Enhanced reliability and performance increase user retention
3. **Reducing Support Burden**: Fewer errors and better error handling reduce support requests
4. **Supporting Scalability**: The new architecture can scale to handle increased usage

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Integration challenges between domains | Medium | High | Clear interfaces, comprehensive integration testing |
| AI service reliability issues | High | High | Robust error handling, fallback mechanisms |
| Performance regressions | Low | Medium | Performance testing throughout development |
| Extended migration timeline | Medium | Medium | Phased approach with clear milestones |

================
File: docs/idea-playground/REDIRECT_FIX.md
================
# Idea Playground Redirect Fix

## Issue

Users were encountering a 404 error when trying to access the `/idea-playground` URL directly. This was happening because the actual route defined in the application is `/idea-hub/playground`, but users were trying to access the shorter URL.

Error message:
```
No routes matched location "/idea-playground"
```

## Solution

We implemented a redirect in the router configuration to automatically redirect users from `/idea-playground` to `/idea-hub/playground`. This ensures that users can access the Idea Playground feature using either URL.

### Implementation Details

The fix was implemented by adding redirect routes in `App.tsx` for both authenticated and unauthenticated users:

1. For unauthenticated users:
```jsx
<Route path="/idea-playground" element={<Navigate to="/idea-hub/playground" replace />} />
```

2. For authenticated users:
```jsx
<Route path="idea-playground" element={<Navigate to="/idea-hub/playground" replace />} />
```

The `replace` prop ensures that the redirect doesn't add a new entry to the browser history stack, making the back button work correctly.

### Testing

A test script was created at `scripts/test-idea-playground-redirect.js` to verify that the redirect works correctly. The script uses Puppeteer to:

1. Navigate to `/idea-playground`
2. Check if the browser is redirected to `/idea-hub/playground`

To run the test:
```bash
node scripts/test-idea-playground-redirect.js
```

## Benefits

- Improves user experience by handling common URL variations
- Prevents 404 errors when users try to access the shorter URL
- Maintains backward compatibility if the URL was shared or bookmarked

## Future Considerations

If more URL aliases are needed in the future, the same pattern can be applied by adding additional redirect routes in the router configuration.

================
File: docs/idea-playground/REQUIREMENTS.md
================
# Idea Playground Rebuild: Requirements Specification

## 1. Introduction

### 1.1 Purpose

This document specifies the requirements for the complete rebuild of the Idea Playground feature within the Wheel99 platform. It serves as the definitive reference for all development, testing, and validation activities related to the rebuild project.

### 1.2 Scope

The Idea Playground rebuild encompasses:
- Complete redesign of the architecture and codebase
- Enhanced AI integration for idea generation and refinement
- Improved user interface with better feedback mechanisms
- Robust error handling and recovery systems

### 1.3 Definitions

| Term | Definition |
|------|------------|
| Canvas | A container for organizing related business ideas |
| Idea | A business concept with defined attributes (title, description, etc.) |
| Variation | A derivative of an original idea with unique characteristics |
| SWOT | Strengths, Weaknesses, Opportunities, and Threats analysis |
| Refinement | The process of enhancing and detailing an idea |

### 1.4 System Context

The Idea Playground interacts with:
- User authentication system
- Profile and company data
- AI services (OpenAI)
- Database storage (Supabase)
- Logging and analytics systems

## 2. Functional Requirements

### 2.1 Canvas Management

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-CM-001 | Users shall be able to create a new canvas with name and description | High |
| FR-CM-002 | Users shall be able to view all canvases they own or collaborate on | High |
| FR-CM-003 | Users shall be able to edit canvas details | Medium |
| FR-CM-004 | Users shall be able to delete a canvas and all contained ideas | Medium |
| FR-CM-005 | Users shall be able to add collaborators to a canvas | Medium |
| FR-CM-006 | Users shall be able to organize canvases with tags | Low |

### 2.2 Idea Generation

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-IG-001 | Users shall be able to manually create ideas within a canvas | High |
| FR-IG-002 | Users shall be able to generate ideas using AI assistance | High |
| FR-IG-003 | AI-generated ideas shall include title, description, problem statement, and target audience | High |
| FR-IG-004 | Users shall be able to provide input parameters for AI idea generation | High |
| FR-IG-005 | Users shall be able to regenerate ideas if not satisfied with results | Medium |
| FR-IG-006 | Users shall receive real-time updates during idea generation | Medium |

### 2.3 Idea Variations

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-IV-001 | The system shall generate 3-5 variations of a selected idea | High |
| FR-IV-002 | Each variation shall have a unique approach or target market | High |
| FR-IV-003 | Variations shall include a complete SWOT analysis | High |
| FR-IV-004 | Users shall be able to select one or more variations for further refinement | High |
| FR-IV-005 | Users shall be able to compare variations side-by-side | Medium |
| FR-IV-006 | The system shall preserve the original idea while creating variations | Medium |

### 2.4 Idea Merging

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-IM-001 | Users shall be able to select multiple variations to merge | High |
| FR-IM-002 | The system shall generate 2-3 merged ideas based on selected variations | High |
| FR-IM-003 | Merged ideas shall combine strengths from source variations | High |
| FR-IM-004 | Users shall be able to view relationships between merged ideas and source variations | Medium |
| FR-IM-005 | Users shall be able to select a final merged idea to proceed with | High |
| FR-IM-006 | Users shall be able to edit merged ideas manually | Medium |

### 2.5 Idea Refinement

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-IR-001 | Users shall be able to refine any idea with additional details | High |
| FR-IR-002 | The system shall provide AI assistance for idea refinement | High |
| FR-IR-003 | Refinement shall include business model generation | High |
| FR-IR-004 | Refinement shall include market validation questions | Medium |
| FR-IR-005 | Users shall be able to save and resume refinement progress | Medium |
| FR-IR-006 | The system shall suggest improvements based on idea content | Medium |

### 2.6 Collaboration

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-CO-001 | Users shall be able to share canvases with team members | Medium |
| FR-CO-002 | Users shall be able to leave comments on ideas | Medium |
| FR-CO-003 | The system shall notify users of changes to shared canvases | Low |
| FR-CO-004 | Users shall be able to control edit permissions for collaborators | Low |

### 2.7 Export and Integration

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-EI-001 | Users shall be able to export ideas in multiple formats (PDF, DOCX) | Low |
| FR-EI-002 | Users shall be able to share ideas via link | Low |
| FR-EI-003 | The system shall support integration with project management tools | Low |

## 3. Non-Functional Requirements

### 3.1 Performance

| ID | Requirement | Priority |
|----|-------------|----------|
| NFR-P-001 | AI idea generation shall complete within 15 seconds | High |
| NFR-P-002 | AI variation generation shall complete within 15 seconds | High |
| NFR-P-003 | The UI shall remain responsive during AI operations | High |
| NFR-P-004 | The system shall support pagination for canvases with 50+ ideas | Medium |
| NFR-P-005 | Canvas load time shall not exceed 2 seconds | Medium |

### 3.2 Reliability

| ID | Requirement | Priority |
|----|-------------|----------|
| NFR-R-001 | The system shall achieve 99% uptime | High |
| NFR-R-002 | The system shall gracefully handle AI service failures | High |
| NFR-R-003 | The system shall implement automated retry for failed AI operations | High |
| NFR-R-004 | The system shall preserve user input during failures | High |
| NFR-R-005 | Recovery from failures shall not require user to restart from beginning | High |

### 3.3 Usability

| ID | Requirement | Priority |
|----|-------------|----------|
| NFR-U-001 | The UI shall provide clear feedback for all operations | High |
| NFR-U-002 | The system shall display meaningful error messages | High |
| NFR-U-003 | The system shall provide contextual help for complex features | Medium |
| NFR-U-004 | The UI shall be responsive across desktop and tablet devices | Medium |
| NFR-U-005 | The system shall support keyboard navigation | Low |

### 3.4 Security

| ID | Requirement | Priority |
|----|-------------|----------|
| NFR-S-001 | User data shall be accessible only to authorized users | High |
| NFR-S-002 | Canvas sharing shall require explicit permission | High |
| NFR-S-003 | All API requests shall be authenticated | High |
| NFR-S-004 | User actions shall be logged for audit purposes | Medium |

### 3.5 Scalability

| ID | Requirement | Priority |
|----|-------------|----------|
| NFR-SC-001 | The system shall support 1000+ concurrent users | Medium |
| NFR-SC-002 | The system shall support 10,000+ canvases per tenant | Medium |
| NFR-SC-003 | The system shall handle 100+ ideas per canvas without performance degradation | Medium |

### 3.6 Maintainability

| ID | Requirement | Priority |
|----|-------------|----------|
| NFR-M-001 | The codebase shall follow TypeScript best practices | High |
| NFR-M-002 | The system shall achieve 80%+ unit test coverage | High |
| NFR-M-003 | The system shall use dependency injection for service composition | High |
| NFR-M-004 | The system shall have comprehensive API documentation | Medium |
| NFR-M-005 | The system shall log detailed error information for troubleshooting | Medium |

## 4. Constraints and Assumptions

### 4.1 Technical Constraints

- Development must use TypeScript, React, and Supabase
- AI operations must use OpenAI's API
- The system must work within the existing authentication framework
- The system must integrate with the existing logging infrastructure

### 4.2 Business Constraints

- The rebuild must be completed within 5 weeks
- The system must support the existing user base
- The system should not require additional infrastructure costs

### 4.3 Key Assumptions

- OpenAI API will remain available and compatible
- Supabase will support the required data volume and query patterns
- Users have modern browsers that support required JavaScript features
- Existing authentication and authorization systems are sufficient

## 5. Requirement Traceability Matrix

| Requirement ID | User Story | Component | Test Case |
|----------------|------------|-----------|-----------|
| FR-CM-001 | US-CM-001 | CanvasCreationForm | TC-CM-001 |
| FR-IG-001 | US-IG-001 | IdeaGenerationForm | TC-IG-001 |
| FR-IV-001 | US-IV-001 | VariationGenerator | TC-IV-001 |
| FR-IM-001 | US-IM-001 | VariationSelector | TC-IM-001 |
| FR-IR-001 | US-IR-001 | IdeaRefinementPanel | TC-IR-001 |
| NFR-P-001 | US-PERF-001 | AIService | TC-PERF-001 |
| NFR-R-001 | US-REL-001 | ErrorHandling | TC-REL-001 |
| NFR-U-001 | US-USA-001 | ProgressIndicator | TC-USA-001 |

================
File: docs/idea-playground/TRAINING_PIPELINE.md
================
# Training Pipeline Implementation

This document details the continuous learning and Hugging Face integration in the Idea Playground system.

## Overview

The training pipeline enables the system to continuously improve by learning from user interactions with generated ideas. It includes:

- Data collection and preparation
- Filtering and obfuscation
- Hugging Face model hosting and training
- Versioning and deployment

```mermaid
graph TD
    subgraph "Data Collection"
        INT[Interaction Tracking]
        FBK[Feedback Collection]
        IPS[IP Protection Settings]
    end
    
    subgraph "Data Processing"
        PRE[Preprocessing]
        FIL[Filtering]
        OBF[Obfuscation]
        ENC[Encoding]
    end
    
    subgraph "Training"
        HP[Hyperparameter Tuning]
        TRN[Training Loop]
        VAL[Validation]
    end
    
    subgraph "Deployment"
        MOD[Model Registry]
        HF[Hugging Face Spaces]
        THK[Local Inference]
    end
    
    INT --> PRE
    FBK --> PRE
    IPS --> FIL
    
    PRE --> FIL
    FIL --> OBF
    OBF --> ENC
    
    ENC --> TRN
    HP --> TRN
    TRN --> VAL
    VAL --> MOD
    
    MOD --> HF
    HF --> THK
```

## Training Data Collection

### Interaction Tracking

The system captures all user interactions with ideas:

```typescript
// src/lib/services/idea-playground/interaction-tracking.service.ts
export class IdeaInteractionTrackingService {
  /**
   * Track an interaction with an idea
   */
  async trackInteraction(interaction: Omit<IdeaInteraction, 'id' | 'timestamp'>): Promise<string> {
    try {
      const timestamp = new Date().toISOString();
      
      const { data, error } = await supabase
        .from('idea_interactions')
        .insert([{
          ...interaction,
          timestamp
        }])
        .select('id');
        
      if (error) throw error;
      
      // Update idea training status based on interaction
      await this.updateIdeaTrainingStatusFromInteraction(
        interaction.ideaId,
        interaction.interactionType
      );
      
      return data?.[0]?.id;
    } catch (error) {
      console.error('Error tracking idea interaction:', error);
      throw error;
    }
  }
  
  /**
   * Update idea training status based on interaction
   */
  private async updateIdeaTrainingStatusFromInteraction(
    ideaId: string,
    interactionType: IdeaInteractionType
  ): Promise<void> {
    try {
      let trainingStatus: string | null = null;
      
      // Map interaction types to training statuses
      switch (interactionType) {
        case IdeaInteractionType.POSITIVE_RATING:
        case IdeaInteractionType.SAVED:
        case IdeaInteractionType.IMPLEMENTED:
        case IdeaInteractionType.SHARED:
        case IdeaInteractionType.EXPORTED:
          trainingStatus = 'positive_example';
          break;
          
        case IdeaInteractionType.NEGATIVE_RATING:
        case IdeaInteractionType.DISMISSED:
        case IdeaInteractionType.LOW_ENGAGEMENT:
          trainingStatus = 'negative_example';
          break;
          
        case IdeaInteractionType.EDITED:
        case IdeaInteractionType.REFINED:
          trainingStatus = 'modified_example';
          break;
          
        case IdeaInteractionType.MERGED:
          trainingStatus = 'merged_example';
          break;
          
        // For neutral interactions, no change in training status
        default:
          return;
      }
      
      if (trainingStatus) {
        await supabase
          .from('ideas')
          .update({ training_status: trainingStatus })
          .eq('id', ideaId);
      }
    } catch (error) {
      console.error('Error updating idea training status:', error);
      // Non-critical error, just log it
    }
  }
}
```

### Training Session Management

```typescript
// src/lib/services/idea-playground/training-management.service.ts
export class TrainingManagementService {
  /**
   * Create a new training session
   */
  async createTrainingSession(): Promise<string> {
    try {
      const { data, error } = await supabase
        .from('training_sessions')
        .insert([{
          started_at: new Date().toISOString(),
          model_version: `v${Date.now()}`,
          status: 'pending'
        }])
        .select('id');
        
      if (error) throw error;
      
      return data[0].id;
    } catch (error) {
      console.error('Error creating training session:', error);
      throw error;
    }
  }
  
  /**
   * Update training session status
   */
  async updateSessionStatus(
    sessionId: string, 
    status: 'pending' | 'processing' | 'completed' | 'failed',
    metrics?: any
  ): Promise<void> {
    try {
      const updates: any = { status };
      
      if (status === 'completed') {
        updates.completed_at = new Date().toISOString();
      }
      
      if (metrics) {
        updates.metrics = metrics;
      }
      
      await supabase
        .from('training_sessions')
        .update(updates)
        .eq('id', sessionId);
    } catch (error) {
      console.error('Error updating training session:', error);
      throw error;
    }
  }
}
```

## Data Preprocessing

### Dataset Preparation Service

```typescript
// src/lib/services/idea-playground/training/dataset-preparation.service.ts
export class DatasetPreparationService {
  private protectionService: IdeaProtectionService;
  
  constructor(protectionService: IdeaProtectionService) {
    this.protectionService = protectionService;
  }
  
  /**
   * Prepare dataset for training
   */
  async prepareTrainingDataset(sessionId: string): Promise<{
    positiveExamples: IdeaPlaygroundIdea[];
    negativeExamples: IdeaPlaygroundIdea[];
    refinedExamples: { original: IdeaPlaygroundIdea; refined: IdeaPlaygroundIdea }[];
  }> {
    try {
      // Get ideas with training statuses
      const { data: ideas } = await supabase
        .from('ideas')
        .select('*')
        .not('training_status', 'is', null);
        
      if (!ideas || ideas.length === 0) {
        return {
          positiveExamples: [],
          negativeExamples: [],
          refinedExamples: []
        };
      }
      
      // Filter based on IP protection settings
      const filteredIdeas = await this.protectionService.filterIdeasForTraining(ideas);
      
      // Separate by training status
      const positiveExamples = filteredIdeas.filter(idea => 
        idea.training_status === 'positive_example'
      );
      
      const negativeExamples = filteredIdeas.filter(idea => 
        idea.training_status === 'negative_example'
      );
      
      // Get refined examples
      const refinedExamples = await this.getRefinedExamples(filteredIdeas);
      
      // Track ideas used in training
      await this.recordTrainingIdeas(sessionId, {
        positiveExamples,
        negativeExamples,
        refinedExamples
      });
      
      return {
        positiveExamples,
        negativeExamples,
        refinedExamples
      };
    } catch (error) {
      console.error('Error preparing training dataset:', error);
      throw error;
    }
  }
  
  /**
   * Get refined examples with original and refined versions
   */
  private async getRefinedExamples(ideas: IdeaPlaygroundIdea[]): Promise<{ 
    original: IdeaPlaygroundIdea; 
    refined: IdeaPlaygroundIdea 
  }[]> {
    const modifiedIdeas = ideas.filter(idea => 
      idea.training_status === 'modified_example'
    );
    
    const refinedExamples: { 
      original: IdeaPlaygroundIdea; 
      refined: IdeaPlaygroundIdea 
    }[] = [];
    
    // For each modified idea, find the original version from interactions
    for (const idea of modifiedIdeas) {
      const { data: interactions } = await supabase
        .from('idea_interactions')
        .select('previous_version, new_version')
        .eq('idea_id', idea.id)
        .eq('interaction_type', 'edited')
        .order('timestamp', { ascending: false })
        .limit(1);
        
      if (interactions && interactions.length > 0 && 
          interactions[0].previous_version && 
          interactions[0].new_version) {
        refinedExamples.push({
          original: interactions[0].previous_version,
          refined: interactions[0].new_version
        });
      }
    }
    
    return refinedExamples;
  }
  
  /**
   * Record which ideas were used in training
   */
  private async recordTrainingIdeas(
    sessionId: string,
    dataset: {
      positiveExamples: IdeaPlaygroundIdea[];
      negativeExamples: IdeaPlaygroundIdea[];
      refinedExamples: { original: IdeaPlaygroundIdea; refined: IdeaPlaygroundIdea }[];
    }
  ): Promise<void> {
    const trainingIdeasToInsert = [];
    
    // Add positive examples
    for (const idea of dataset.positiveExamples) {
      trainingIdeasToInsert.push({
        training_session_id: sessionId,
        idea_id: idea.id,
        included_as: 'positive',
        obfuscated: false
      });
    }
    
    // Add negative examples
    for (const idea of dataset.negativeExamples) {
      trainingIdeasToInsert.push({
        training_session_id: sessionId,
        idea_id: idea.id,
        included_as: 'negative',
        obfuscated: false
      });
    }
    
    // Add modified examples
    for (const { original, refined } of dataset.refinedExamples) {
      trainingIdeasToInsert.push({
        training_session_id: sessionId,
        idea_id: original.id,
        included_as: 'modified',
        obfuscated: false
      });
    }
    
    // Record all training ideas
    if (trainingIdeasToInsert.length > 0) {
      await supabase
        .from('training_ideas')
        .insert(trainingIdeasToInsert);
      
      // Update training data count
      await supabase
        .from('training_sessions')
        .update({ 
          training_data_count: trainingIdeasToInsert.length 
        })
        .eq('id', sessionId);
    }
  }
}
```

## Data Obfuscation

For privacy, we obfuscate sensitive idea data before training:

```typescript
// src/lib/services/idea-playground/training/data-obfuscation.service.ts
export class DataObfuscationService {
  /**
   * Obfuscate sensitive data in ideas
   */
  obfuscateIdeas(
    ideas: IdeaPlaygroundIdea[], 
    level: 'basic' | 'complete' = 'basic'
  ): IdeaPlaygroundIdea[] {
    return ideas.map(idea => this.obfuscateIdea(idea, level));
  }
  
  /**
   * Obfuscate a single idea
   */
  private obfuscateIdea(
    idea: IdeaPlaygroundIdea,
    level: 'basic' | 'complete'
  ): IdeaPlaygroundIdea {
    const obfuscated = { ...idea };
    
    // Basic obfuscation removes user-specific identifiers
    if (level === 'basic' || level === 'complete') {
      delete obfuscated.user_id;
      delete obfuscated.owner_user_id;
      delete obfuscated.created_by;
      
      // Remove implementation details
      delete obfuscated.company_name;
      delete obfuscated.legal_status;
    }
    
    // Complete obfuscation generalizes the idea content
    if (level === 'complete') {
      // Generalize industry-specific terms
      obfuscated.title = this.generalizeText(obfuscated.title);
      obfuscated.description = this.generalizeText(obfuscated.description);
      obfuscated.problem_statement = this.generalizeText(obfuscated.problem_statement);
      obfuscated.solution_concept = this.generalizeText(obfuscated.solution_concept);
      
      // Generalize target audience
      if (typeof obfuscated.target_audience === 'string') {
        obfuscated.target_audience = this.generalizeText(obfuscated.target_audience);
      } else if (Array.isArray(obfuscated.target_audience)) {
        obfuscated.target_audience = obfuscated.target_audience.map(
          audience => this.generalizeText(audience)
        );
      }
      
      // Generalize business specifics
      obfuscated.unique_value = this.generalizeText(obfuscated.unique_value);
      obfuscated.business_model = this.generalizeText(obfuscated.business_model);
    }
    
    return obfuscated;
  }
  
  /**
   * Replace specific terms with more general concepts
   */
  private generalizeText(text: string): string {
    if (!text) return text;
    
    // Replace company names with [COMPANY]
    text = text.replace(/\b([A-Z][a-z]+){2,}\b/g, '[COMPANY]');
    
    // Replace specific numbers with [NUMBER]
    text = text.replace(/\b\d+(\.\d+)?\b/g, '[NUMBER]');
    
    // Replace emails with [EMAIL]
    text = text.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]');
    
    // Replace URLs with [URL]
    text = text.replace(/https?:\/\/[^\s]+/g, '[URL]');
    
    return text;
  }
}
```

## Hugging Face Integration

### Model Configuration

```typescript
// src/lib/services/idea-playground/huggingface/model-config.ts
export interface HuggingFaceModelConfig {
  modelId: string;
  taskType: 'text-generation' | 'text-classification' | 'feature-extraction';
  apiKey: string;
  organizationId?: string;
  spaceId?: string;
}

export const defaultModelConfig: HuggingFaceModelConfig = {
  modelId: 'wheel99/idea-playground-generator',
  taskType: 'text-generation',
  apiKey: process.env.HUGGING_FACE_API_KEY || ''
};

export const embeddingModelConfig: HuggingFaceModelConfig = {
  modelId: 'wheel99/idea-playground-embeddings',
  taskType: 'feature-extraction',
  apiKey: process.env.HUGGING_FACE_API_KEY || ''
};
```

### Hugging Face Adapter

```typescript
// src/lib/services/idea-playground/llm/adapters/huggingface.adapter.ts
import { HfInference } from '@huggingface/inference';
import { LLMAdapter } from './interface';
import { defaultModelConfig, embeddingModelConfig } from '../huggingface/model-config';

export class HuggingFaceAdapter implements LLMAdapter {
  private hf: HfInference;
  private config = defaultModelConfig;
  private embeddingConfig = embeddingModelConfig;
  
  constructor(config?: Partial<typeof defaultModelConfig>) {
    if (config) {
      this.config = { ...this.config, ...config };
    }
    
    this.hf = new HfInference(this.config.apiKey);
  }
  
  async generateText(prompt: string, options: any = {}): Promise<string> {
    try {
      const response = await this.hf.textGeneration({
        model: options.model || this.config.modelId,
        inputs: prompt,
        parameters: {
          temperature: options.temperature ?? 0.7,
          max_new_tokens: options.maxTokens ?? 1000,
          do_sample: true
        }
      });
      
      return response.generated_text || '';
    } catch (error) {
      console.error('Hugging Face text generation error:', error);
      throw error;
    }
  }
  
  async generateEmbedding(text: string): Promise<number[]> {
    try {
      const response = await this.hf.featureExtraction({
        model: this.embeddingConfig.modelId,
        inputs: text
      });
      
      // Returned embeddings might be nested arrays
      if (Array.isArray(response) && Array.isArray(response[0])) {
        // Return mean pooling of token embeddings
        const embeddings = response as number[][];
        
        // Calculate mean for each dimension
        const dimensions = embeddings[0].length;
        const meanEmbedding = new Array(dimensions).fill(0);
        
        for (const embedding of embeddings) {
          for (let i = 0; i < dimensions; i++) {
            meanEmbedding[i] += embedding[i] / embeddings.length;
          }
        }
        
        return meanEmbedding;
      }
      
      return response as number[];
    } catch (error) {
      console.error('Hugging Face embedding generation error:', error);
      throw error;
    }
  }
  
  async generateIdeaVariations(originalIdea: any, count: number): Promise<any[]> {
    // Similar implementation to OpenAI adapter
    const prompt = `
      Generate ${count} variations of the following business idea:
      
      Title: ${originalIdea.title}
      Description: ${originalIdea.description}
      Problem Statement: ${originalIdea.problem_statement}
      
      Each variation should have a different angle, target market, or implementation approach.
      Provide the result as a JSON array of ideas, each with the following properties:
      title, description, problem_statement, solution_concept, target_audience, unique_value.
    `;
    
    try {
      const jsonResponse = await this.generateText(prompt, {
        temperature: 0.8
      });
      
      // Parse JSON response
      return JSON.parse(jsonResponse);
    } catch (error) {
      console.error('Error generating idea variations:', error);
      return [];
    }
  }
  
  async refineIdea(idea: any, feedback: string): Promise<any> {
    // Similar implementation to OpenAI adapter
    const prompt = `
      Refine the following business idea based on this feedback:
      
      ORIGINAL IDEA:
      Title: ${idea.title}
      Description: ${idea.description}
      Problem Statement: ${idea.problem_statement}
      Solution Concept: ${idea.solution_concept}
      Target Audience: ${typeof idea.target_audience === 'string' ? idea.target_audience : idea.target_audience.join(', ')}
      Unique Value: ${idea.unique_value}
      
      FEEDBACK:
      ${feedback}
      
      Provide the refined idea as a JSON object with the same properties as the original.
      Make sure to address all the feedback points.
    `;
    
    try {
      const jsonResponse = await this.generateText(prompt, {
        temperature: 0.5
      });
      
      // Parse JSON response
      return JSON.parse(jsonResponse);
    } catch (error) {
      console.error('Error refining idea:', error);
      return idea; // Return original idea on error
    }
  }
  
  async isAvailable(): Promise<boolean> {
    try {
      // Simple test call to check if API is available
      await this.hf.textGeneration({
        model: this.config.modelId,
        inputs: 'This is a test.'
      });
      return true;
    } catch (error) {
      console.error('Hugging Face API is not available:', error);
      return false;
    }
  }
}
```

## Training Automation

### Training Pipeline Service

```typescript
// src/lib/services/idea-playground/training/training-pipeline.service.ts
export class TrainingPipelineService {
  private datasetService: DatasetPreparationService;
  private obfuscationService: DataObfuscationService;
  private trainingService: TrainingManagementService;
  
  constructor(
    datasetService: DatasetPreparationService,
    obfuscationService: DataObfuscationService,
    trainingService: TrainingManagementService
  ) {
    this.datasetService = datasetService;
    this.obfuscationService = obfuscationService;
    this.trainingService = trainingService;
  }
  
  /**
   * Run the full training pipeline
   */
  async runTrainingPipeline(): Promise<string> {
    try {
      // Create a new training session
      const sessionId = await this.trainingService.createTrainingSession();
      
      // Update session status
      await this.trainingService.updateSessionStatus(sessionId, 'processing');
      
      // Prepare dataset
      const dataset = await this.datasetService.prepareTrainingDataset(sessionId);
      
      // Check if we have enough data
      const totalExamples = 
        dataset.positiveExamples.length + 
        dataset.negativeExamples.length + 
        dataset.refinedExamples.length;
        
      if (totalExamples < 10) {
        await this.trainingService.updateSessionStatus(
          sessionId, 
          'failed', 
          { error: 'Not enough training data' }
        );
        throw new Error('Not enough training data');
      }
      
      // Obfuscate data
      const obfuscatedPositives = this.obfuscationService.obfuscateIdeas(
        dataset.positiveExamples
      );
      
      const obfuscatedNegatives = this.obfuscationService.obfuscateIdeas(
        dataset.negativeExamples
      );
      
      const obfuscatedRefined = dataset.refinedExamples.map(example => ({
        original: this.obfuscationService.obfuscateIdeas([example.original])[0],
        refined: this.obfuscationService.obfuscateIdeas([example.refined])[0]
      }));
      
      // Format dataset for Hugging Face
      const formattedDataset = this.formatForHuggingFace({
        positiveExamples: obfuscatedPositives,
        negativeExamples: obfuscatedNegatives,
        refinedExamples: obfuscatedRefined
      });
      
      // Start training process
      const modelVersion = await this.trainModel(formattedDataset);
      
      // Update session with results
      await this.trainingService.updateSessionStatus(
        sessionId, 
        'completed', 
        { 
          model_version: modelVersion,
          examples_count: totalExamples
        }
      );
      
      return modelVersion;
    } catch (error) {
      console.error('Error running training pipeline:', error);
      throw error;
    }
  }
  
  /**
   * Format dataset for Hugging Face training
   */
  private formatForHuggingFace(dataset: any): any {
    // Implementation depends on Hugging Face dataset format requirements
    // This is a placeholder for the actual implementation
    return {
      positive_examples: dataset.positiveExamples,
      negative_examples: dataset.negativeExamples,
      refined_examples: dataset.refinedExamples
    };
  }
  
  /**
   * Train the model using Hugging Face
   */
  private async trainModel(formattedDataset: any): Promise<string> {
    // This would contain code to interact with Hugging Face's training API
    // or to upload the dataset to a Hugging Face training pipeline
    
    // For now, we'll simulate the training process
    return `model_${Date.now()}`;
  }
}
```

## Local Inference

### Local Model Integration

```typescript
// src/lib/services/idea-playground/llm/adapters/local-model.adapter.ts
import type { InferenceSession } from 'onnxruntime-web';
import { LLMAdapter } from './interface';

export class LocalModelAdapter implements LLMAdapter {
  private modelSession: InferenceSession | null = null;
  private tokenizer: any = null;
  private modelLoading: Promise<void> | null = null;
  private embeddingModelSession: InferenceSession | null = null;
  
  constructor() {
    // Lazy load model when first used
  }
  
  /**
   * Load ONNX model and tokenizer
   */
  private async loadModel(): Promise<void> {
    if (this.modelSession !== null) return;
    
    if (this.modelLoading !== null) {
      return this.modelLoading;
    }
    
    this.modelLoading = (async () => {
      try {
        // Import dynamically to prevent SSR issues
        const ort = await import('onnxruntime-web');
        const { AutoTokenizer } = await import('@xenova/transformers');
        
        // Initialize tokenizer
        this.tokenizer = await AutoTokenizer.from_pretrained('wheel99/idea-playground-generator');
        
        // Initialize model
        this.modelSession = await ort.InferenceSession.create(
          '/models/idea_generator_quantized.onnx'
        );
        
        // Load embedding model
        this.embeddingModelSession = await ort.InferenceSession.create(
          '/models/idea_embeddings_quantized.onnx'
        );
      } catch (error) {
        console.error('Error loading local model:', error);
        this.modelSession = null;
        this.tokenizer = null;
        this.embeddingModelSession = null;
        throw error;
      }
    })();
    
    return this.modelLoading;
  }
  
  async generateText(prompt: string, options: any = {}): Promise<string> {
    try {
      await this.loadModel();
      
      if (!this.modelSession || !this.tokenizer) {
        throw new Error('Model not loaded');
      }
      
      // Tokenize input
      const tokenized = await this.tokenizer(prompt);
      
      // Run inference
      const outputs = await this.modelSession.run({
        input_ids: tokenized.input_ids,
        attention_mask: tokenized.attention_mask
      });
      
      // Decode output tokens
      const outputText = await this.tokenizer.decode(
        outputs.logits, 
        { skip_special_tokens: true }
      );
      
      return outputText;
    } catch (error) {
      console.error('Local text generation error:', error);
      throw error;
    }
  }
  
  async generateEmbedding(text: string): Promise<number[]> {
    try {
      await this.loadModel();
      
      if (!this.embeddingModelSession || !this.tokenizer) {
        throw new Error('Embedding model not loaded');
      }
      
      // Tokenize input
      const tokenized = await this.tokenizer(text, { padding: true, truncation: true });
      
      // Run inference
      const outputs = await this.embeddingModelSession.run({
        input_ids: tokenized.input_ids,
        attention_mask: tokenized.attention_mask
      });
      
      // Return the [CLS] token embedding as the text embedding
      // or calculate mean pooling across all token embeddings
      return Array.from(outputs.embeddings.data);
    } catch (error) {
      console.error('Local embedding generation error:', error);
      throw error;
    }
  }
  
  // Other methods would be implemented similarly to the HuggingFace adapter
  async generateIdeaVariations(originalIdea: any, count: number): Promise<any[]> {
    // Implementation similar to other adapters
    return [];
  }
  
  async refineIdea(idea: any, feedback: string): Promise<any> {
    // Implementation similar to other adapters
    return idea;
  }
  
  async isAvailable(): Promise<boolean> {
    try {
      await this.loadModel();
      return this.modelSession !== null;
    } catch (error) {
      return false;
    }
  }
}
```

## Automated Training Schedule

```typescript
// src/lib/services/idea-playground/training/automated-training.service.ts
export class AutomatedTrainingService {
  private trainingPipeline: TrainingPipelineService;
  private lastTrainingTimestamp: number = 0;
  private static readonly MIN_TRAINING_INTERVAL = 7 * 24 * 60 * 60 * 1000; // 1 week
  
  constructor(trainingPipeline: TrainingPipelineService) {
    this.trainingPipeline = trainingPipeline;
  }
  
  /**
   * Check if training should be triggered and run if needed
   */
  async checkAndTriggerTraining(): Promise<void> {
    const now = Date.now();
    
    // Don't train more frequently than MIN_TRAINING_INTERVAL
    if (now - this.lastTrainingTimestamp < AutomatedTrainingService.MIN_TRAINING_INTERVAL) {
      return;
    }
    
    // Check if we have enough new data since last training
    const hasEnoughNewData = await this.checkForNewTrainingData();
    
    if (hasEnoughNewData) {
      try {
        // Run training pipeline
        await this.trainingPipeline.runTrainingPipeline();
        
        // Update timestamp
        this.lastTrainingTimestamp = now;
      } catch (error) {
        console.error('Automated training failed:', error);
      }
    }
  }
  
  /**
   * Check if there's enough new data to justify training
   */
  private async checkForNewTrainingData(): Promise<boolean> {
    try {
      // Get latest training session
      const { data: latestSessions } = await supabase
        .from('training_sessions')
        .select('completed_at, training_data_count')
        .eq('status', 'completed')
        .order('completed_at', { ascending: false })
        .limit(1);
        
      if (!latestSessions || latestSessions.length === 0) {
        return true; // No previous training, so run it
      }
      
      const latestSession = latestSessions[0];
      const lastTrainingDate = new Date(latestSession.completed_at);
      
      // Count new interactions since last training
      const { count } = await supabase
        .from('idea_interactions')
        .select('id', { count: 'exact' })
        .gt('timestamp', lastTrainingDate.toISO

================
File: docs/idea-playground/USER_STORIES.md
================
# Idea Playground Rebuild: User Stories

## 1. User Personas

### 1.1 Founder/Entrepreneur

**Name**: Alex Chen  
**Role**: Startup Founder  
**Goals**:
- Generate innovative business ideas quickly
- Refine concepts into viable business models
- Evaluate and compare different approaches
- Document business ideas for sharing with potential investors

### 1.2 Product Manager

**Name**: Jordan Taylor  
**Role**: Product Manager  
**Goals**:
- Explore product variations based on market needs
- Evaluate strengths and weaknesses of different approaches
- Merge concepts to create stronger product ideas
- Organize ideas for team discussion

### 1.3 Business Strategist

**Name**: Morgan Rivera  
**Role**: Business Strategist  
**Goals**:
- Generate strategic initiatives for business growth
- Conduct comprehensive analyses of business opportunities
- Identify strengths and weaknesses of different approaches
- Develop go-to-market strategies for new concepts

### 1.4 UX Designer

**Name**: Sam Johnson  
**Role**: UX Designer  
**Goals**:
- Explore different user experience approaches
- Generate ideas focused on solving user problems
- Collaborate with team members on product concepts
- Document design rationales for new concepts

### 1.5 Marketing Professional

**Name**: Taylor Green  
**Role**: Marketing Director  
**Goals**:
- Generate marketing campaign ideas
- Identify target audiences for different approaches
- Analyze market positioning for new concepts
- Develop unique value propositions

## 2. Canvas Management Stories

### US-CM-001: Canvas Creation

**As a** founder, **I want to** create a new canvas, **so that** I can organize my business ideas in one place.

**Acceptance Criteria**:
- I can specify a name and description for my canvas
- I can create multiple canvases for different projects or concepts
- The canvas is immediately available after creation
- I can see a confirmation that the canvas was created successfully

### US-CM-002: Canvas Organization

**As a** product manager, **I want to** view all my canvases, **so that** I can navigate between different projects.

**Acceptance Criteria**:
- I can see a list of all canvases I own or collaborate on
- I can search for canvases by name
- I can filter canvases by tags or categories
- I can see summary information about each canvas

### US-CM-003: Canvas Collaboration

**As a** business strategist, **I want to** share my canvas with team members, **so that** we can collaborate on business ideas.

**Acceptance Criteria**:
- I can add collaborators to a canvas by email address
- Collaborators receive a notification when added to a canvas
- I can set permissions for each collaborator (view, edit)
- I can remove collaborators when needed

## 3. Idea Generation Stories

### US-IG-001: Manual Idea Creation

**As an** entrepreneur, **I want to** manually create a business idea, **so that** I can document my thoughts.

**Acceptance Criteria**:
- I can specify a title, description, and other key details
- The idea is saved within the selected canvas
- I can edit the idea after creation
- I can see a success message when the idea is saved

### US-IG-002: AI-Assisted Idea Generation

**As a** founder, **I want to** generate business ideas using AI, **so that** I can explore opportunities I might not have considered.

**Acceptance Criteria**:
- I can provide parameters to guide the AI (industry, market size, etc.)
- The AI generates detailed business ideas with all required fields
- I can see progress updates during the generation process
- I can regenerate ideas if I'm not satisfied with the results

### US-IG-003: Real-Time Generation Updates

**As a** user, **I want to** see real-time updates during AI idea generation, **so that** I know the system is working.

**Acceptance Criteria**:
- I can see a progress indicator during generation
- The system shows intermediate results as they become available
- I receive clear feedback if the generation is taking longer than expected
- I can cancel the generation process if desired

## 4. Idea Variation Stories

### US-IV-001: Generate Variations

**As a** product manager, **I want to** create variations of my product idea, **so that** I can explore different approaches.

**Acceptance Criteria**:
- I can select an existing idea to generate variations
- The system produces 3-5 distinct variations
- Each variation has unique characteristics but maintains the core concept
- Variations have complete details including SWOT analysis

### US-IV-002: Compare Variations

**As a** business strategist, **I want to** compare different idea variations side-by-side, **so that** I can evaluate their relative strengths.

**Acceptance Criteria**:
- I can view multiple variations in a comparison view
- I can see key differences highlighted between variations
- I can compare specific aspects (e.g., target market, revenue model)
- I can export the comparison for sharing

### US-IV-003: Select Variations

**As an** entrepreneur, **I want to** select promising variations, **so that** I can focus on the most viable options.

**Acceptance Criteria**:
- I can mark variations as selected or unselected
- The system visually indicates which variations are selected
- I can select multiple variations simultaneously
- My selection persists if I navigate away and return

## 5. Idea Merging Stories

### US-IM-001: Merge Selected Variations

**As a** product developer, **I want to** combine elements from multiple idea variations, **so that** I can create a stronger concept.

**Acceptance Criteria**:
- I can select multiple variations to merge
- The system intelligently combines the strengths from each variation
- I can review and refine the merged idea
- The relationship to source variations is maintained

### US-IM-002: View Merged Ideas

**As a** business strategist, **I want to** see how merged ideas combine elements from source variations, **so that** I understand the new concept's origins.

**Acceptance Criteria**:
- I can see which source variations contributed to the merged idea
- I can view specific elements that came from each source
- I can navigate between the merged idea and its sources
- I can see a visual representation of the relationships

### US-IM-003: Finalize Idea Selection

**As a** founder, **I want to** select a final idea from the merged options, **so that** I can proceed with detailed development.

**Acceptance Criteria**:
- I can compare merged ideas side-by-side
- I can select one idea as the final choice
- The system highlights the selected idea
- I can proceed to refinement with the selected idea

## 6. Idea Refinement Stories

### US-IR-001: Refine Business Model

**As an** entrepreneur, **I want to** refine my idea's business model, **so that** I can validate its commercial viability.

**Acceptance Criteria**:
- I can add detailed revenue streams
- I can define cost structure elements
- I can specify key partnerships and resources
- I can save my progress and return later

### US-IR-002: AI-Assisted Refinement

**As a** business strategist, **I want to** get AI assistance in refining my idea, **so that** I can identify improvement opportunities.

**Acceptance Criteria**:
- The AI suggests improvements based on best practices
- I can accept or reject individual suggestions
- The AI provides rationale for its suggestions
- I can request more detailed analysis in specific areas

### US-IR-003: Market Validation

**As a** product manager, **I want to** validate my idea against market data, **so that** I can assess its potential success.

**Acceptance Criteria**:
- The system provides relevant market validation questions
- I can see industry benchmarks where available
- The system highlights potential market challenges
- I receive recommendations for further research

## 7. Collaboration Stories

### US-CO-001: Comment on Ideas

**As a** team member, **I want to** leave comments on specific ideas, **so that** I can provide feedback to collaborators.

**Acceptance Criteria**:
- I can add comments to any idea in a shared canvas
- Comments show the author and timestamp
- I can edit or delete my own comments
- Other users are notified of new comments

### US-CO-002: Track Changes

**As a** canvas owner, **I want to** track changes made by collaborators, **so that** I stay informed of updates.

**Acceptance Criteria**:
- I can see an activity feed showing recent changes
- Each change shows who made it and when
- I can filter the activity feed by user or action type
- I receive notifications for important changes

## 8. User Story Map

```
                                     [Generate Ideas]
                                           |
                        +------------------+------------------+
                        |                  |                  |
                 [Create Canvas]    [Generate Ideas]    [Collaborate]
                        |                  |                  |
            +-----------+          +-------+-------+          +-----------+
            |           |          |       |       |          |           |
    [Create Canvas] [Organize]  [Manual] [AI-Assisted] [Share] [Comment]
            |           |          |       |       |          |           |
      +---------+  +--------+  +-----+  +-----+  +--------+  +-------+
      |         |  |        |  |     |  |     |  |        |  |       |
[Name/Desc] [Tag]  [Enter]  [Guide] [Progress] [Collab] [Feedback]


                                    [Refine Ideas]
                                           |
                        +------------------+------------------+
                        |                  |                  |
                 [Create Variations]  [Merge Ideas]    [Refine Details]
                        |                  |                  |
            +-----------+          +-------+-------+          +-----------+
            |           |          |       |       |          |           |
     [Generate]  [Compare]    [Select] [Combine] [Business]  [Market]
            |           |          |       |       |          |           |
      +---------+  +--------+  +-----+  +-----+  +--------+  +-------+
      |         |  |        |  |     |  |     |  |        |  |       |
 [Unique]  [SWOT]  [Multi] [Strength] [Model] [Validation]

================
File: docs/idea-playground-pathway1/AI_INTEGRATION.md
================
# Idea Playground Pathway 1: AI Integration

This document details the AI integration for the Idea Playground Pathway 1 feature, including prompt engineering, response handling, and optimization strategies.

## AI Integration Overview

The Idea Playground Pathway 1 feature leverages AI capabilities to:

1. Generate distinct variations of an original business idea (3-5 suggestions)
2. Merge multiple selected variations into new hybrid ideas
3. Regenerate specific suggestions with improvements

These operations use the OpenAI API through our existing `generalLLMService` to generate high-quality, diverse, and useful business concepts.

## Implementation Architecture

The AI integration is organized around a dedicated service class:

```typescript
// src/lib/services/idea-pathway1-ai.service.ts
export class IdeaPathway1AIService {
  async generateCompanySuggestions(
    idea: IdeaPlaygroundIdea,
    userId: string,
    count: number = 5
  ): Promise<Suggestion[]>
  
  async mergeSuggestions(
    suggestions: Suggestion[],
    userId: string
  ): Promise<Suggestion>
  
  async regenerateSuggestion(
    originalSuggestion: Suggestion,
    idea: IdeaPlaygroundIdea,
    userId: string
  ): Promise<Suggestion>
}
```

The service is instantiated as a singleton:

```typescript
export const ideaPathway1AIService = new IdeaPathway1AIService();
```

## AI Prompts

### Idea Suggestion Generation Prompt

This prompt instructs the AI to generate multiple distinct variations of an original idea, each with its own unique approach, target audience, or business model.

```typescript
private createSuggestionPrompt(idea: IdeaPlaygroundIdea, count: number): string {
  const userContext = idea.used_company_context 
    ? `This idea is part of an existing business. Consider how it might fit within 
       an established company's operations and strategy.` 
    : '';
    
  return `
    You are a creative business strategist and startup advisor with extensive knowledge of 
    markets, business models, and innovation strategies.
    
    ORIGINAL IDEA:
    Title: ${idea.title}
    Description: ${idea.description}
    Solution Concept: ${idea.solution_concept || 'Not specified'}
    ${userContext}
    
    TASK:
    Generate ${count} distinct and innovative variations of the original idea. Each variation should 
    have a unique angle or approach while still solving the core problem or addressing the core opportunity.
    
    For each variation, please provide:
    1. Title: A catchy, clear title
    2. Description: A concise description of the idea variation (1-2 sentences)
    3. Problem Statement: What problem does this solve?
    4. Solution Concept: How does this solution work?
    5. Target Audience: Who would use/buy this?
    6. Unique Value: What makes this variation special?
    7. Business Model: How would this make money?
    8. Marketing Strategy: How would you promote this?
    9. Revenue Model: Specific revenue streams
    10. Go-to-Market Strategy: Initial launch approach
    11. Market Size: Rough estimate of the addressable market
    12. Competition: List of 2-4 potential competitors
    13. Revenue Streams: 3-5 potential revenue sources
    14. Cost Structure: 3-5 major cost categories
    15. Key Metrics: 3-5 important KPIs to track
    
    SWOT ANALYSIS FOR EACH:
    - Strengths: 2-3 key strengths
    - Weaknesses: 2-3 key weaknesses
    - Opportunities: 2-3 market opportunities
    - Threats: 2-3 potential risks or threats
    
    FORMAT:
    Return the results in a valid JSON array format that I can parse directly. Each object should have all the above fields.
    
    IMPORTANT GUIDELINES:
    - Make each variation truly distinct, not just minor tweaks
    - Be realistic but creative
    - Consider different business models for each
    - Target different audience segments where appropriate
    - Each variation should have a clear revenue model
  `;
}
```

### Idea Merge Prompt

This prompt instructs the AI to merge multiple selected suggestions into a single cohesive business concept that takes the best elements from each source suggestion.

```typescript
private createMergePrompt(suggestions: Suggestion[]): string {
  // Extract titles for a more concise prompt summary
  const suggestionTitles = suggestions.map((s, i) => `${i+1}. ${s.title}`).join('\n');
  
  // Create detailed JSON for each suggestion
  const suggestionsJson = JSON.stringify(suggestions, null, 2);
  
  return `
    You are a creative business strategist and startup advisor tasked with merging multiple business ideas.
    
    TASK:
    Create a single, cohesive business idea that combines the best elements from these suggestions:
    ${suggestionTitles}
    
    Detailed information about each suggestion:
    ${suggestionsJson}
    
    Create a new merged business idea that:
    1. Takes the best elements from each suggestion
    2. Resolves any contradictions between the suggestions
    3. Creates something that's more than the sum of its parts
    4. Is coherent and practical
    
    FORMAT:
    Return a single merged suggestion in valid JSON format with the same fields as the input suggestions.
    
    Title the merged suggestion with "(Merged Concept)" at the end, e.g. "AI-Powered Health Platform (Merged Concept)".
    
    IMPORTANT:
    - The merged concept should be innovative yet realistic
    - Ensure all fields are filled out completely
    - Maintain the most compelling value propositions from the original concepts
    - Address the strongest target audience identified across concepts
  `;
}
```

### Suggestion Regeneration Prompt

This prompt instructs the AI to regenerate a specific suggestion with improvements while keeping the core concept intact.

```typescript
private createRegenerationPrompt(suggestion: Suggestion, idea: IdeaPlaygroundIdea): string {
  const suggestionJson = JSON.stringify(suggestion, null, 2);
  
  return `
    You are a creative business strategist and startup advisor with extensive knowledge of 
    markets, business models, and innovation strategies.
    
    ORIGINAL IDEA INPUT:
    Title: ${idea.title}
    Description: ${idea.description}
    Solution Concept: ${idea.solution_concept || 'Not specified'}
    
    CURRENT SUGGESTION TO IMPROVE:
    ${suggestionJson}
    
    TASK:
    Generate an improved version of this business idea. Keep the core concept but make it more:
    - Innovative
    - Marketable
    - Financially viable
    - Competitive
    
    Enhance all aspects of the idea, especially:
    - Value proposition
    - Business model
    - Target audience
    - Go-to-market strategy
    
    FORMAT:
    Return the improved suggestion in a valid JSON format with all the same fields as the input suggestion.
    
    IMPORTANT:
    - Make meaningful improvements, not superficial changes
    - Keep the fundamental concept intact while enhancing it
    - Ensure all fields are filled out completely
    - Be realistic but ambitious
  `;
}
```

## Response Handling

The service includes robust response handling to extract structured data from AI responses:

### JSON Extraction and Parsing

```typescript
private parseSuggestionsResponse(responseContent: string, originalIdea: IdeaPlaygroundIdea): Suggestion[] {
  try {
    // Find the JSON array in the response
    const jsonMatch = responseContent.match(/\[[\s\S]*\]/);
    
    if (jsonMatch) {
      const suggestions = JSON.parse(jsonMatch[0]);
      
      // Validate and clean up suggestions
      return suggestions.map((s: any) => this.validateAndCleanSuggestion(s, originalIdea));
    }
    
    // If no JSON array found, fall back to mock suggestions
    console.warn('Failed to parse AI response as JSON array');
    return this.generateMockSuggestions(originalIdea, 5);
  } catch (error) {
    console.error('Error parsing AI response:', error);
    return this.generateMockSuggestions(originalIdea, 5);
  }
}

private parseMergedSuggestion(responseContent: string, originalSuggestions: Suggestion[]): Suggestion {
  try {
    // Find the JSON object in the response
    const jsonMatch = responseContent.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      const suggestion = JSON.parse(jsonMatch[0]);
      
      // Validate and ensure the title indicates it's a merged concept
      const mergedSuggestion = this.validateAndCleanSuggestion(suggestion, null);
      
      // Make sure the title indicates it's a merged concept
      if (!mergedSuggestion.title.includes('(Merged Concept)')) {
        mergedSuggestion.title += ' (Merged Concept)';
      }
      
      return mergedSuggestion;
    }
    
    // If no JSON object found, fall back to basic merge
    console.warn('Failed to parse AI response as JSON object');
    return this.createBasicMergedSuggestion(originalSuggestions);
  } catch (error) {
    console.error('Error parsing AI merge response:', error);
    return this.createBasicMergedSuggestion(originalSuggestions);
  }
}
```

### Data Validation and Cleaning

A robust validation and cleaning function ensures that all suggestion data is complete and properly formatted:

```typescript
private validateAndCleanSuggestion(suggestion: any, originalIdea: IdeaPlaygroundIdea | null): Suggestion {
  // Default values from original idea if available
  const defaultTitle = originalIdea ? `Variation of ${originalIdea.title}` : 'New Business Idea';
  const defaultDescription = originalIdea?.description || 'No description provided';
  const defaultProblemStatement = originalIdea?.problem_statement || 'Problem statement not specified';
  const defaultSolutionConcept = originalIdea?.solution_concept || 'Solution not specified';
  
  // Ensure all required fields exist
  return {
    title: suggestion.title || defaultTitle,
    description: suggestion.description || defaultDescription,
    problem_statement: suggestion.problem_statement || defaultProblemStatement,
    solution_concept: suggestion.solution_concept || defaultSolutionConcept,
    target_audience: suggestion.target_audience || 'General market',
    unique_value: suggestion.unique_value || 'Unique value proposition not specified',
    business_model: suggestion.business_model || 'Business model not specified',
    marketing_strategy: suggestion.marketing_strategy || 'Marketing strategy not specified',
    revenue_model: suggestion.revenue_model || 'Revenue model not specified',
    go_to_market: suggestion.go_to_market || 'Go-to-market strategy not specified',
    market_size: suggestion.market_size || 'Market size not estimated',
    competition: Array.isArray(suggestion.competition) ? suggestion.competition : ['Not specified'],
    revenue_streams: Array.isArray(suggestion.revenue_streams) ? suggestion.revenue_streams : ['Not specified'],
    cost_structure: Array.isArray(suggestion.cost_structure) ? suggestion.cost_structure : ['Not specified'],
    key_metrics: Array.isArray(suggestion.key_metrics) ? suggestion.key_metrics : ['Not specified'],
    strengths: Array.isArray(suggestion.strengths) ? suggestion.strengths : ['Not specified'],
    weaknesses: Array.isArray(suggestion.weaknesses) ? suggestion.weaknesses : ['Not specified'],
    opportunities: Array.isArray(suggestion.opportunities) ? suggestion.opportunities : ['Not specified'],
    threats: Array.isArray(suggestion.threats) ? suggestion.threats : ['Not specified']
  };
}
```

### Fallback Mechanisms

The implementation includes robust fallback mechanisms for cases where AI generation fails:

1. **Mock Suggestions Generation**: When the AI fails to generate valid suggestions, the system can fall back to pre-defined templates:

```typescript
private generateMockSuggestions(idea: IdeaPlaygroundIdea, count: number): Suggestion[] {
  const mockSuggestions: Suggestion[] = [];
  
  const variants = [
    { suffix: 'Premium Edition', audience: 'Enterprise customers', model: 'Subscription' },
    { suffix: 'Lite Version', audience: 'Individual users', model: 'Freemium' },
    { suffix: 'Pro Edition', audience: 'Professional users', model: 'One-time purchase' },
    { suffix: 'Community Edition', audience: 'Communities and non-profits', model: 'Open source with paid support' },
    { suffix: 'Enterprise Solution', audience: 'Large corporations', model: 'Annual licensing' }
  ];
  
  // Generate the requested number of suggestions
  for (let i = 0; i < Math.min(count, variants.length); i++) {
    const variant = variants[i];
    
    mockSuggestions.push({
      title: `${idea.title} - ${variant.suffix}`,
      description: `A ${variant.suffix.toLowerCase()} of ${idea.title} targeting ${variant.audience.toLowerCase()}.`,
      // Additional fields populated with variant-specific values
      // ...
    });
  }
  
  return mockSuggestions;
}
```

2. **Basic Merge Logic**: For cases where AI merging fails, a basic algorithm combines elements from source suggestions:

```typescript
private createBasicMergedSuggestion(suggestions: Suggestion[]): Suggestion {
  if (suggestions.length === 0) {
    throw new Error('No suggestions to merge');
  }
  
  const baseSuggestion = suggestions[0];
  const allTitles = suggestions.map(s => s.title.replace(/ \(Merged Concept\)$/, ''));
  
  // Create a title that references the merged concepts
  const mergedTitle = allTitles.length <= 2 
    ? `${allTitles.join(' + ')} (Merged Concept)`
    : `${allTitles[0]} + ${allTitles.length - 1} More (Merged Concept)`;
  
  // Combine all unique elements from arrays
  const combineUnique = (field: keyof Suggestion) => {
    const allItems = suggestions.flatMap(s => {
      const value = s[field];
      return Array.isArray(value) ? value : [];
    });
    return [...new Set(allItems)].slice(0, 5); // Limit to 5 items
  };
  
  return {
    title: mergedTitle,
    description: `A merged concept combining the best elements of ${allTitles.join(', ')}.`,
    // Additional fields combined from source suggestions
    // ...
  };
}
```

## UI Components

The feature includes several UI components for managing AI-generated suggestions:

### SuggestionsScreen Component

Displays all generated suggestions and allows users to:
- Select a suggestion to continue with
- Regenerate individual suggestions using AI
- Edit suggestions manually
- Select multiple suggestions for merging

```typescript
// src/components/idea-playground/pathway1/SuggestionsScreen.tsx
const SuggestionsScreen: React.FC = () => {
  // State for suggestions, loading, error handling
  
  // Integration with AI service
  const generateSuggestions = async (ideaData: IdeaPlaygroundIdea) => {
    try {
      setIsGenerating(true);
      
      // Use the AI service to generate suggestions
      const generatedSuggestions = await ideaPathway1AIService.generateCompanySuggestions(
        ideaData,
        user?.id || 'anonymous',
        5 // Generate 5 suggestions
      );
      
      setSuggestions(generatedSuggestions);
      setSelectedSuggestionIndex(0);
    } catch (err) {
      // Error handling
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Regeneration handling
  const handleRegenerateSuggestion = async (index: number) => {
    // Use AI service to regenerate a specific suggestion
  };
  
  // Render logic for suggestions grid, loading states, etc.
}
```

### SuggestionMerger Component 

Allows users to merge multiple suggestions with AI assistance and manual editing capabilities:

```typescript
// src/components/idea-playground/pathway1/SuggestionMerger.tsx
const SuggestionMerger: React.FC<SuggestionMergerProps> = ({
  suggestions,
  onSave,
  onCancel
}) => {
  // State for merged suggestion, loading, errors
  
  // Generate AI-powered merged suggestion
  useEffect(() => {
    const generateAIMergedSuggestion = async () => {
      if (suggestions.length < 2) return;
      
      try {
        setIsGenerating(true);
        
        // Call the AI service to generate a merged suggestion
        const aiMergedSuggestion = await ideaPathway1AIService.mergeSuggestions(
          suggestions,
          user?.id || 'anonymous'
        );
        
        // Update the merged suggestion with the AI-generated one
        setMergedSuggestion(aiMergedSuggestion);
      } catch (err) {
        // Error handling
      } finally {
        setIsGenerating(false);
      }
    };
    
    generateAIMergedSuggestion();
  }, [suggestions, user?.id]);
  
  // UI for editing merged suggestion
}
```

## Loading and Error States

The implementation includes comprehensive loading and error states:

1. **Loading Indicators**:
   - Spinner animations during AI operations
   - Descriptive loading messages
   - Disabled UI elements during loading

2. **Error Handling**:
   - User-friendly error messages
   - Fallback mechanisms when AI operations fail
   - Retry capabilities
   - Detailed error logging for debugging

## Future Improvements

Potential enhancements to the AI integration:

1. **Specialized Model Fine-tuning**: Train models specifically for business idea generation
2. **User Feedback Loop**: Incorporate user ratings of suggestion quality to improve prompts
3. **Contextual Awareness**: Enhanced integration with user profile and company data
4. **Industry-Specific Variations**: Tailor suggestions based on industry trends and best practices
5. **Competitive Analysis**: More detailed integration with market research data
6. **Iterative Refinement**: Allow multi-turn refinement of ideas through conversation
7. **Visualization**: AI-generated visualizations of business models and concepts

## Technical Considerations

### API Usage Optimization

To minimize API costs while maintaining quality:

1. **Response Caching**: Cache responses for identical or similar prompts
2. **Batched Requests**: Generate all suggestions in a single API call
3. **Progressive Refinement**: Start with basic suggestions and refine only those the user shows interest in
4. **Efficient Token Usage**: Carefully designed prompts to minimize token consumption

### Model Selection

The implementation uses the most appropriate model based on the task:

1. **High-Quality Suggestions**: Models optimized for creative generation (GPT-4)
2. **Quick Iterations**: Faster, more economical models for refinements and edits
3. **Specialized Tasks**: Purpose-built models for specific aspects like market analysis

### Security and Privacy

1. **Data Minimization**: Only essential information sent to AI APIs
2. **Anonymization**: User identification information removed from prompts
3. **Content Filtering**: Outputs screened for inappropriate content
4. **Access Controls**: Proper authentication and authorization for AI operations

================
File: docs/idea-playground-pathway1/DATA_MODELING.md
================
# Idea Playground Pathway 1: Data Modeling

This document details the database schema design for the Idea Playground Pathway 1 feature, including tables, relationships, and data flows.

## Database Schema

The Idea Playground Pathway 1 feature extends the existing database schema with three new tables:

### Tables

#### 1. idea_playground_variations

Stores variations of original ideas generated by the AI.

| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| id | UUID | No | uuid_generate_v4() | Primary key |
| parent_idea_id | UUID | No | | Foreign key to idea_playground_ideas |
| title | VARCHAR(255) | No | | Variation title |
| description | TEXT | Yes | | Detailed description |
| problem_statement | TEXT | Yes | | Problem addressed |
| solution_concept | TEXT | Yes | | Proposed solution |
| target_audience | TEXT | Yes | | Target market |
| unique_value | TEXT | Yes | | Value proposition |
| business_model | TEXT | Yes | | Business model |
| marketing_strategy | TEXT | Yes | | Marketing approach |
| revenue_model | TEXT | Yes | | Revenue generation |
| go_to_market | TEXT | Yes | | Go-to-market strategy |
| market_size | TEXT | Yes | | Market size estimate |
| strengths | TEXT[] | Yes | '{}' | Array of strengths |
| weaknesses | TEXT[] | Yes | '{}' | Array of weaknesses |
| opportunities | TEXT[] | Yes | '{}' | Array of opportunities |
| threats | TEXT[] | Yes | '{}' | Array of threats |
| is_selected | BOOLEAN | No | false | Selection status |
| is_merged | BOOLEAN | No | false | Merged status |
| created_at | TIMESTAMP WITH TIME ZONE | No | NOW() | Creation timestamp |
| updated_at | TIMESTAMP WITH TIME ZONE | No | NOW() | Update timestamp |

**Indexes:**
- Primary Key: id
- Foreign Key: parent_idea_id → idea_playground_ideas.id (with CASCADE deletion)
- Index on parent_idea_id for performance

#### 2. idea_playground_merged_ideas

Stores merged ideas generated from multiple variations.

| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| id | UUID | No | uuid_generate_v4() | Primary key |
| canvas_id | UUID | No | | Foreign key to idea_playground_canvases |
| title | VARCHAR(255) | No | | Merged idea title |
| description | TEXT | Yes | | Detailed description |
| problem_statement | TEXT | Yes | | Problem addressed |
| solution_concept | TEXT | Yes | | Proposed solution |
| target_audience | TEXT | Yes | | Target market |
| unique_value | TEXT | Yes | | Value proposition |
| business_model | TEXT | Yes | | Business model |
| marketing_strategy | TEXT | Yes | | Marketing approach |
| revenue_model | TEXT | Yes | | Revenue generation |
| go_to_market | TEXT | Yes | | Go-to-market strategy |
| market_size | TEXT | Yes | | Market size estimate |
| strengths | TEXT[] | Yes | '{}' | Array of strengths |
| weaknesses | TEXT[] | Yes | '{}' | Array of weaknesses |
| opportunities | TEXT[] | Yes | '{}' | Array of opportunities |
| threats | TEXT[] | Yes | '{}' | Array of threats |
| is_selected | BOOLEAN | No | false | Selection status |
| created_at | TIMESTAMP WITH TIME ZONE | No | NOW() | Creation timestamp |
| updated_at | TIMESTAMP WITH TIME ZONE | No | NOW() | Update timestamp |

**Indexes:**
- Primary Key: id
- Foreign Key: canvas_id → idea_playground_canvases.id (with CASCADE deletion)
- Index on canvas_id for performance

#### 3. idea_playground_merge_sources

Maps the relationship between merged ideas and their source variations.

| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| merged_idea_id | UUID | No | | Foreign key to idea_playground_merged_ideas |
| variation_id | UUID | No | | Foreign key to idea_playground_variations |
| created_at | TIMESTAMP WITH TIME ZONE | No | NOW() | Creation timestamp |

**Indexes:**
- Primary Key: (merged_idea_id, variation_id)
- Foreign Key: merged_idea_id → idea_playground_merged_ideas.id (with CASCADE deletion)
- Foreign Key: variation_id → idea_playground_variations.id (with CASCADE deletion)
- Index on merged_idea_id for performance
- Index on variation_id for performance

### Entity Relationship Diagram

```mermaid
erDiagram
    idea_playground_canvases ||--o{ idea_playground_ideas : contains
    idea_playground_ideas ||--o{ idea_playground_variations : generates
    idea_playground_canvases ||--o{ idea_playground_merged_ideas : contains
    idea_playground_variations }o--o{ idea_playground_merged_ideas : combines
    idea_playground_variations ||--o{ idea_playground_merge_sources : "source for"
    idea_playground_merged_ideas ||--o{ idea_playground_merge_sources : "created from"
```

## Database Triggers

### Timestamp Management

To automatically update the `updated_at` field when a record is modified, we implement the following triggers:

#### For idea_playground_variations:

```sql
CREATE OR REPLACE FUNCTION update_idea_variation_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_idea_variation_timestamp
BEFORE UPDATE ON idea_playground_variations
FOR EACH ROW
EXECUTE FUNCTION update_idea_variation_timestamp();
```

#### For idea_playground_merged_ideas:

```sql
CREATE OR REPLACE FUNCTION update_merged_idea_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_merged_idea_timestamp
BEFORE UPDATE ON idea_playground_merged_ideas
FOR EACH ROW
EXECUTE FUNCTION update_merged_idea_timestamp();
```

## Data Transformation Flows

### Idea to Variations Flow

1. Original idea is stored in `idea_playground_ideas`
2. AI generates variations based on original idea
3. Variations are stored in `idea_playground_variations` with reference to parent idea

```mermaid
graph TD
    A[idea_playground_ideas] --> B[AI Processing]
    B --> C[idea_playground_variations]
    C --> D[User Selection]
    D --> E{Selected for merging?}
    E -->|Yes| F[Merge Process]
    E -->|No| G[Final Selection]
```

### Variations to Merged Ideas Flow

1. Selected variations from `idea_playground_variations` are sent to AI
2. AI generates merged ideas combining elements from selected variations
3. Merged ideas are stored in `idea_playground_merged_ideas`
4. Relationships between variations and merged ideas are stored in `idea_playground_merge_sources`

```mermaid
graph TD
    A[idea_playground_variations] -->|Selected| B[AI Processing]
    B --> C[idea_playground_merged_ideas]
    A --> D[idea_playground_merge_sources]
    C --> D
    D --> E[User Selection]
    E --> F[Final Selection]
```

## Query Patterns

### Common Queries

#### Get Variations for an Idea:

```sql
SELECT * FROM idea_playground_variations
WHERE parent_idea_id = :idea_id
ORDER BY created_at ASC;
```

#### Get Selected Variations:

```sql
SELECT * FROM idea_playground_variations
WHERE parent_idea_id = :idea_id AND is_selected = true
ORDER BY created_at ASC;
```

#### Get Merged Ideas for a Canvas:

```sql
SELECT * FROM idea_playground_merged_ideas
WHERE canvas_id = :canvas_id
ORDER BY created_at DESC;
```

#### Get Source Variations for a Merged Idea:

```sql
SELECT v.*
FROM idea_playground_variations v
JOIN idea_playground_merge_sources ms ON v.id = ms.variation_id
WHERE ms.merged_idea_id = :merged_idea_id;
```

## Performance Considerations

### Indexing Strategy

The schema includes indexes on all foreign key relationships and commonly queried fields to ensure optimal performance:

1. Primary key indexes on all tables
2. Foreign key indexes for quick relationship lookups
3. Composite indexes on join tables

### Query Optimization

For large datasets, consider:

1. Pagination for variation and merged idea lists
2. Lazy loading for full idea details
3. Caching frequently accessed variations

## Migration Strategy

The implementation will use a single migration script to create all new tables, triggers, and indexes. The migration script should be designed to be idempotent (safe to run multiple times).

### Migration Steps:

1. Create new tables if they don't exist
2. Create indexes on the new tables
3. Create triggers for timestamp management
4. Add any necessary constraints

## Data Security

Access to variations and merged ideas should follow the same security model as the original ideas:

1. Users can only access their own ideas and variations
2. Company members can access company-wide ideas and variations
3. All data is secured with row-level security policies

## Data Validation

The service layer should implement validation to ensure:

1. Variation titles are not empty
2. Parent idea references are valid
3. Merged idea references are valid
4. SWOT analysis arrays contain valid entries

================
File: docs/idea-playground-pathway1/IMPLEMENTATION_PLAN.md
================
# Idea Playground Pathway 1: Implementation Plan

This document outlines the phased approach for implementing the Idea Playground Pathway 1 feature, including tasks, dependencies, and estimated timelines.

## Implementation Phases

The implementation is divided into five phases to allow for incremental development, testing, and deployment.

### Phase 1: Database Schema and Backend Foundation (Week 1)

#### Tasks

1. **Database Schema Design and Migration**
   - Create migration file for new tables
   - Set up relationships between tables
   - Add indexes for performance optimization
   - Create triggers for timestamp management
   - Estimated time: 2 days

2. **Service Layer Extension**
   - Add new types and interfaces
   - Implement AI prompt templates
   - Create service methods for idea variation generation
   - Create service methods for idea merging
   - Implement JSON response parsing and error handling
   - Estimated time: 3 days

#### Deliverables
- Database migration script
- Extended type definitions
- IdeaPlaygroundService implementation with new methods

#### Dependencies
- Existing Idea Playground database schema
- Access to OpenAI API through generalLLMService

### Phase 2: UI Components - Variation Generation (Week 2)

#### Tasks

1. **Pathway Navigation Component**
   - Create step indicator component
   - Implement navigation controls
   - Set up state management for pathway flow
   - Estimated time: 1 day

2. **Idea Variation Panel and Card Components**
   - Create IdeaVariationPanel component
   - Create IdeaVariationList component
   - Create IdeaVariationCard component
   - Implement selection mechanism
   - Implement SWOT analysis display
   - Estimated time: 3 days

3. **Integration with IdeaPlaygroundWorkspace**
   - Extend IdeaPlaygroundWorkspace to include pathway step management
   - Integrate new components with existing workflow
   - Preserve existing functionality
   - Estimated time: 2 days

#### Deliverables
- PathwayNavigation component
- IdeaVariationPanel component
- IdeaVariationList component
- IdeaVariationCard component
- Updated IdeaPlaygroundWorkspace component

#### Dependencies
- Phase 1 completion
- Existing UI component library

### Phase 3: UI Components - Idea Merging (Week 3)

#### Tasks

1. **Merge Panel and Card Components**
   - Create IdeaMergePanel component
   - Create MergedIdeaList component
   - Create MergedIdeaCard component
   - Implement selection mechanism
   - Display relationship to source variations
   - Estimated time: 3 days

2. **Final Selection Interface**
   - Implement final idea selection UI
   - Create success feedback UI
   - Estimated time: 1 day

3. **Integration and State Management**
   - Connect all components
   - Implement selection state persistence
   - Handle transitions between steps
   - Estimated time: 2 days

#### Deliverables
- IdeaMergePanel component
- MergedIdeaList component
- MergedIdeaCard component
- Final selection interface
- Complete integrated UI flow

#### Dependencies
- Phase 2 completion

### Phase 4: Testing and Refinement (Week 4)

#### Tasks

1. **Unit Testing**
   - Write unit tests for service methods
   - Write unit tests for UI components
   - Achieve minimum 80% test coverage
   - Estimated time: 2 days

2. **Integration Testing**
   - Test the complete pathway flow
   - Test edge cases and error handling
   - Test with various idea types
   - Estimated time: 2 days

3. **Performance Optimization**
   - Implement lazy loading for idea details
   - Add caching for AI responses
   - Optimize database queries
   - Estimated time: 1 day

4. **UI Refinement**
   - Polish visual design
   - Improve animations and transitions
   - Enhance mobile responsiveness
   - Estimated time: 1 day

#### Deliverables
- Comprehensive test suite
- Performance optimizations
- Refined UI

#### Dependencies
- Phase 3 completion

### Phase 5: Documentation and Deployment (Week 5)

#### Tasks

1. **User Documentation**
   - Create user guide with screenshots
   - Create tutorial videos
   - Estimated time: 1 day

2. **Developer Documentation**
   - Update technical documentation
   - Document APIs and component interfaces
   - Estimated time: 1 day

3. **Deployment Preparation**
   - Create deployment scripts
   - Prepare rollback plan
   - Estimated time: 1 day

4. **Staged Deployment**
   - Deploy to staging environment
   - Conduct user acceptance testing
   - Deploy to production
   - Estimated time: 2 days

#### Deliverables
- Complete user and developer documentation
- Deployment scripts
- Production-ready feature

#### Dependencies
- Phase 4 completion

## Resource Requirements

### Development Team
- 1 Backend Developer
- 1 Frontend Developer
- 1 UI/UX Designer (part-time)
- 1 QA Engineer (part-time)

### Infrastructure
- Development, staging, and production environments
- Database capacity for new tables
- Increased OpenAI API quota for additional prompts

## Risk Assessment and Mitigation

| Risk | Impact | Probability | Mitigation |
|------|--------|------------|------------|
| OpenAI API response format changes | High | Medium | Implement robust parsing with fallbacks |
| Performance issues with large datasets | Medium | Medium | Implement pagination and lazy loading |
| User confusion with multi-step workflow | Medium | Low | Create intuitive UI and clear instructions |
| JSON parsing errors from AI responses | High | High | Implement fallback mechanisms and error handling |
| Integration issues with existing components | Medium | Medium | Thorough testing and clear component interfaces |

## Success Metrics

### Technical Metrics
- 80%+ test coverage
- < 2 second response time for idea generation
- < 2 second response time for idea merging
- Zero critical bugs in production

### User Metrics
- 70%+ of users complete the full pathway
- 50%+ of users try the merging functionality
- Positive user feedback (> 4/5 rating)

## Post-Implementation Evaluation

After deployment, conduct an evaluation to assess:
1. Feature adoption rate
2. User satisfaction
3. Performance in production
4. Areas for improvement

Schedule a retrospective two weeks after deployment to collect insights and plan future enhancements.

================
File: docs/idea-playground-pathway1/JSON_PARSING_FIX.md
================
# Idea Playground Pathway 1 JSON Parsing Fix

## Issue Description

The Idea Playground Pathway 1 feature was encountering errors during idea generation, specifically:

```
TypeError: Cannot read properties of undefined (reading 'title')
    at IdeaPathway1AIService.generateMockSuggestions (idea-pathway1-ai.service.ts:616:24)
    at IdeaPathway1AIService.generateCompanySuggestions (idea-pathway1-ai.service.ts:53:36)
```

## Root Cause

The issue was in the `generateMockSuggestions` method of `idea-pathway1-ai.service.ts`. When the AI service failed to generate real suggestions, it fell back to mock suggestions. However, the mock suggestion generator wasn't handling the case where the idea parameter might be null or undefined, causing it to crash when trying to access properties like `idea.title`.

## Fix Implementation

We updated the `generateMockSuggestions` method to safely handle null or undefined idea objects by adding proper null checks and default values:

1. Updated the method signature to explicitly accept null or undefined values:
   ```typescript
   private generateMockSuggestions(idea: IdeaPlaygroundIdea | null | undefined, count: number): Suggestion[]
   ```

2. Added default values for all idea properties:
   ```typescript
   const defaultTitle = 'Business Idea';
   const defaultDescription = 'A new business concept';
   const defaultProblemStatement = 'Problem statement not available';
   const defaultSolutionConcept = 'Solution concept not available';
   ```

3. Safely accessed idea properties with null coalescing operators:
   ```typescript
   const ideaTitle = idea?.title || defaultTitle;
   const ideaDescription = idea?.description || defaultDescription;
   const ideaProblemStatement = idea?.problem_statement || defaultProblemStatement;
   const ideaSolutionConcept = idea?.solution_concept || defaultSolutionConcept;
   ```

## Verification

We verified the fix using both a Node.js test script and a web-based test component:

1. `scripts/verify-idea-pathway1-fix.js` - CLI test that verifies the fix works with null, undefined, and valid idea objects.
2. `src/test.tsx` - React component that tests the fix directly in the browser.

You can test the fix by navigating to `/test` in the application, which provides a UI to test all scenarios.

## Additional Changes

We also ensured that our fix didn't introduce any regressions by:

1. Ensuring all required fields from the `IdeaPlaygroundIdea` interface are properly handled
2. Maintaining the same mock suggestion generation behavior for valid idea objects

## Conclusion

This fix ensures that the Idea Playground Pathway 1 feature will gracefully handle errors in the AI suggestion process by properly falling back to mock suggestions, even when the original idea object is null or undefined.

================
File: docs/idea-playground-pathway1/LINTING_FIXES.md
================
# Idea Playground Pathway 1: Linting and TypeScript Fixes

This document describes the linting and TypeScript type safety improvements made to the Idea Playground Pathway 1 feature to improve code quality and prevent potential errors.

## Overview

The Idea Playground Pathway 1 feature had several TypeScript and ESLint issues that were affecting code quality and potentially causing runtime errors. We've implemented a comprehensive linting fix strategy that addresses these issues.

## Key Improvements

1. **TypeScript Type Safety**
   - Added explicit return types to functions
   - Improved parameter typing
   - Replaced vague `any` types with more specific types like `unknown` or `Record<string, any>`
   - Added proper typing for React component props and state

2. **JSON Parsing Robustness**
   - Added multi-strategy JSON parsing approach
   - Implemented proper error handling for JSON parsing failures
   - Added detailed error reporting

3. **Error Handling**
   - Enhanced error reporting with specific error messages
   - Improved error display in the UI
   - Added defensive coding patterns to handle edge cases

4. **Code Structure**
   - Fixed missing imports 
   - Addressed ESLint warnings about syntax and style
   - Improved consistency across files

## Files Improved

The following files were improved by our linting fixes:

1. `src/lib/services/idea-pathway1-ai.service.ts` - Core AI service for pathway 1
2. `src/components/idea-playground/pathway1/SuggestionsScreen.tsx` - Main UI for suggestions
3. `src/components/idea-playground/pathway1/SuggestionCard.tsx` - Individual suggestion display
4. `src/components/idea-playground/pathway1/SuggestionEditor.tsx` - Editing component
5. `src/components/idea-playground/pathway1/SuggestionMerger.tsx` - Merging component

## Fix Categories

### Type Improvements

```typescript
// Before
function generateSuggestions(idea, userId, count) {
  // implementation
}

// After
function generateSuggestions(idea: IdeaPlaygroundIdea, userId: string, count: number = 5): Promise<Suggestion[]> {
  // implementation
}
```

### Error Handling Improvements

```typescript
// Before
catch (err) {
  console.error('Error fetching idea or generating suggestions:', err);
  setError('Failed to load idea or generate suggestions. Please try again.');
}

// After
catch (err) {
  console.error('Error fetching idea or generating suggestions:', err);
  const errorMessage = err instanceof Error ? err.message : 'Unknown error';
  setError(`Failed to load idea or generate suggestions: ${errorMessage}. Please refresh to try again.`);
}
```

### Import Fixes

Added necessary imports:

```typescript
import JSON5 from 'json5';
import { generalLLMService } from './general-llm.service';
```

### JSON Parsing Fixes

Implemented multi-strategy JSON parsing with progressive fallbacks:

```typescript
// Strategy 1: Direct parsing with JSON5
// Strategy 2: Regex extraction + parsing
// Strategy 3: Object-by-object extraction
// Strategy 4: Preprocessing + parsing
// Strategy 5: Individual field extraction
```

## Automated Fix Script

We've created a script to automatically fix linting issues across all relevant files:

```bash
node --experimental-modules scripts/fix-idea-pathway1-lint.js
```

This script:

1. Applies common TypeScript fixes to all files
2. Applies specialized fixes for specific files
3. Runs ESLint auto-fix where possible
4. Provides detailed logs of changes made

## Remaining Issues

While most issues have been addressed, there are a few remaining linting errors that require manual attention:

- Some TypeScript parser errors in complex type definitions
- Version compatibility warnings with the current TypeScript version

## Testing

After applying these fixes, you should test:

1. Creating a new idea
2. Generating suggestions
3. Editing suggestions
4. Merging suggestions
5. Continuing with a selected suggestion

## Future Improvement Recommendations

1. **Type Refinement**: Further refine types to be more specific where possible
2. **Unit Tests**: Add unit tests for JSON parsing strategies
3. **Error Boundary**: Implement React error boundaries around AI components
4. **Logging**: Add more detailed logging for debugging
5. **Documentation**: Add JSDoc comments to key functions

## Conclusion

These linting and type safety improvements make the Idea Playground Pathway 1 feature more robust, maintainable, and less prone to errors. The automated fix script provides an easy way to maintain these standards going forward.

================
File: docs/idea-playground-pathway1/README.md
================
# Idea Playground Pathway 1

## Overview

The Idea Playground Pathway 1 feature enhances the ideation process by enabling users to explore variations of their business ideas and generate hybrid concepts through AI-assisted idea refinement. This pathway offers a structured workflow to develop and refine ideas, making the creative process more productive and efficient.

> **Note:** A robust JSON parsing fix has been implemented (see [JSON_PARSING_FIX.md](./JSON_PARSING_FIX.md) for details) to resolve previous issues with AI-generated responses. This ensures reliable operation of all AI features.

## Key Features

- **AI-Powered Idea Variation Generation**: Generate 3-5 distinct variations of an original business idea with complete details including SWOT analysis, target audiences, business models, and more
- **Variation Management**: Select, edit, or regenerate individual variations as needed
- **AI-Powered Merging**: Combine elements from multiple selected variations to create new hybrid ideas
- **Interactive Editing**: Customize any aspect of generated or merged ideas
- **Comprehensive Business Details**: Each idea includes problem statements, solution concepts, revenue models, and other critical business aspects
- **Final Selection**: Choose a final idea to continue with in your business development journey

## Implementation Components

The implementation consists of several key components:

### AI Service Layer

- `idea-pathway1-ai.service.ts`: Dedicated AI service for Pathway 1 operations
  - `generateCompanySuggestions()`: Generate variations of an original idea
  - `mergeSuggestions()`: Combine multiple suggestions into a cohesive concept
  - `regenerateSuggestion()`: Improve a specific suggestion while maintaining its core concept

### UI Components

- **Suggestion Management**
  - `SuggestionCard`: Component for displaying an AI-generated business idea with full details
  - `SuggestionsScreen`: Grid layout of suggestion cards with selection and management capabilities
  - `SuggestionEditor`: Editor for modifying any aspect of a suggestion
  - `SuggestionMerger`: Interface for viewing and editing AI-merged suggestion combinations

- **Pathway Navigation**
  - `PathwayStepIndicator`: Displays the current step in the pathway and allows navigation
  - `PathwayNavigation`: Controls for moving through the pathway steps
  - `IdeaPathwayWorkflow`: Main component that orchestrates the entire pathway workflow

### Database Structure

- `idea_playground_suggestions`: Stores AI-generated suggestions of original ideas
- `idea_playground_merged_suggestions`: Stores hybrid ideas created by merging suggestions
- `idea_playground_merge_sources`: Junction table tracking relationships between merged ideas and source suggestions

## Workflow

1. **Initial Idea**: Start with an existing idea from the Idea Playground
2. **AI Generation**: System generates 3-5 distinct variations of the original idea
3. **Exploration**: User can view, edit, or regenerate any variation
4. **Selection**: User selects one variation to continue with, or multiple for merging
5. **AI Merging**: If multiple variations selected, AI creates a cohesive merged concept
6. **Refinement**: User can edit the merged concept if desired
7. **Final Selection**: User selects a variation or merged concept to continue with

## AI Integration Features

### Suggestion Generation

The AI system generates unique business idea variations with:
- Distinct approaches to solving the same problem
- Different target audiences and market segments
- Various business and revenue models
- Comprehensive SWOT analysis (strengths, weaknesses, opportunities, threats)
- Detailed business aspects (marketing strategy, go-to-market plan, etc.)

### Intelligent Merging

When merging multiple suggestions, the AI:
- Identifies complementary strengths from each source suggestion
- Resolves contradictions between different approaches
- Creates a cohesive business concept that's more than the sum of its parts
- Maintains the most compelling value propositions
- Addresses the most viable target audiences

### Regeneration

The regeneration feature allows users to:
- Keep the core concept but improve specific aspects
- Enhance marketability, innovation, or financial viability
- Address weaknesses identified in the original variation

## Technical Implementation

### AI Service Architecture

The AI integration is built around a dedicated service class that:
- Communicates with our existing `generalLLMService`
- Uses carefully crafted prompts to generate high-quality business concepts
- Includes robust response parsing, error handling, and fallback mechanisms
- Implements caching and optimization to minimize API costs

### User Experience Optimizations

- Loading indicators during AI operations
- Error handling with user-friendly messages
- Fallback mechanisms when AI operations fail
- Progressive loading of suggestions

## Installation

1. Run the database migration to create the necessary tables:
   ```bash
   node scripts/run-idea-playground-pathway1-migration.js
   ```

2. Ensure the `idea-pathway1-ai.service.ts` is properly imported in your services index.

3. Integrate the `IdeaPlaygroundWorkspaceWithPathway` component in your routing system.

## Integration with Existing System

The Pathway 1 feature is designed to integrate seamlessly with the existing Idea Playground. It extends the functionality without disrupting existing features. Users can:

1. Generate ideas in the traditional way
2. Select an idea to explore through Pathway 1
3. Return to the main Idea Playground with their refined idea

## Next Steps

After implementing Pathway 1, consider developing additional pathways such as:

- **Pathway 2**: Market validation and competitor analysis
- **Pathway 3**: Revenue model exploration
- **Pathway 4**: Go-to-market strategy development

These pathways could follow a similar step-based approach, extending the idea refinement capabilities of the platform.

================
File: docs/idea-playground-pathway1/REQUIREMENTS.md
================
# Idea Playground Pathway 1: Requirements Specification

## Overview

Idea Playground Pathway 1 enhances the existing Idea Playground functionality by adding a multi-step workflow after the initial idea generation. This document outlines the detailed requirements for this feature.

## Functional Requirements

### 1. Idea Variation Generation

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-VAR-001 | The system shall generate 3-5 distinct company ideas as variations of an original idea | High |
| REQ-VAR-002 | Each variation shall have its own title, description, problem statement, solution concept, target audience, and unique value proposition | High |
| REQ-VAR-003 | Each variation shall include a complete SWOT analysis with specific strengths, weaknesses, opportunities, and threats | High |
| REQ-VAR-004 | Variations shall be significantly different from each other in terms of approach, target market, or business model | High |
| REQ-VAR-005 | The system shall preserve the original idea while generating variations | Medium |
| REQ-VAR-006 | Users shall be able to regenerate variations if they are not satisfied with the initial set | Medium |

### 2. Idea Selection and Merging

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-SEL-001 | Users shall be able to select one or more idea variations | High |
| REQ-SEL-002 | The system shall support multi-selection of variations for merging | High |
| REQ-SEL-003 | The system shall generate 2 new merged ideas when multiple variations are selected | High |
| REQ-SEL-004 | Merged ideas shall combine strengths from the selected variations | High |
| REQ-SEL-005 | Users shall be able to view details of each merged idea | High |
| REQ-SEL-006 | Users shall be able to select a single merged idea to continue with | High |
| REQ-SEL-007 | The system shall track relationships between merged ideas and their source variations | Medium |

### 3. User Interface and Navigation

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-UI-001 | The system shall provide a step indicator showing the current step in the pathway | High |
| REQ-UI-002 | Users shall be able to navigate between steps in the pathway | High |
| REQ-UI-003 | Idea variations shall be displayed in a grid layout | High |
| REQ-UI-004 | Each idea card shall display a summary of the idea with option to view more details | High |
| REQ-UI-005 | The system shall visually indicate selected variations | High |
| REQ-UI-006 | The system shall display a loading indicator during AI-powered generation | Medium |
| REQ-UI-007 | The system shall preserve the existing first page of the Idea Playground | High |

### 4. Data Management

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-DAT-001 | The system shall store all generated variations in the database | High |
| REQ-DAT-002 | The system shall store merged ideas in the database | High |
| REQ-DAT-003 | The system shall track the relationship between variations and their parent idea | High |
| REQ-DAT-004 | The system shall track the relationship between merged ideas and their source variations | High |
| REQ-DAT-005 | The system shall support selection state persistence | Medium |

## Non-Functional Requirements

### 1. Performance

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-PERF-001 | Idea variations shall be generated within 15 seconds | High |
| REQ-PERF-002 | Merged ideas shall be generated within 15 seconds | High |
| REQ-PERF-003 | The UI shall remain responsive during AI operations | High |

### 2. Usability

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-USA-001 | The interface shall be intuitive and follow existing design patterns | High |
| REQ-USA-002 | The system shall provide clear feedback on actions and generation progress | High |
| REQ-USA-003 | The pathway shall guide users through each step with clear instructions | High |
| REQ-USA-004 | The selection mechanism shall be obvious and easy to use | High |

### 3. Security and Privacy

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-SEC-001 | User-generated content shall be private to the user or their company | High |
| REQ-SEC-002 | AI operations shall respect data privacy guidelines | High |

### 4. Scalability

| Requirement ID | Description | Priority |
|----------------|-------------|----------|
| REQ-SCA-001 | The system shall support multiple concurrent users generating variations | Medium |
| REQ-SCA-002 | The database design shall efficiently handle the storage of variations and merged ideas | Medium |

## User Stories

### Idea Variation

1. **As a** founder, **I want to** generate multiple variations of my initial business idea, **so that** I can explore different approaches to solving the same problem.

2. **As a** product manager, **I want to** see distinct variations with different target audiences and business models, **so that** I can identify the most promising market segments.

3. **As an** entrepreneur, **I want to** view a SWOT analysis for each idea variation, **so that** I can quickly assess their potential viability.

### Idea Selection and Merging

4. **As a** business strategist, **I want to** select multiple promising variations, **so that** I can merge their best elements into a stronger concept.

5. **As a** startup founder, **I want to** combine elements from different variations, **so that** I can create a more innovative and robust business model.

6. **As a** product developer, **I want to** select a final idea to proceed with, **so that** I can focus my efforts on developing it further.

### User Interface

7. **As a** user, **I want to** easily navigate between steps in the idea generation process, **so that** I can revisit previous steps if needed.

8. **As a** user, **I want to** clearly see which variations I've selected, **so that** I can make informed decisions about merging.

9. **As a** user, **I want to** have a visually appealing and intuitive interface, **so that** I can efficiently explore business ideas without confusion.

## Acceptance Criteria

### Idea Variation Generation

- The system generates 3-5 distinct variations of the original idea
- Each variation has unique characteristics in terms of approach, target market, or business model
- Each variation includes a complete SWOT analysis
- All details from the original idea are preserved

### Idea Selection and Merging

- Users can select multiple variations for merging
- The system generates 2 new merged ideas based on selected variations
- Merged ideas retain the best elements of the selected variations
- Users can select one final idea to continue with

### User Interface

- A step indicator shows the current position in the idea pathway
- Selected variations are visually highlighted
- Loading indicators appear during AI generation processes
- Navigation controls allow moving between steps

### Data Management

- All variations and merged ideas are stored in the database
- Relationships between ideas are tracked and maintained
- Selection state persists between user sessions

================
File: docs/idea-playground-pathway1/TECHNICAL_ARCHITECTURE.md
================
# Idea Playground Pathway 1: Technical Architecture

This document outlines the technical architecture for the Idea Playground Pathway 1 feature, including system components, data flow, database schema, and integration points.

## System Architecture Overview

The Idea Playground Pathway 1 feature extends the existing Idea Playground architecture with new components to support idea variation generation, selection, and merging.

```mermaid
graph TD
    User(User) --> UI(UI Components)
    UI --> IdeaPlaygroundWorkspace(IdeaPlaygroundWorkspace)
    
    subgraph "Pathway 1 Components"
        IdeaPlaygroundWorkspace --> PathwayNavigation(PathwayNavigation)
        IdeaPlaygroundWorkspace --> IdeaVariationPanel(IdeaVariationPanel)
        IdeaPlaygroundWorkspace --> IdeaMergePanel(IdeaMergePanel)
        IdeaVariationPanel --> IdeaVariationList(IdeaVariationList)
        IdeaVariationList --> IdeaVariationCard(IdeaVariationCard)
        IdeaMergePanel --> MergedIdeaList(MergedIdeaList)
        MergedIdeaList --> MergedIdeaCard(MergedIdeaCard)
    end
    
    IdeaPlaygroundWorkspace --> IdeaPlaygroundService(IdeaPlaygroundService)
    IdeaPlaygroundService --> Supabase[(Supabase Database)]
    IdeaPlaygroundService --> OpenAI(OpenAI API)
```

## Component Descriptions

### UI Components

1. **IdeaPlaygroundWorkspace**
   - Main container component that orchestrates the pathway flow
   - Manages pathway state and navigation between steps
   - Coordinates communication between child components

2. **PathwayNavigation**
   - Displays the current step in the pathway
   - Provides controls for moving between steps
   - Includes back, next, and finish buttons

3. **IdeaVariationPanel**
   - Panel for displaying and managing idea variations
   - Includes controls for generating variations
   - Manages variation selection state

4. **IdeaVariationList**
   - Grid layout for displaying multiple idea variation cards
   - Handles layout and responsiveness

5. **IdeaVariationCard**
   - Card component for an individual idea variation
   - Displays idea summary with expandable details
   - Includes selection mechanism
   - Shows SWOT analysis

6. **IdeaMergePanel**
   - Panel for managing the merging of selected variations
   - Includes controls for generating merged ideas
   - Manages merged idea selection state

7. **MergedIdeaList**
   - Grid layout for displaying merged idea cards
   - Handles layout and responsiveness

8. **MergedIdeaCard**
   - Card component for a merged idea
   - Displays merged idea summary with expandable details
   - Includes selection mechanism
   - Shows relationship to source variations

### Service Components

1. **IdeaPlaygroundService**
   - Contains business logic for Idea Playground
   - New methods for variation generation and merging
   - Handles communication with the database and AI service

2. **OpenAI Integration**
   - Used through General LLM Service
   - Generates idea variations based on original idea
   - Generates merged ideas from selected variations

## Data Flow

### Idea Variation Generation Flow

```mermaid
sequenceDiagram
    participant User
    participant UI as UI Components
    participant Service as IdeaPlaygroundService
    participant AI as OpenAI API
    participant DB as Supabase Database
    
    User->>UI: Select original idea and request variations
    UI->>Service: generateIdeaVariations(originalIdeaId)
    Service->>DB: Get original idea details
    DB-->>Service: Original idea data
    Service->>AI: Generate idea variations prompt
    AI-->>Service: Generated variations (JSON)
    Service->>Service: Parse and validate response
    Service->>DB: Store variations
    DB-->>Service: Confirmation
    Service-->>UI: Return saved variations
    UI-->>User: Display variation cards
```

### Idea Merging Flow

```mermaid
sequenceDiagram
    participant User
    participant UI as UI Components
    participant Service as IdeaPlaygroundService
    participant AI as OpenAI API
    participant DB as Supabase Database
    
    User->>UI: Select multiple variations and request merge
    UI->>Service: mergeSelectedVariations(variationIds)
    Service->>DB: Get selected variation details
    DB-->>Service: Variation data
    Service->>AI: Generate idea merge prompt
    AI-->>Service: Generated merged ideas (JSON)
    Service->>Service: Parse and validate response
    Service->>DB: Store merged ideas
    DB-->>Service: Confirmation
    Service->>DB: Update variation merge status
    DB-->>Service: Confirmation
    Service-->>UI: Return saved merged ideas
    UI-->>User: Display merged idea cards
```

## Database Schema

The feature adds three new tables to the existing database schema:

### 1. idea_playground_variations

Stores idea variations generated from original ideas.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID | Primary key |
| parent_idea_id | UUID | Foreign key to idea_playground_ideas |
| title | VARCHAR(255) | Variation title |
| description | TEXT | Detailed description |
| problem_statement | TEXT | Problem addressed |
| solution_concept | TEXT | Proposed solution |
| target_audience | TEXT | Target market |
| unique_value | TEXT | Value proposition |
| business_model | TEXT | Business model |
| marketing_strategy | TEXT | Marketing approach |
| revenue_model | TEXT | Revenue generation |
| go_to_market | TEXT | Go-to-market strategy |
| market_size | TEXT | Market size estimate |
| strengths | TEXT[] | Array of strengths |
| weaknesses | TEXT[] | Array of weaknesses |
| opportunities | TEXT[] | Array of opportunities |
| threats | TEXT[] | Array of threats |
| is_selected | BOOLEAN | Selection status |
| is_merged | BOOLEAN | Merged status |
| created_at | TIMESTAMP | Creation timestamp |
| updated_at | TIMESTAMP | Update timestamp |

### 2. idea_playground_merged_ideas

Stores merged ideas generated from multiple variations.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID | Primary key |
| canvas_id | UUID | Foreign key to idea_playground_canvases |
| title | VARCHAR(255) | Merged idea title |
| description | TEXT | Detailed description |
| problem_statement | TEXT | Problem addressed |
| solution_concept | TEXT | Proposed solution |
| target_audience | TEXT | Target market |
| unique_value | TEXT | Value proposition |
| business_model | TEXT | Business model |
| marketing_strategy | TEXT | Marketing approach |
| revenue_model | TEXT | Revenue generation |
| go_to_market | TEXT | Go-to-market strategy |
| market_size | TEXT | Market size estimate |
| strengths | TEXT[] | Array of strengths |
| weaknesses | TEXT[] | Array of weaknesses |
| opportunities | TEXT[] | Array of opportunities |
| threats | TEXT[] | Array of threats |
| is_selected | BOOLEAN | Selection status |
| created_at | TIMESTAMP | Creation timestamp |
| updated_at | TIMESTAMP | Update timestamp |

### 3. idea_playground_merge_sources

Maps the relationship between merged ideas and their source variations.

| Column | Type | Description |
|--------|------|-------------|
| merged_idea_id | UUID | Foreign key to idea_playground_merged_ideas |
| variation_id | UUID | Foreign key to idea_playground_variations |
| created_at | TIMESTAMP | Creation timestamp |

## Entity Relationship Diagram

```mermaid
erDiagram
    idea_playground_canvases ||--o{ idea_playground_ideas : contains
    idea_playground_ideas ||--o{ idea_playground_variations : generates
    idea_playground_canvases ||--o{ idea_playground_merged_ideas : contains
    idea_playground_variations }o--o{ idea_playground_merged_ideas : combines
    idea_playground_variations ||--o{ idea_playground_merge_sources : "source for"
    idea_playground_merged_ideas ||--o{ idea_playground_merge_sources : "created from"
```

## Integration Points

### 1. OpenAI API Integration

- Uses the existing `generalLLMService` to communicate with the OpenAI API
- Requires two new prompt templates:
  - Idea variation generation prompt
  - Idea merging prompt
- Handles JSON response parsing and error handling

### 2. Supabase Database Integration

- Extends the existing database schema with three new tables
- Uses Supabase RPC functions for complex operations
- Requires database triggers for timestamp management

## State Management

The pathway requires tracking several state variables in the `IdeaPlaygroundWorkspace` component:

1. `currentStep`: Tracks the current step in the pathway (enum: 'initial_idea', 'variations', 'selection', 'merge', 'final_selection')
2. `selectedIdea`: The original idea selected for variation
3. `variations`: Array of generated variations
4. `selectedVariations`: Array of selected variation IDs
5. `mergedIdeas`: Array of generated merged ideas
6. `selectedMergedIdea`: ID of the selected final idea
7. `isLoading`: Loading state during AI operations

## Performance Considerations

1. **Lazy Loading**: Implementation should use lazy loading for idea details to improve initial load time
2. **Response Caching**: AI-generated variations should be cached to avoid unnecessary regeneration
3. **Optimistic Updates**: UI should implement optimistic updates for selection operations
4. **Pagination**: If the number of variations or merged ideas becomes large, implement pagination

## Security Considerations

1. **Permissions**: Access to idea variations and merged ideas should respect the same permission model as the original ideas
2. **Data Sanitization**: All user inputs should be sanitized before being included in AI prompts
3. **Rate Limiting**: Implement rate limiting for AI operations to prevent abuse

## Future Extensions

1. **Variation Templates**: Allow users to select from different variation strategies (disruptive, incremental, etc.)
2. **Custom SWOT**: Enable users to edit the SWOT analysis for variations
3. **Multiple Merges**: Support multiple rounds of merging for more refined ideas
4. **Comparison View**: Add a side-by-side comparison view for variations and merged ideas

================
File: docs/idea-playground-pathway1/TESTING_GUIDE.md
================
# Idea Playground Pathway 1: Testing Guide

This document outlines the testing strategy and procedures for the Idea Playground Pathway 1 feature, including unit tests, integration tests, and end-to-end tests.

## Testing Strategy

The testing strategy for the Idea Playground Pathway 1 feature follows a comprehensive approach:

1. **Unit Testing**: Testing individual components and functions in isolation
2. **Integration Testing**: Testing the interaction between components
3. **End-to-End Testing**: Testing the complete user flow
4. **Automated Testing**: Scripts for automated testing of key functionality
5. **Manual Testing**: Test cases for human testers to validate UI and UX

## Test Environments

- **Development**: Local development environment for unit and initial integration tests
- **Staging**: Pre-production environment for full integration and end-to-end tests
- **Production**: Final validation after deployment

## Unit Tests

### Service Layer Tests

| Test ID | Description | Expected Outcome |
|---------|-------------|------------------|
| UT-SRV-001 | Test `generateIdeaVariations` with valid parameters | Return array of variations |
| UT-SRV-002 | Test `generateIdeaVariations` with invalid idea ID | Return empty array |
| UT-SRV-003 | Test `updateVariationSelection` with valid ID | Return true |
| UT-SRV-004 | Test `updateVariationSelection` with invalid ID | Return false |
| UT-SRV-005 | Test `mergeSelectedVariations` with valid parameters | Return array of merged ideas |
| UT-SRV-006 | Test `mergeSelectedVariations` with insufficient variations | Return empty array |
| UT-SRV-007 | Test `getMergedIdeasForCanvas` with valid canvas ID | Return array of merged ideas |
| UT-SRV-008 | Test `getMergedIdeasForCanvas` with invalid canvas ID | Return empty array |

### Component Tests

| Test ID | Description | Expected Outcome |
|---------|-------------|------------------|
| UT-CMP-001 | Test `IdeaVariationCard` renders correctly | Component renders without errors |
| UT-CMP-002 | Test `IdeaVariationCard` selection feature | Selection callback triggered |
| UT-CMP-003 | Test `IdeaVariationList` renders correctly | Component renders without errors |
| UT-CMP-004 | Test `IdeaVariationList` with empty array | Empty state message displayed |
| UT-CMP-005 | Test `IdeaMergePanel` renders correctly | Component renders without errors |
| UT-CMP-006 | Test `IdeaMergePanel` with selected variations | Merge button enabled |
| UT-CMP-007 | Test `PathwayNavigation` renders correctly | Component renders without errors |
| UT-CMP-008 | Test `PathwayNavigation` step control | Step change callback triggered |

## Integration Tests

| Test ID | Description | Expected Outcome |
|---------|-------------|------------------|
| IT-001 | Generate variations and verify database entries | Variations stored correctly |
| IT-002 | Select variations and verify selection state | Selection state persisted |
| IT-003 | Merge variations and verify merged ideas | Merged ideas stored correctly |
| IT-004 | Verify relationships between variations and merged ideas | Relationships maintained correctly |
| IT-005 | Test interaction between IdeaPlaygroundWorkspace and variation components | Components interact correctly |
| IT-006 | Test AI integration for variation generation | AI returns valid variation data |
| IT-007 | Test AI integration for idea merging | AI returns valid merged idea data |

## End-to-End Tests

| Test ID | Description | Steps | Expected Outcome |
|---------|-------------|-------|------------------|
| E2E-001 | Complete Pathway 1 flow | 1. Create initial idea<br>2. Generate variations<br>3. Select variations<br>4. Merge variations<br>5. Select final idea | Complete flow works without errors |
| E2E-002 | Single variation selection | 1. Create initial idea<br>2. Generate variations<br>3. Select one variation<br>4. Continue with selection | Variation selected and flow continues |
| E2E-003 | Multiple variation merge | 1. Create initial idea<br>2. Generate variations<br>3. Select multiple variations<br>4. Merge selected<br>5. Select merged idea | Merged idea created and selected |
| E2E-004 | Regenerate variations | 1. Create initial idea<br>2. Generate variations<br>3. Regenerate variations | New variations generated |
| E2E-005 | Navigation between steps | 1. Navigate through all steps<br>2. Go back to previous steps<br>3. Skip to final step | Navigation works correctly |

## Automated Test Script

An automated test script is provided at `scripts/test-idea-playground-pathway1.js` to verify the core functionality of the Idea Playground Pathway 1 feature. This script performs the following tests:

1. Verify database tables exist
2. Create a test canvas
3. Generate a test idea
4. Generate variations for the test idea
5. Select variations
6. Merge selected variations
7. Retrieve merged ideas
8. Verify relationships between variations and merged ideas
9. Clean up test data

To run the automated test script:

```bash
node scripts/test-idea-playground-pathway1.js
```

## Manual Testing Checklist

### Variation Generation

- [ ] UI shows loading state during generation
- [ ] Variations display all required information
- [ ] Each variation is visibly distinct
- [ ] SWOT analysis is properly formatted and visible
- [ ] UI is responsive on different screen sizes

### Variation Selection

- [ ] Clicking on a variation toggles selection state
- [ ] Selected variations are visually highlighted
- [ ] Selection persists when navigating between steps
- [ ] Multiple variations can be selected
- [ ] Continue button is enabled only when at least one variation is selected

### Idea Merging

- [ ] Merged ideas showcase elements from source variations
- [ ] Relationships to source variations are visible
- [ ] Merged ideas have complete SWOT analysis
- [ ] UI adjusts appropriately when different numbers of variations are selected
- [ ] Error states are handled gracefully

### Navigation

- [ ] Step indicator shows current position in workflow
- [ ] Navigation between steps works correctly
- [ ] Previous steps remain accessible
- [ ] UI provides clear direction on how to proceed

## Performance Testing

| Test ID | Description | Target Metric |
|---------|-------------|---------------|
| PERF-001 | Variation generation time | < 15 seconds |
| PERF-002 | Variation merging time | < 15 seconds |
| PERF-003 | UI responsiveness during AI operations | No UI freezing |
| PERF-004 | Loading time for variations list | < 2 seconds |
| PERF-005 | Database query performance | < 500ms |

## Accessibility Testing

| Test ID | Description | Success Criteria |
|---------|-------------|------------------|
| ACC-001 | Keyboard navigation | All interactive elements accessible |
| ACC-002 | Screen reader compatibility | All content properly announced |
| ACC-003 | Color contrast | WCAG AA compliance |
| ACC-004 | Text sizing | UI works with increased text size |
| ACC-005 | Focus management | Focus states visible and logical |

## Security Testing

| Test ID | Description | Success Criteria |
|---------|-------------|------------------|
| SEC-001 | Access control | Users can only access their own data |
| SEC-002 | Input validation | System rejects malicious inputs |
| SEC-003 | API request validation | All requests properly validated |
| SEC-004 | SQL injection protection | Database queries parameterized |
| SEC-005 | Rate limiting | API endpoints protected from abuse |

## Known Issues and Workarounds

| Issue ID | Description | Workaround |
|----------|-------------|------------|
| ISSUE-001 | AI occasionally generates similar variations | Regenerate variations or adjust the input parameters |
| ISSUE-002 | JSON parsing errors can occur with complex responses | Fallback text extraction mechanism in place |
| ISSUE-003 | Selection state may reset on page refresh | Re-select variations after page refresh |

## Test Data

A set of test data is available for testing purposes:

- Test user: Available in environment variables
- Test idea templates: Stored in the database
- Mock AI responses: Available for offline testing

## Conclusion

Following this testing guide will ensure comprehensive validation of the Idea Playground Pathway 1 feature. All aspects of the feature should be tested, including functionality, usability, performance, accessibility, and security.

================
File: docs/idea-playground-pathway1/USER_GUIDE.md
================
# Idea Playground Pathway 1: User Guide

This guide provides step-by-step instructions for using the Idea Playground Pathway 1 feature, which enables you to explore AI-generated variations of your business ideas and merge them into stronger concepts.

## Getting Started

### Prerequisites
- You must have an account and be logged in
- You must have created at least one idea in the Idea Playground

## Step-by-Step Guide

### Step 1: Generate an Initial Idea

1. Navigate to the Idea Playground from the main dashboard
2. Select an existing canvas or create a new one
3. Fill in the idea generation form with your parameters
4. Click "Generate Ideas" to create your initial idea
5. Review the generated idea

![Initial Idea Generation](../assets/idea-pathway1/step1.png)

### Step 2: Generate Idea Variations

1. Select the idea you want to explore further
2. Click the "Explore Variations" button
3. Wait while the AI generates 3-5 distinct variations of your idea
4. Review the variations presented on idea cards

![Idea Variations](../assets/idea-pathway1/step2.png)

#### Understanding Idea Variation Cards

Each AI-generated idea variation card contains:
- **Title**: A unique name for the variation
- **Description**: Brief overview of the concept
- **Problem Statement**: The specific problem this variation addresses
- **Solution Concept**: How this idea solves the problem
- **Target Audience**: Who would use/buy this
- **Unique Value Proposition**: What makes this variation special
- **Business Model**: How this idea would make money
- **SWOT Analysis**: Strengths, weaknesses, opportunities, and threats
- **Additional Details**: Revenue streams, cost structure, key metrics, etc.

Each card has three primary actions:
- **Select**: Choose this variation to continue with
- **Edit**: Manually modify the details of this variation
- **Regenerate**: Ask the AI to create a new version of this specific variation

Click on any card to expand and see all details about that variation.

### Step 3: Work with Variations

You have several options at this step:

#### Option A: Select a Single Variation

1. Click the selection checkbox on the variation you want to proceed with
2. Click "Continue with Selected" to move to the next stage with this idea

#### Option B: Regenerate a Variation

If you're not fully satisfied with a particular variation:

1. Click the "Regenerate" button on that variation's card
2. Wait while the AI creates an improved version of that specific concept
3. Review the regenerated variation with all its updated details

#### Option C: Edit a Variation Manually

If you want to make specific changes to a variation:

1. Click the "Edit" button on that variation's card
2. Make your desired changes to any fields
3. Click "Save Changes" to update the variation

#### Option D: Merge Multiple Variations

1. Click the selection checkboxes on multiple variations (2 or more)
2. Click "Merge Selected" to create a new hybrid concept
3. The AI will combine the best elements from each selected variation

![Selection Process](../assets/idea-pathway1/step3.png)

### Step 4: Merge Variations (if merging)

If you chose to merge multiple variations:

1. The system will show you an AI-generated merged concept that combines elements from your selected variations
2. You can edit any aspect of the merged concept if desired
3. You'll see which source variations contributed to different aspects of the merged idea
4. Click "Save Merged Concept" when you're satisfied

The merged concept will automatically include:
- A title indicating it's a merged concept
- A description that explains the hybrid approach
- Elements drawn from each source variation
- A comprehensive SWOT analysis
- Full business details derived from the source variations

![Merged Ideas](../assets/idea-pathway1/step4.png)

### Step 5: Continue with Your Selected Idea

After selecting your final idea (either a single variation or a merged concept):

1. The system will save your selection
2. You will proceed to the next stages of idea development
3. Your selected idea contains all the details from the variation/merged idea

## Advanced Features

### AI Regeneration

The AI regeneration feature allows you to:
- Get a fresh take on a specific variation you like
- Keep the core concept but improve various aspects
- Enhance marketability, innovation, or financial viability
- Address weaknesses identified in the original variation

### AI Merging

The AI merging feature allows you to:
- Combine the best elements from multiple variations
- Create a concept that's more than the sum of its parts
- Resolve contradictions between different approaches
- Target broader or more specific markets
- Create innovative hybrid business models

The AI specifically tries to:
- Maintain the most compelling value propositions
- Address the strongest target audiences
- Create a coherent, practical business concept
- Combine complementary strengths
- Mitigate weaknesses from individual variations

## Tips for Best Results

### Generating Diverse Variations

- Start with a well-defined initial idea
- Include specific details in your original idea for better variations
- The more detailed your original idea, the more diverse the variations will be

### Selecting Variations for Merging

- Choose variations with complementary strengths
- Look for variations that address different aspects of the problem
- Combine variations with different target audiences for broader market appeal
- Select variations with different business models to create innovative hybrids

### General Tips

- You can always go back to previous steps using the pathway navigation
- If you're not satisfied with any generated variations, you can regenerate them individually
- Save your work regularly
- Explore multiple pathways for the same initial idea to discover different possibilities

## Troubleshooting

### Common Issues and Solutions

| Issue | Solution |
|-------|----------|
| Variations are too similar | Add more specific details to your original idea |
| Merged ideas don't combine elements as expected | Select more diverse variations for merging |
| AI generation is taking too long | Check your internet connection or refresh the page |
| Selection isn't working | Clear your browser cache and try again |
| Need more variations | Consider creating multiple pathways from the same original idea |

If you encounter persistent issues, please contact support through the help menu.

================
File: docs/multi-persona-profile/CONTINUE_SETUP_FIX.md
================
# Continue Setup Functionality Fix

## Issue Summary

When users clicked "Continue Setup" in the dashboard after partially completing onboarding, they were taken back to the beginning of the onboarding flow rather than continuing from where they left off.

## Root Cause

The problem was in the `OnboardingProgressCard` component where:

1. The "Continue Setup" button used a generic `/onboarding` URL without specifying which persona's onboarding flow to continue
2. The personaId parameter was not being passed from the progress card to the onboarding page
3. Without the personaId, the OnboardingController would start a new onboarding flow

## Implementation Details

### 1. Modified OnboardingProgressCard.tsx

1. Added state to store the personaId:
   ```typescript
   const [onboardingPersonaId, setOnboardingPersonaId] = useState<string | null>(null);
   ```

2. Saved the personaId when fetching onboarding progress:
   ```typescript
   const { needsOnboarding, personaId } = await multiPersonaProfileService.checkOnboardingNeeded(user.id);
   
   if (needsOnboarding && personaId) {
     setActiveOnboarding(true);
     setOnboardingPersonaId(personaId); // Store the personaId for the Continue Setup button
     // ...
   }
   ```

3. Updated the "Continue Setup" button to use the stored personaId:
   ```typescript
   {progress < 100 && onboardingPersonaId && (
     <Link 
       to={`/onboarding/${onboardingPersonaId}`}
       className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700"
     >
       Continue Setup
     </Link>
   )}
   ```

### 2. Enhanced OnboardingPage.tsx

Added debug logging to make troubleshooting easier:

```typescript
useEffect(() => {
  if (personaId) {
    console.log('Resuming onboarding for persona:', personaId);
  } else {
    console.log('Starting new onboarding flow without personaId');
  }
}, [personaId]);
```

### 3. Verified App.tsx Routing

Confirmed that the App's router correctly handles the personaId parameter in both the protected and unprotected routes:

```tsx
// Unprotected routes
<Route path="onboarding/:personaId" element={<OnboardingPage />} />

// Protected routes
<Route path="onboarding/:personaId" element={<OnboardingPage />} />
```

## Testing

To test this fix:
1. Log in to the application
2. Start but do not complete the onboarding process
3. Navigate to the dashboard
4. Verify that the "Continue Setup" button appears
5. Click "Continue Setup"
6. Verify that the onboarding flow resumes from the last step, rather than starting over

## Results

With these changes:
- The "Continue Setup" button properly preserves and passes the personaId
- Clicking the button now takes users back to where they left off in the onboarding process
- The OnboardingController can resume the correct onboarding state and step

================
File: docs/multi-persona-profile/CURRENT_STATUS.md
================
# Multi-Persona Profile System: Current Status

## Overview

The Multi-Persona Profile System has been designed to allow users to create and manage multiple personas (founder, service provider, etc.) within a single user account. However, as of March 16, 2025, this feature has been **temporarily disabled** in the UI layer while we overhaul the onboarding process. This document explains the current status, reasons for disablement, and plans for re-enabling the feature.

## Current Status

### Backend Services Status

- **Database Schema**: Fully implemented and operational
- **API Endpoints**: Fully implemented and operational
- **Service Layer**: Fully implemented and operational

### Frontend Components Status

- **PersonaSelector Component**: Temporarily hidden in Layout component
- **CreatePersonaForm Component**: Still accessible but not promoted in UI
- **PersonaManagementPage**: Still accessible directly via URL but not linked in navigation

### User Flow Status

- **Persona Creation**: Temporarily deprioritized in favor of streamlined onboarding
- **Persona Switching**: UI component hidden but underlying functionality remains intact
- **Per-Persona Settings**: Data model supports this but UI is not currently exposing it

## Reasons for Temporary Disablement

1. **Onboarding Focus**: The current development priority is streamlining the initial onboarding process to improve user activation rates and time-to-value.

2. **Simplified User Experience**: By temporarily focusing on a single persona per user, we can create a more straightforward onboarding experience that doesn't overwhelm new users.

3. **Technical Debt Reduction**: Before fully implementing multi-persona UI components across the application, we're strengthening the underlying architecture.

4. **User Research Findings**: Recent user testing indicated confusion around the multi-persona concept during initial onboarding. We're reworking how this is presented to users.

## Implementation Details

### Code Changes

- The PersonaSelector component in Layout.tsx has been commented out with an explanatory comment:
  ```jsx
  {/* PersonaSelector hidden for all users per request */}
  <div className="hidden lg:ml-6 lg:flex lg:items-center">
    {/* Persona selector is temporarily hidden
    {!location.pathname.includes('/initial-onboarding') && (
      <PersonaSelector />
    )} */}
  </div>
  ```

- The database schema and backend services remain fully functional, with no changes needed when re-enabling the UI components.

- Routes to persona management pages remain in place but are not actively linked from the UI.

### Data Preservation

- All existing persona data is preserved in the database
- Users with existing personas will still have them when the feature is re-enabled
- Any new data created during this period will be properly associated with the user's default persona

## Plan for Re-enabling

The Multi-Persona Profile System will be re-enabled and enhanced in phases:

### Phase 1: Complete Initial Onboarding (Current Focus)
- Complete and stabilize the streamlined initial onboarding flow
- Capture essential user role information
- Drive users to relevant features without persona complexity

### Phase 2: Integrate Personas with Detailed Profile (Upcoming)
- Re-enable the PersonaSelector in a more strategic location
- Improve the persona creation experience
- Clearly communicate the purpose and benefits of multiple personas

### Phase 3: Full Multi-Persona Experience (Future)
- Extend persona-specific experiences throughout the application
- Implement persona-specific dashboards
- Add advanced persona management features

## Developer Guidelines

### Testing Multi-Persona Functionality

Despite the UI components being hidden, developers should continue to test the multi-persona backend functionality to ensure it remains operational:

1. **Direct URL Access**: Test persona management by directly accessing `/personas` and `/personas/new`
2. **API Testing**: Use API testing tools to verify the persona endpoints continue to function
3. **Database Validation**: Ensure persona data is being correctly stored and retrieved

### Code Changes During Disablement

When working with the codebase during this period:

1. Do not remove any multi-persona backend code
2. Maintain compatibility with the multi-persona data model
3. Design new features with eventual multi-persona support in mind
4. Comment any code that temporarily works around the absence of active persona selection

## User Impact

### Current Users

- Users who previously created multiple personas will still have their data preserved
- Only their primary/active persona will be used during this period
- They will not see the persona selector in the UI

### New Users

- Will experience a streamlined, single-persona onboarding flow
- Will be introduced to the multi-persona concept at a later stage
- Will receive a more focused initial experience

## Monitoring & Metrics

During this period, we're monitoring:

1. **Onboarding Completion Rates**: Tracking if the simplified flow improves completion
2. **Time-to-Value**: Measuring how quickly users reach key platform features
3. **User Feedback**: Collecting sentiment about the streamlined experience
4. **Technical Performance**: Ensuring the backend systems remain stable

## Conclusion

The multi-persona feature remains a core part of our platform strategy. Its temporary UI disablement is a strategic decision to optimize the initial user experience while we enhance the onboarding flow. The feature will be re-enabled with improvements once the initial onboarding stabilization is complete.

This approach allows us to:
- Focus development resources on the highest-impact areas
- Create a cleaner initial user experience
- Gather data on simplified onboarding performance
- Plan for a more intuitive re-introduction of the multi-persona concept

All changes have been designed to be easily reversible, with no data loss or significant refactoring required when re-enabling the feature.

================
File: docs/multi-persona-profile/IMPLEMENTATION_FIX.md
================
# Multi-Persona Profile System Implementation Fix

## Issue Overview

There was an issue with the Multi-Persona Profile system where the application was receiving errors when trying to create or access user profiles:

1. `GET https://aerakewgxmkexuyzsomh.supabase.co/rest/v1/user_core_profiles?select=*&id=eq.fe965d81-d7c4-4578-b495-210f32ff44ca 406 (Not Acceptable)`
2. `POST https://aerakewgxmkexuyzsomh.supabase.co/rest/v1/rpc/service_role_api.init_user_profile 404 (Not Found)`

The main error was `Could not find the function public.service_role_api.init_user_profile(user_id) in the schema cache.`

## Problem Identified

The application was trying to call a Supabase database function named `service_role_api.init_user_profile` which was not available in the database. 

This function was meant to be created by a migration file (`20250316192200_add_service_role_api_function.sql`), but there was an issue with the migration application, causing the function to be missing from the database schema.

## Solution Implemented

Instead of relying on the missing database function, we modified the `createDefaultProfile` method in the `MultiPersonaProfileService` class to handle profile creation directly from the application code.

The updated implementation:

1. Checks if the user already has a core profile
2. If not, creates a new core profile with default values
3. Creates user settings
4. Checks if the user has any personas
5. If not, creates a default "Primary Profile" persona
6. Sets up onboarding state for the new persona
7. Ensures the profile has an active persona set

This implementation avoids the need for the database function while maintaining all the required functionality.

## Benefits of This Fix

1. **No Database Migration Required**: The application now works without needing to fix or reapply the database migration.
2. **Code-Level Solution**: The fix is implemented at the application code level, making it more maintainable.
3. **Improved Error Handling**: The new implementation has more detailed error handling and logging.
4. **Retained Functionality**: All the functionality of the original approach is preserved.

## Next Steps

1. **Verify in Production**: Confirm the fix works in the production environment.
2. **Monitor Error Logs**: Watch for any related errors to ensure the fix is comprehensive.
3. **Consider Long-Term Migration**: For a more robust solution, you might still want to implement the database function later, as it could provide performance benefits for large-scale operations.

================
File: docs/multi-persona-profile/MIGRATION_FIX.md
================
# Multi-Persona Profile System Migration Fix

## Issue

There was an error in the profile initialization flow that caused the following errors:

```
GET https://aerakewgxmkexuyzsomh.supabase.co/rest/v1/user_core_profiles?select=*&id=fe965d81-d7c4-4578-b495-210f32ff44ca 406 (Not Acceptable)

POST https://aerakewgxmkexuyzsomh.supabase.co/rest/v1/rpc/service_role_api.init_user_profile 404 (Not Found)

Error initializing user profile: 
{code: 'PGRST202', details: 'Searched for the function public.service_role_api.init_user_profile, but no matches were found in the schema cache.', hint: 'Perhaps you meant to call the function public.migrate_existing_profiles', message: 'Could not find the function public.service_role_api.init_user_profile(user_id) in the schema cache'}
```

## Root Cause

The application code in `multi-persona-profile.service.ts` was trying to call a database function `service_role_api.init_user_profile`, but this function wasn't defined in the database. 

In the original migration file (`20250316131100_multi_persona_profile_system.sql`), a function called `migrate_existing_profiles` was defined but it was intended for bulk migration of existing profiles, not for initializing a single user profile as needed by the application.

## Solution

A new migration (`20250316192200_add_service_role_api_function.sql`) was created to:

1. Create the `service_role_api` schema
2. Implement the missing `init_user_profile` function which:
   - Creates a core profile for a user if one doesn't exist
   - Creates a default persona if none exists
   - Sets up proper onboarding state
   - Returns all the necessary data in the format expected by the application

## Implementation Details

The `init_user_profile` function:

- Is defined in the `service_role_api` schema as expected by the application
- Has the `SECURITY DEFINER` attribute so it runs with the permissions of the creator
- Handles all the database operations needed to properly set up a new user
- Returns data in the proper JSON format expected by the TypeScript code

## How to Apply This Fix

Run the migration script:

```bash
node scripts/run-service-role-api-migration.js
```

This will create the missing function and allow the profile initialization to work correctly.

## Verifying the Fix

After applying this migration:

1. The error messages should no longer appear when a user first logs in
2. New users should be able to complete the onboarding process
3. Persona creation should work correctly in the onboarding flow

## Note for Future Developers

When implementing database functions that are called from application code, ensure that:

1. The schema and function names match exactly what the application code expects
2. The function parameters and return type match the application's expectations
3. The correct permissions are granted to allow the application to call the function

================
File: docs/multi-persona-profile/ONBOARDING_COMPLETION_FIX.md
================
# Onboarding Completion Fix

## Issue

Users who completed the onboarding process before the multi-persona system was implemented are experiencing the following issues:

1. The setup progress percentage is not displaying correctly (shows as incomplete)
2. Clicking "Continue Setup" takes users back to the beginning of onboarding instead of resuming progress
3. The system incorrectly prompts users to complete onboarding again, even though they've already done so

This happens because the multi-persona profile system tracks onboarding progress in a new `onboarding_state` table, but existing users who completed onboarding before this system was implemented don't have records in this table.

## Solution

We've created a script to mark onboarding as complete for existing users. This script:

1. Identifies all users in the system
2. For each user, it:
   - Gets all of their personas
   - Checks if each persona has an `onboarding_state` record
   - If no record exists, creates one marked as complete
   - If a record exists but is not marked complete, updates it to be complete

## How to Use

Run the provided script:

```bash
./scripts/run-onboarding-completion.sh
```

The script will:
1. Process all users in the system
2. Create or update onboarding state records as needed
3. Print detailed logs of its actions
4. Show statistics at the end (users processed, personas updated, etc.)

## What This Fixes

After running this script:

1. The progress bar will correctly show 100% for users who have already completed onboarding
2. The "Continue Setup" button will no longer appear for these users
3. Users won't be prompted to repeat the onboarding process

## Technical Details

The script uses the following approach:

1. It marks the `current_step` as 'completion' (the final step)
2. It sets all previous steps as completed in the `completed_steps` array
3. It sets the `is_complete` flag to true
4. It adds completion metadata to the `form_data` object

This ensures that the `OnboardingProgressCard` component and other parts of the UI correctly recognize that onboarding has been completed.

## When to Run

Run this script once when upgrading to the multi-persona system to ensure a smooth transition for existing users. It's safe to run multiple times - it will only update records that need to be changed and skip those that are already marked complete.

================
File: docs/multi-persona-profile/ONBOARDING_FIX.md
================
# Multi-Persona Profile Onboarding Fix

## Summary of Issues

Two critical issues were affecting the multi-persona profile system's onboarding flow:

1. **Database Permission Error**: 403 Forbidden errors when trying to access the `user_settings` table
2. **Step Transition Issue**: The onboarding flow would reset back to `role_selection` after creating a new persona instead of advancing to `company_stage`

## Root Causes

### Database Permission Error
The `user_settings` table was missing proper Row Level Security (RLS) policies, preventing authenticated users from inserting new settings records during profile creation.

### Step Transition Issue
In the `OnboardingController.tsx` component, when creating a new persona, the code was saving the *current* step (`role_selection`) to the onboarding state instead of the *next* step (`company_stage`). This caused the flow to reset when reloading the onboarding state.

## Implemented Solutions

### Fix 1: Added RLS Policies for user_settings Table

Added the following SQL policies to the database:

```sql
-- For user_settings table
CREATE POLICY user_settings_select ON user_settings
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY user_settings_insert ON user_settings
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY user_settings_update ON user_settings
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
```

These policies allow users to select, insert, and update only their own settings records.

### Fix 2: Updated Onboarding Flow Step Transition

Modified the `goToNextStep` function in `OnboardingController.tsx` to:

1. Determine the next step *before* creating a new persona
2. Save the *next* step (e.g., `company_stage`) to the onboarding state instead of the current step
3. Reorder the logic to ensure transitions are properly handled

Key changes:
- Moved the next step determination logic to the beginning of the function
- Updated the `updateOnboardingState` call to use `nextStep` instead of `currentStep`
- Added more logging to track the step transitions

## Technical Implementation Details

The main fix involved restructuring the `goToNextStep` function to determine the next step earlier in the process. This ensures that when a new persona is created, the correct onboarding step is saved in the database.

Before, the flow was:
1. Create persona
2. Save current step (`role_selection`) to onboarding state
3. Determine next step
4. Update UI to next step

After, the flow is:
1. Determine next step
2. Create persona
3. Save next step (`company_stage`) to onboarding state
4. Update UI to next step

This ensures that when the onboarding state is loaded again, it already has the correct next step stored.

## Testing

The changes were tested by creating a new persona and verifying that:
1. The `user_settings` table could be accessed without permission errors
2. The onboarding flow properly advanced to the next step (`company_stage` for founder personas)
3. The flow doesn't reset back to `role_selection` when reloading the page

## Additional Recommendations

For long-term stability:

1. **Error Handling**: Add more robust error handling for database permission errors
2. **Step Persistence**: Consider using local storage as a fallback for step persistence
3. **Migration Script**: Create a migration script to ensure these fixes are applied to all environments
4. **Testing Suite**: Add automated tests for the onboarding flow to catch regressions

================
File: docs/multi-persona-profile/ONBOARDING_PROGRESS_FIX.md
================
# Onboarding Progress Tracking Fix

## Issue Summary

Users were experiencing issues with onboarding progress tracking:
1. The progress bar showed 0% even after completing several steps
2. The onboarding steps weren't being properly marked as completed
3. The `service_role_api.init_user_profile` function was failing (404 error)

## Root Causes

1. **Completed Steps Tracking**: Steps weren't being added to the `completed_steps` array in the onboarding state when users moved between steps.
2. **Progress Calculation**: The progress calculation in the `OnboardingProgressCard` component used a simplistic approach that didn't account for the actual flow.
3. **Direct Profile Creation**: The service role API function had issues, but we've implemented a direct fallback approach.

## Implementation Details

### 1. Fixed Step Completion Tracking in `OnboardingController.tsx`

Added code to track completed steps within the `goToNextStep` function:

```javascript
// Save the current step to completed_steps before moving to the next one
const newCompletedSteps = [...(onboardingState?.completed_steps || [])];
if (currentStep !== 'welcome' && !newCompletedSteps.includes(currentStep)) {
  newCompletedSteps.push(currentStep);
}

// Also update the onboarding state with the completed step
if (createdPersonaId && currentStep !== 'welcome') {
  await multiPersonaProfileService.updateOnboardingState(user.id, createdPersonaId, {
    current_step: nextStep,
    completed_steps: newCompletedSteps
  });
}
```

### 2. Improved Progress Calculation in `OnboardingProgressCard.tsx`

Enhanced the progress calculation algorithm to:
- Consider all steps in the onboarding flow
- Give partial credit for the current step in progress
- Show 100% when onboarding is complete

```javascript
// Calculate progress based on completed steps and include the current step
const allSteps = [
  'welcome',
  'role_selection',
  'company_stage',
  'industry_selection',
  'skill_level', 
  'goals_selection',
  'theme_preferences',
  'notification_preferences',
  'recommendations',
  'completion'
];
const totalSteps = allSteps.length - 1; // Excluding welcome step

// If current step is in completion or user has completed all steps
if (state.is_complete || state.current_step === 'completion') {
  setProgress(100);
} else {
  // Count completed steps, but also count the current step as partial progress
  const completedCount = state.completed_steps.length;
  const currentStepIndex = allSteps.indexOf(state.current_step);
  
  // Calculate percentage: completed steps + partial credit for current step
  const calculatedProgress = Math.min(100, Math.round(((completedCount + 0.5) / totalSteps) * 100));
  setProgress(calculatedProgress);
}
```

### 3. Handled Profile Completion in `App.tsx`

Updated the routing logic to handle returning users properly:

```javascript
// Check if this is a returning user (has a lastLogin timestamp in setup_progress)
const isReturningUser = (profile?.setup_progress as any)?.lastLogin !== undefined;

// Only redirect to onboarding if this isn't a returning user
if (!isReturningUser) {
  // Redirect to general onboarding which will handle personas
  return <Navigate to="/onboarding" replace />;
}
```

## Testing

A test script has been created in `scripts/test-profile-completion.js` to verify the onboarding progress calculation. This script:

1. Creates a test user and persona
2. Sets up an onboarding state with some completed steps
3. Calculates the expected progress percentage
4. Confirms the calculation matches our UI implementation

## Results

With these changes:
- Progress tracking now accurately reflects the user's position in the onboarding flow
- Each step is properly marked as completed when the user moves to the next step
- Returning users can access the dashboard without being redirected to onboarding
- User profiles are created directly, bypassing the service_role_api function

================
File: docs/multi-persona-profile/PERSONA_NAME_FIX.md
================
# Persona Name Uniqueness Fix

## Issue Overview

After implementing the previous fixes for onboarding step transition and database permissions, we encountered a new error:

```
duplicate key value violates unique constraint "user_personas_user_id_name_key"
```

This occurs when attempting to create a new persona for an existing user. The database has a unique constraint that prevents a user from having multiple personas with the same name.

## Root Cause

In the `OnboardingController.tsx` file, when creating a new persona, we were using a static name pattern:

```typescript
name: `My ${personaType} profile`,
```

For example, if a user attempted to create another "founder" type persona, it would try to use the name "My founder profile" again, which violates the unique constraint.

## Solution Implemented

We modified the persona creation process to include a timestamp in the persona name, ensuring uniqueness:

```typescript
// Add timestamp to persona name to ensure uniqueness
const timestamp = new Date().getTime();
const personaName = `My ${personaType} profile (${timestamp})`;
```

For example, instead of creating "My founder profile", it would now create something like "My founder profile (1711406387465)".

## Technical Implementation Details

The fix was applied to the `OnboardingController.tsx` file in the `goToNextStep` function. We:

1. Added code to generate a timestamp when creating a new persona
2. Constructed a unique persona name using this timestamp
3. Added logging to track when unique names are being created
4. Used this unique name when calling `createPersona`

This approach is simple and effective because:
- It guarantees uniqueness (timestamps are always increasing)
- It's human-readable (users can still see the persona type in the name)
- It requires minimal code changes (just a few lines in one file)
- It doesn't require database schema changes

## Testing

The fix was tested by attempting to create multiple personas of the same type for a user. The system now:
1. Successfully creates personas with unique names
2. Avoids the duplicate key constraint error
3. Properly progresses through the onboarding flow

## Related Issues

This fix complements the earlier fixes:
- The database permissions fix that ensured users could access `user_settings`
- The step transition fix that ensured the flow progressed from role selection to company stage

Together, these fixes create a robust onboarding flow that properly handles persona creation and step transitions.

================
File: docs/multi-persona-profile/README_FIX.md
================
# Multi-Persona Profile System Fix

## Overview

This repository contains a fix for the multi-persona profile system's user initialization flow. There was a missing database function that was causing profile initialization to fail, resulting in errors during onboarding.

## The Issue

The application code was trying to call a function (`service_role_api.init_user_profile`) that didn't exist in the database. This caused errors in:

1. Profile initialization for new users
2. Persona creation during onboarding
3. User onboarding process completion

## The Solution

We've created:

1. A migration SQL file that creates the missing function
2. A script to apply this migration
3. A test script to verify the fix works
4. Documentation explaining the issue and fix

## How to Apply the Fix

1. Make sure your Supabase environment variables are set in `.env`:
   ```
   SUPABASE_URL=your_supabase_url
   SUPABASE_SERVICE_KEY=your_service_role_key
   ```

2. Run the migration script:
   ```bash
   node scripts/run-service-role-api-migration.js
   ```

3. Verify the fix:
   ```bash
   node scripts/test-service-role-api-function.js
   ```

## Files Created

- `supabase/migrations/20250316192200_add_service_role_api_function.sql`: The SQL migration
- `scripts/run-service-role-api-migration.js`: Script to apply the migration 
- `scripts/test-service-role-api-function.js`: Test script to verify the fix
- `docs/multi-persona-profile/MIGRATION_FIX.md`: Detailed documentation of the fix
- `docs/multi-persona-profile/README_FIX.md`: This overview document

## What The Fix Does

The migration:

1. Creates the `service_role_api` schema if it doesn't exist
2. Creates an `init_user_profile` function in this schema that initializes a user profile by:
   - Creating a core profile if needed
   - Creating a default persona if needed
   - Setting up proper onboarding state
   - Returning all necessary data in the format expected by the application
3. Grants proper permissions to the service role

## Technical Notes

- No changes were needed to the TypeScript code, as the function now matches what the code expected
- The function uses `SECURITY DEFINER` to ensure it has sufficient permissions
- The function properly integrates with the multi-persona profile system's data structure

## Related Documentation

For more detailed information, see:
- [Migration Fix Documentation](./MIGRATION_FIX.md)
- [Multi-Persona Profile System Documentation](./TECHNICAL_DOCUMENTATION.md)

================
File: docs/onboarding-wizard/BLINKING_FIX.md
================
# Onboarding Wizard Blinking Fix

## Issue Description

The onboarding wizard was experiencing a bug where screens would blink and not progress properly through the steps. The main symptoms were:

1. Screens would flash/blink rapidly between steps
2. The wizard would sometimes get stuck and not progress to the next step
3. Clicking buttons multiple times was sometimes required to progress

## Root Causes

After investigation, we identified several root causes:

1. **Infinite Re-rendering Loops**: The `useEffect` hooks had dependency arrays that triggered too many re-renders
2. **Race Conditions**: Asynchronous operations were not properly coordinated, causing state updates at unexpected times
3. **State Instability**: Multiple state updates within a short time caused the UI to flash/blink
4. **Missing Error Handling**: Failed API calls weren't properly handled, causing the UI to get stuck in loading states
5. **Persona Creation Race Condition**: When creating a new persona, state updates triggered additional fetches before the persona creation was complete

## Solution Implemented

The following key fixes were implemented in `src/components/onboarding/OnboardingController.tsx`:

### 1. Added Refs to Track API Call Status

```typescript
// Reference to check if fetch has already been initiated
const fetchInitiatedRef = useRef<boolean>(false);
// Reference to track API request status
const isFetchingRef = useRef<boolean>(false);
```

These refs prevent multiple simultaneous API calls and avoid duplicate fetches on re-renders.

### 2. Memoized Fetch Function with useCallback

```typescript
const fetchOnboardingState = useCallback(async () => {
  // Skip if already fetching or already initiated
  if (!user || !personaId || isFetchingRef.current || fetchInitiatedRef.current) return;
  
  // Mark as fetching and initiated
  isFetchingRef.current = true;
  fetchInitiatedRef.current = true;
  
  // ... API call logic ...
}, [user, personaId, activePersona]);
```

The `useCallback` memoization prevents the function from being recreated on each render, and the additional flags track API call status.

### 3. Controlled Fetch Effect

```typescript
useEffect(() => {
  // Skip if there's no user or personaId isn't defined yet
  if (!user || !personaId) return;
  
  // Don't refetch if we've already started fetching
  if (isFetchingRef.current) return;
  
  fetchOnboardingState();
  
  // Cleanup
  return () => {
    // Reset fetching but keep initiated flag
    isFetchingRef.current = false;
  };
}, [user, personaId, fetchOnboardingState]);
```

This controls when the fetch is triggered and prevents unnecessary API calls.

### 4. Transition Protection

```typescript
// Use a ref to track whether we're currently transitioning
const isTransitioningRef = useRef<boolean>(false);

// Handle transitions between steps
const goToNextStep = useCallback(async (stepData: Record<string, any> = {}) => {
  if (!user || isTransitioningRef.current) return;
  
  // Prevent multiple clicks/transitions
  isTransitioningRef.current = true;
  
  // ... state update and API call logic ...
  
  // Allow transitions again after a short delay
  setTimeout(() => {
    isTransitioningRef.current = false;
    setLoading(false);
  }, 300);
}, [user, personaId, currentStep, userSelections]);
```

This prevents double-clicks or multiple rapid transitions, which could cause overlapping state updates.

### 5. Debounced Loading State

```typescript
// Add a debounced loading state to prevent flickering
const [stableLoading, setStableLoading] = useState(false);

useEffect(() => {
  if (loading) {
    // Set stable loading immediately when loading starts
    setStableLoading(true);
  } else {
    // Delay turning off loading indicator to prevent flickering
    const timer = setTimeout(() => {
      setStableLoading(false);
    }, 300);
    return () => clearTimeout(timer);
  }
}, [loading]);
```

This prevents the loading indicator from flickering rapidly by delaying its removal.

### 6. Better Error Handling

```typescript
try {
  // API call that might fail
} catch (error) {
  console.error('Error details:', error);
  // Continue anyway with sensible fallbacks
  setPersonalizationReady(true);
}
```

Improved error handling ensures that even if an API call fails, the UI doesn't get stuck.

### 7. Enhanced Logging

Added extensive console logging throughout the component to track state transitions and API calls, making it easier to debug future issues.

## Testing

A test script has been created (`scripts/test-onboarding-flow.js`) that sets up a test user and monitors the onboarding state. This script can be used to verify that the fix is working correctly.

## Future Recommendations

To prevent similar issues in the future:

1. Use refs to track the status of asynchronous operations
2. Memoize functions with useCallback when they're used in dependency arrays
3. Implement debounce mechanisms for state changes that affect the UI
4. Use strict dependency arrays in useEffect hooks
5. Add comprehensive error handling for all API calls
6. Implement detailed logging for state transitions

By following these practices, we can ensure that the onboarding flow remains stable and provides a smooth user experience.

================
File: docs/onboarding-wizard/INITIAL_ONBOARDING.md
================
# Initial Onboarding Process

## Overview

The Initial Onboarding process is the first phase of our two-phase onboarding strategy. It provides a streamlined, focused onboarding experience that quickly captures the most essential user information based on their role, getting users to relevant platform features faster.

This document outlines the technical implementation, user flow, and testing procedures for the Initial Onboarding system.

## User Flow

1. **Initial Entry**
   - New user signs up or logs in for the first time
   - User is automatically redirected to `/initial-onboarding`
   - Non-authenticated users are shown the login screen

2. **Role Selection**
   - User selects their primary role:
     - **Founder**: Building or leading a company
     - **Company Member**: Working at an existing company
     - **Service Provider**: Offering services to companies

3. **Role-Specific Information Collection**
   - **For Founders**: Company stage selection
     - Idea Stage → Directed to Idea Playground
     - Solid Idea → Directed to Company Formation
     - Existing Company → Profile setup for existing company
   - **For Company Members**: Company joining flow
     - Enter company code or information
     - Select role within company
   - **For Service Providers**: Service category selection
     - Multiple categories can be selected
     - Option to add specific services within categories

4. **Completion & Redirection**
   - User profile is updated with initial onboarding information
   - Marked as having completed initial onboarding
   - Redirected to appropriate feature based on role selection
   - Scheduled for detailed onboarding at next appropriate opportunity

## Component Architecture

### 1. InitialOnboardingPage (`src/pages/InitialOnboardingPage.tsx`)

The container page that:
- Checks authentication status
- Renders login for non-authenticated users
- Shows loading state while profile data loads
- Provides the onboarding context wrapper
- Handles completion callbacks and navigation

```typescript
// Key implementation details
const InitialOnboardingPage: React.FC = () => {
  const { user, profile } = useAuthStore();
  const navigate = useNavigate();
  
  // Show login for non-authenticated users
  if (!user) return <Login />;
  
  // Handle onboarding completion
  const handleOnboardingComplete = async () => {
    // Update profile to mark initial onboarding as complete
    // Redirect to appropriate next step
  };
  
  return <InitialOnboardingWizard user={user} onComplete={handleOnboardingComplete} />;
};
```

### 2. InitialOnboardingWizard (`src/components/onboarding/InitialOnboardingWizard.tsx`)

The core component that:
- Manages the onboarding step state
- Renders the appropriate step component
- Provides navigation between steps
- Saves user selections
- Tracks progress

```typescript
// Step definitions
const steps = [
  { id: 'role', label: 'Your Role', component: InitialRoleStep },
  { id: 'company_stage', label: 'Company Stage', component: FounderCompanyStageStep, 
    shouldShow: (data) => data.role === 'founder' },
  { id: 'join_company', label: 'Join Company', component: JoinCompanyStep,
    shouldShow: (data) => data.role === 'company_member' },
  { id: 'service_categories', label: 'Your Services', component: ServiceProviderCategoriesStep,
    shouldShow: (data) => data.role === 'service_provider' },
];
```

### 3. Role-Specific Step Components

#### 3.1 InitialRoleStep (`src/components/onboarding/steps/InitialRoleStep.tsx`)
- Presents role selection cards with icons and descriptions
- Captures user's primary role selection
- Simple, focused UI for quick decisions

#### 3.2 FounderCompanyStageStep (`src/components/onboarding/steps/FounderCompanyStageStep.tsx`)
- Only shown to users who selected "founder" role
- Presents company stage options with visual indicators
- Tailored descriptions and next steps for each stage

#### 3.3 JoinCompanyStep (`src/components/onboarding/steps/JoinCompanyStep.tsx`)
- Only shown to users who selected "company member" role
- Company lookup or code entry
- Role selection within company

#### 3.4 ServiceProviderCategoriesStep (`src/components/onboarding/steps/ServiceProviderCategoriesStep.tsx`)
- Only shown to users who selected "service provider" role
- Multi-select interface for service categories
- Option to specify particular services within categories

## Data Flow

1. **Data Storage**
   - All selections are stored in the user's profile under `setup_progress.form_data`
   - Company-specific information is stored in appropriate company tables
   - Service provider information is stored in service provider tables

2. **Integration with Profile Service**
   - `profile.service.ts` handles all profile data operations
   - Updates are batched to minimize database writes
   - Setup progress tracking is maintained in the profile

3. **State Management**
   - React state for UI interactions
   - Profile data for persistence
   - Redux store for global state coordination

## Testing the Initial Onboarding

### Reset Onboarding State Script

A dedicated script has been created to reset the onboarding state for testing:

```bash
node scripts/test-initial-onboarding.js
```

This script:
1. Connects to the database
2. Finds the mock user profile
3. Updates the profile to mark initial onboarding as incomplete
4. Clears any stored onboarding data

### Testing Process

1. **Reset the Onboarding State**
   ```bash
   node scripts/test-initial-onboarding.js
   ```

2. **Start the Development Server**
   ```bash
   npm run dev
   ```

3. **Navigate to the Initial Onboarding**
   - Go to http://localhost:5173/initial-onboarding
   - You should be automatically logged in with the mock user

4. **Test Different Paths**
   - Test the founder path with different company stages
   - Test the company member path
   - Test the service provider path
   - Verify correct redirections based on selections

5. **Verify Data Storage**
   - Check that selections are properly saved in the user profile
   - Verify that the initial onboarding completion flag is set

## Considerations

### 1. Performance
- Initial onboarding is designed to be lightweight and fast
- Minimal network requests during the process
- Pre-loaded options to avoid waiting for data

### 2. Accessibility
- All steps are keyboard navigable
- ARIA labels and roles for screen readers
- Sufficient color contrast for all UI elements

### 3. Mobile Responsiveness
- Fully responsive design works on all device sizes
- Touch-friendly UI elements
- Appropriate spacing for mobile interactions

### 4. Error Handling
- Graceful handling of network issues
- Automatic saving of progress
- Easy recovery from interruptions

## Future Enhancements

1. **Analytics Integration**
   - Track step completion rates
   - Measure time spent on each step
   - Analyze drop-off points

2. **A/B Testing Framework**
   - Test different role descriptions
   - Experiment with step order variations
   - Optimize for completion rate

3. **Personalization Enhancements**
   - More tailored content based on role
   - Dynamic recommendations
   - Integration with feature discovery

4. **Re-enabling Persona Selection**
   - Once the initial onboarding flow is stabilized
   - Re-introduce the currently hidden PersonaSelector component
   - Integrate multi-persona support with the onboarding flow

================
File: docs/onboarding-wizard/REQUIREMENTS.md
================
# Onboarding Wizard Requirements

## Feature Overview
The Onboarding Wizard is a guided, step-by-step process for new users to help customize their experience based on their role and preferences. It now follows a two-phase approach: an initial streamlined onboarding to quickly capture essential role information, followed by a more detailed profile setup.

## Epics & User Stories

### Epic 1: Initial Onboarding (NEW ✅)
Quickly identify the user's primary role and essential information to direct them to appropriate features immediately.

#### User Stories
- **US1.1**: As a new user, I want a streamlined initial onboarding process that quickly captures my role so I can start using the platform.
- **US1.2**: As a founder, I want to quickly specify my company stage during initial onboarding so I get directed to appropriate resources (idea playground, company formation, etc).
- **US1.3**: As a company member, I want a simple process to join my company during initial onboarding so I can collaborate immediately.
- **US1.4**: As a service provider, I want to quickly specify my service categories during initial onboarding so I can be discovered appropriately.
- **US1.5**: As a user, I want my initial onboarding state saved so I can continue with detailed profile setup later.

### Epic 2: User Role Identification
Determine the user's primary role in the system to customize their subsequent onboarding experience.

#### User Stories
- **US2.1**: As a new user, I want to select my role in the system (founder, company member, service provider) so I can see relevant features and content.
- **US2.2**: As a founder, I want the system to recognize my specific needs so I get directed to appropriate company-building resources.
- **US2.3**: As a company member, I want the system to understand I'm part of an existing company so I can quickly access collaboration tools.
- **US2.4**: As a service provider, I want to indicate what services I offer so I can be matched with companies needing my expertise.
- **US2.5**: As a user, I want to see future role options that aren't fully implemented yet so I understand the platform's direction.

### Epic 3: Company Stage Assessment
For founders, determine the current stage of their company to direct them to appropriate resources.

#### User Stories
- **US3.1**: As a founder, I want to specify my company's current stage (idea stage, solid idea, formed company) so I receive relevant guidance.
- **US3.2**: As an idea-stage founder, I want to be directed to ideation and validation tools so I can develop my concept.
- **US3.3**: As a founder with a solid idea, I want to be directed to company formation resources so I can formalize my business.
- **US3.4**: As a founder with an existing company, I want to quickly set up my company profile so I can manage my business on the platform.
- **US3.5**: As a founder, I want to see a visual indicator showing how different company stages align with platform features.

### Epic 4: User Profiling & Personalization
Collect additional information to further personalize the user experience.

#### User Stories
- **US4.1**: As a user, I want to select my industry so I can see industry-specific resources and recommendations.
- **US4.2**: As a user, I want to indicate my experience level so content can be tailored to my expertise.
- **US4.3**: As a user, I want to specify my goals for using the platform so the system can highlight relevant features.
- **US4.4**: As a user, I want to set my visual preferences (light/dark mode) so the interface matches my needs.
- **US4.5**: As a user, I want to configure my notification preferences so I only receive updates that matter to me.

### Epic 5: Guided Feature Introduction
Introduce users to key platform features based on their profile.

#### User Stories
- **US5.1**: As a user, I want to see personalized feature recommendations based on my role and preferences.
- **US5.2**: As a user, I want direct links to recommended features so I can immediately start using them.
- **US5.3**: As a founder, I want the idea playground highlighted if I'm in the ideation stage so I can begin exploring concepts.
- **US5.4**: As a founder ready to form a company, I want company formation tools highlighted so I can take immediate action.
- **US5.5**: As a company member, I want team collaboration tools highlighted so I can connect with colleagues.
- **US5.6**: As a service provider, I want the directory and marketplace highlighted so I can start offering services.

### Epic 6: Onboarding Flow Management
Provide a smooth, flexible onboarding experience with proper progress tracking.

#### User Stories
- **US6.1**: As a user, I want to see my onboarding progress so I know how much is left to complete.
- **US6.2**: As a user, I want the option to skip onboarding so I can access the platform immediately if needed.
- **US6.3**: As a user, I want to save my progress in onboarding so I can resume later if interrupted.
  - **Implementation**: Dedicated "Save & Exit" button allows users to pause at any point
  - **Implementation**: All progress is automatically preserved at the current step
  - **Implementation**: System seamlessly resumes from the last completed step when returning
- **US6.4**: As a user, I want a personalized welcome message upon completing onboarding so I feel acknowledged.
- **US6.5**: As a returning user, I should not see the onboarding wizard again unless I explicitly choose to restart it.
- **US6.6**: As a platform administrator, I want user onboarding data stored so I can analyze user segments and preferences.
- **US6.7**: As a user, I want to be able to sign out completely so I can test the system with different accounts.
  - **Implementation**: SignOutButton component added to the layout for consistent logout access
  - **Implementation**: Fully clears user state and redirects to login page
  - **Implementation**: Enables easy testing with multiple user accounts
- **US6.8**: As a user, I want my application settings (theme, notifications) to be separate from my core profile data.
  - **Implementation**: Created dedicated AppSettings service with its own storage
  - **Implementation**: Settings auto-initialized with defaults for new users
  - **Implementation**: Clean separation of concerns between profile and preferences
- **US6.9**: As a developer, I want easy testing of the onboarding flow.
  - **Implementation**: Created test script to reset onboarding state
  - **Implementation**: Script available at `scripts/test-initial-onboarding.js`

### Epic 7: Multi-Persona Management (TEMPORARILY DISABLED)
Support for managing multiple personas within a single user account.

#### User Stories
- **US7.1**: As a user, I want to create multiple personas (founder, service provider, etc.) so I can use the platform in different capacities.
  - **Status**: Functionality temporarily disabled during onboarding overhaul
  - **Implementation**: Database structure supports this feature but UI components are hidden
- **US7.2**: As a user, I want to switch between my different personas so I can access different features and views.
  - **Status**: PersonaSelector temporarily hidden in Layout component
- **US7.3**: As a user, I want persona-specific settings and preferences so each persona functions optimally for its purpose.
  - **Status**: Will be reintroduced after core onboarding stabilization

### Epic 8: Analytics & Optimization
Track onboarding metrics to improve the process.

#### User Stories
- **US8.1**: As a product manager, I want to track onboarding completion rates so I can identify drop-off points.
- **US8.2**: As a product manager, I want to see which features users navigate to after onboarding so I can measure effectiveness.
- **US8.3**: As a product manager, I want to A/B test different onboarding flows so I can optimize conversion rates.
- **US8.4**: As a product manager, I want to analyze user role distribution so I can prioritize feature development.
- **US8.5**: As a product manager, I want to track time spent on each onboarding step so I can identify friction points.
- **US8.6**: As a product manager, I want to track how often users utilize the save & exit functionality to improve the flow.
  - **Implementation**: Timestamps stored when users save and exit
  - **Implementation**: Analytics hooks for tracking exit points and resume behavior
- **US8.7**: As a product manager, I want to track user settings changes to understand preferences better.
  - **Implementation**: All settings updates are timestamp tracked
  - **Implementation**: Settings service includes analytics hooks
- **US8.8**: As a product manager, I want to track the effectiveness of initial vs. detailed onboarding to optimize for user retention.
  - **Implementation**: Added tracking for initial onboarding completion
  - **Implementation**: Separate metrics for each onboarding phase

## Future Epics (Placeholders)

### Epic 9: Team Onboarding
Streamline the onboarding process for entire teams joining the platform.

#### User Stories (Placeholder)
- **US9.1**: As a team leader, I want to invite team members to join our workspace during my onboarding process.
- **US9.2**: As a team leader, I want to set default role permissions for team members I invite.
- **US9.3**: As a team member, I want a streamlined onboarding process that recognizes I'm joining an existing team.

### Epic 10: Integration Onboarding
Guide users through connecting external tools and importing data.

#### User Stories (Placeholder)
- **US10.1**: As a user, I want to connect my existing tools (GitHub, Slack, etc.) during onboarding.
- **US10.2**: As a user, I want to import data from other platforms during onboarding.
- **US10.3**: As a user, I want recommendations for integrations based on my role and company stage.

### Epic 11: Internationalization
Support onboarding in multiple languages.

#### User Stories (Placeholder)
- **US11.1**: As a non-English speaking user, I want to complete onboarding in my preferred language.
- **US11.2**: As a user in a different region, I want localized examples relevant to my market.

## Implementation Status

### Completed Features
- ✅ Initial onboarding wizard with role selection
- ✅ Role-specific information collection (company stage, service categories)
- ✅ Integration with existing features (idea playground, company setup)
- ✅ Test script for resetting onboarding state
- ✅ Save & Exit functionality
- ✅ Sign Out capability for testing with multiple users

### In Progress Features
- 🔄 Detailed profile setup
- 🔄 Enhanced personalization based on user role
- 🔄 Feature recommendations

### Temporarily Disabled Features
- ⏸️ Multi-persona management
- ⏸️ PersonaSelector component in Layout

### Upcoming Features
- 📅 Analytics tracking for onboarding
- 📅 A/B testing framework
- 📅 Team onboarding

================
File: docs/onboarding-wizard/TECHNICAL_ARCHITECTURE.md
================
# Onboarding Wizard Technical Architecture

## Overview

The Onboarding Wizard is a critical component of the user experience, designed to collect user information, personalize the platform, and guide users to relevant features. This document outlines the technical architecture for implementing this feature.

## Architecture Diagram

```mermaid
graph TD
    A[User Signs Up] --> AA[Initial Onboarding]
    AA --> B[Onboarding Controller]
    
    %% Initial Onboarding Flow
    AA --> AB[InitialOnboardingWizard]
    AB --> AC{Initial Role Selection}
    AC -->|Founder| AD[Company Stage Selection]
    AC -->|Company Member| AE[Company Join Flow]
    AC -->|Service Provider| AF[Service Categories]
    AD --> AG[Save Initial Profile]
    AE --> AG
    AF --> AG
    AG --> AH[Initial Onboarding Complete]
    AH --> B
    
    %% Detailed Onboarding Flow
    B --> C{Detailed Role Selection}
    C -->|Founder| D[Company Stage]
    C -->|Company Member| F[Skill Level]
    C -->|Service Provider| E[Industry Selection]
    D --> E[Industry Selection]
    E --> G[Goals Selection]
    F --> G
    G --> H[Preferences Setup]
    H --> I[Feature Recommendations]
    I --> J[Dashboard Redirect]
    
    K[Onboarding Service] --- B
    K --- L[Profile Service]
    L --- M[(Database)]
    
    N[Analytics Service] --- B
    O[Feature Flag Service] --- B
    
    P[User State Store] --- B
    Q[Theme Provider] --- B
    
    %% Initial onboarding service connects
    AB --- K
    
    %% New save and exit functionality
    B -.-> R[Save & Exit]
    R -.-> J
    AB -.-> R
    
    %% New signout functionality
    S[SignOut Button] -.-> T[Auth Service]
    T -.-> U[Login Page]
    
    %% New app settings separation
    V[App Settings Service] -.-> W[(User Settings DB)]
    H -.-> V
    
    %% Temporarily disabled persona selector
    X[PersonaSelector] -.-> Y[Temporarily Hidden]
```

## System Components

### 1. Frontend Components

#### 1.1 Initial Onboarding Components

##### 1.1.1 InitialOnboardingWizard (`src/components/onboarding/InitialOnboardingWizard.tsx`)
- **Purpose**: Streamlined initial onboarding experience for new users
- **Key Functions**:
  - Capture basic user role (founder, company member, service provider)
  - Collect minimal necessary information based on role
  - Guide users to appropriate features based on selections
  - Store initial profile data
  - Set up for detailed onboarding stage

##### 1.1.2 InitialOnboardingPage (`src/pages/InitialOnboardingPage.tsx`) 
- **Purpose**: Container page for the initial onboarding wizard
- **Key Features**:
  - Handle non-authenticated users by showing login
  - Support authenticated users with the wizard
  - Manage onboarding completion state
  - Redirect logic after completion

##### 1.1.3 Role-Specific Initial Steps
- `InitialRoleStep.tsx`: Simple role selection (founder, company member, service provider)
- `FounderCompanyStageStep.tsx`: Captures company stage for founders
- `ServiceProviderCategoriesStep.tsx`: Collects service categories for providers
- `JoinCompanyStep.tsx`: Handles company membership for company members

#### 1.2 Detailed Onboarding Controller (`src/components/onboarding/OnboardingController.tsx`)
- **Purpose**: Core component that manages the onboarding flow, state transitions, and user progress
- **Key Functions**:
  - Fetch initial user profile data
  - Manage step transitions based on user input
  - Track analytics events
  - Save user selections between steps
  - Handle completion and redirection
  - **Save & Exit Functionality**: Allows users to pause onboarding and return later
    - Automatically preserves progress at current step
    - Dedicated button to exit to dashboard while saving state
    - Seamlessly resumes from last completed step on return

#### 1.2 Step Components
These modular components render individual onboarding steps:
- `RoleSelectionStep.tsx`: Capture user role (founder, company member, service provider)
- `CompanyStageStep.tsx`: For founders to specify company stage
- `IndustrySelectionStep.tsx`: Capture industry category
- `SkillLevelStep.tsx`: User expertise level
- `GoalsSelectionStep.tsx`: User objectives
- `ThemePreferencesStep.tsx`: Visual preferences
- `NotificationPreferencesStep.tsx`: Communication preferences
- `FeatureRecommendations.tsx`: Present personalized features
- Placeholder components for future expansion

#### 1.3 Progress Indicator (`src/components/onboarding/OnboardingProgress.tsx`)
- **Purpose**: Visual indicator showing onboarding completion progress
- **Key Features**:
  - Step completion visualization
  - Progress percentage calculation
  - Mobile-responsive design

#### 1.4 Onboarding Page (`src/pages/OnboardingPage.tsx`)
- **Purpose**: Container page for the onboarding wizard
- **Key Features**:
  - Layout structure
  - Error boundary
  - Loading states

#### 1.5 SignOutButton Component (`src/components/ui/SignOutButton.tsx`)
- **Purpose**: Provides consistent logout functionality throughout the application
- **Key Features**:
  - Integrates with auth service to handle session termination
  - Supports different visual styles (primary, secondary, text)
  - Clears user state from local storage
  - Redirects to login page after successful logout
  - Enables easy testing with new users

### 2. Backend Services

#### 2.1 Onboarding Service (`src/lib/services/onboarding.service.ts`)
- **Purpose**: Business logic for the onboarding process
- **Key Functions**:
  - Save user selections to profile
  - Determine next steps in the flow
  - Calculate recommended features
  - Track onboarding analytics
  - Generate personalized welcome messages
  - Manage onboarding completion state
  - **Progress Persistence**: 
    - Automatically saves each step's data
    - Stores current step for resuming later
    - Maintains history of completed steps
    - Timestamp tracking for analytics

#### 2.2 Profile Service (`src/lib/services/profile.service.ts`)
- **Purpose**: Handle profile data operations
- **Key Functions**:
  - Fetch existing profile data
  - Update profile with onboarding selections
  - Store onboarding completion status
  - **Auto-Profile Creation**:
    - Creates new profiles for first-time users
    - Initializes with default values
    - Sets up onboarding progress tracking

#### 2.3 App Settings Service (`src/lib/services/app-settings.service.ts`)
- **Purpose**: Manage user application settings separate from profile data
- **Key Functions**:
  - Store user preferences like theme and notification settings
  - Provide default settings for new users
  - Deep merge settings objects to preserve structure
  - Separate concerns from core profile data

#### 2.4 Analytics Service (Placeholder)
- **Purpose**: Track user behavior during onboarding
- **Key Functions**:
  - Record step views and completions
  - Measure time spent on each step
  - Track feature selection patterns
  - Support A/B testing

### 3. Data Models

#### 3.1 Onboarding State
```typescript
interface OnboardingState {
  current_step: string;
  completed_steps: string[];
  form_data: Record<string, any>;
  last_updated: string; // ISO timestamp for tracking when user last interacted
  initialOnboardingComplete?: boolean; // Flag to track initial onboarding completion
  onboarding_metrics?: {
    step_completion_times: Record<string, string>;
    total_time_spent?: number;
    completion_date?: string;
    initial_completion_date?: string; // When initial onboarding was completed
  };
}
```

#### 3.2 User Profile Extensions
```typescript
// Extended from existing ExtendedUserProfile
interface OnboardingUserProfile extends ExtendedUserProfile {
  setup_progress?: OnboardingState;
  user_role?: UserRole;
  company_stage?: CompanyStage;
  industry_category?: IndustryCategory;
  skill_level?: UserSkillLevel;
  goals?: string[];
}
```

#### 3.3 Application Settings (Separated from Profile)
```typescript
interface AppSettings {
  theme: 'light' | 'dark' | 'system';
  notifications: {
    email: boolean;
    push: boolean;
    inApp: boolean;
    digest: boolean;
  };
  display: {
    compactView: boolean;
    showTips: boolean;
    cardSize: 'small' | 'medium' | 'large';
  };
  features: {
    [key: string]: boolean;
  };
}
```

#### 3.4 Enumerations
```typescript
enum UserRole {
  FOUNDER = 'FOUNDER',
  COMPANY_MEMBER = 'COMPANY_MEMBER',
  SERVICE_PROVIDER = 'SERVICE_PROVIDER',
  INVESTOR = 'INVESTOR',
  ADVISOR = 'ADVISOR',
  COMMUNITY_MEMBER = 'COMMUNITY_MEMBER'
}

enum CompanyStage {
  IDEA_STAGE = 'IDEA_STAGE',
  SOLID_IDEA = 'SOLID_IDEA',
  FORMED_COMPANY = 'FORMED_COMPANY',
  EARLY_REVENUE = 'EARLY_REVENUE',
  SCALING = 'SCALING',
  ESTABLISHED = 'ESTABLISHED'
}

enum IndustryCategory {
  TECHNOLOGY = 'TECHNOLOGY',
  HEALTHCARE = 'HEALTHCARE',
  FINANCE = 'FINANCE',
  EDUCATION = 'EDUCATION',
  RETAIL = 'RETAIL',
  MANUFACTURING = 'MANUFACTURING', 
  ENTERTAINMENT = 'ENTERTAINMENT',
  OTHER = 'OTHER'
}

enum UserSkillLevel {
  BEGINNER = 'BEGINNER',
  INTERMEDIATE = 'INTERMEDIATE',
  EXPERT = 'EXPERT'
}
```

### 4. Database Schema Considerations

The onboarding data will be stored primarily in the `profiles` table, within the `setup_progress` JSON field, which is already part of the existing schema.

Application settings have been moved to a separate `user_settings` table with the following structure:
- `user_id`: Foreign key to users table
- `settings`: JSON object containing all user settings
- `created_at`: Timestamp of settings creation
- `updated_at`: Timestamp of last update

Example profile data:
```json
{
  "setup_progress": {
    "current_step": "recommendations",
    "completed_steps": ["role_selection", "company_stage", "industry_selection", "goals_selection"],
    "form_data": {
      "userRole": "FOUNDER",
      "companyStage": "IDEA_STAGE",
      "industryCategory": "TECHNOLOGY",
      "goals": ["networking", "fundraising"]
    },
    "last_updated": "2025-03-16T16:38:45Z",
    "onboarding_metrics": {
      "step_completion_times": {
        "role_selection": "2025-03-16T16:24:30Z",
        "company_stage": "2025-03-16T16:25:15Z",
        "industry_selection": "2025-03-16T16:26:00Z",
        "goals_selection": "2025-03-16T16:26:45Z"
      }
    }
  }
}
```

Example settings data:
```json
{
  "user_id": "user123",
  "settings": {
    "theme": "dark",
    "notifications": {
      "email": true,
      "push": false,
      "inApp": true,
      "digest": true
    },
    "display": {
      "compactView": true,
      "showTips": false,
      "cardSize": "small"
    },
    "features": {
      "betaFeatures": true,
      "experimentalTools": false
    }
  },
  "created_at": "2025-03-16T15:30:00Z",
  "updated_at": "2025-03-16T16:45:00Z"
}
```

## Implementation Strategy

### Phase 1: Initial Onboarding (Completed)
1. Implement simplified InitialOnboardingWizard for immediate role capture
2. Create role-specific initial steps (founder, company member, service provider)
3. Integrate with existing features (idea playground, company setup)
4. Store initial selections in user profile
5. Add testing script for onboarding state reset
6. Temporarily disable PersonaSelector during onboarding

### Phase 2: Core Detailed Onboarding Flow
1. Implement the complete detailed flow with role selection and personalization
2. Focus on founders, company members, and service providers
3. Store preferences in user profiles
4. Implement feature recommendations
5. **Add save & exit functionality** for seamless progress preservation
6. **Implement sign out capability** for testing with multiple users
7. **Separate app settings from profile data** for cleaner architecture

### Phase 2: Enhanced Personalization
1. Add industry and skill level selection
2. Implement goal-based recommendations
3. Create theme and notification preferences
4. Build personalized welcome messages

### Phase 3: Analytics & Optimization
1. Implement onboarding analytics tracking
2. Create admin dashboard for onboarding metrics
3. Set up A/B testing infrastructure
4. Implement optimization based on data

### Phase 4: Future Expansion
1. Add team onboarding capabilities
2. Implement integration onboarding for third-party tools
3. Support for international users and localization

## Integration Points

### 1. Authentication System
- **Integration**: Capture user information after successful authentication
- **Flow**: Auth system redirects to onboarding for new users
- **Sign Out Flow**: Clear auth state, user context, and redirect to login page

### 2. Feature Flag System
- **Integration**: Use feature flags to control which onboarding features are active
- **Flow**: Onboarding controller checks feature flags before displaying options

### 3. Analytics System
- **Integration**: Send onboarding events to analytics service
- **Flow**: Track step views, completions, and user selections
- **Exit Tracking**: Monitor save & exit usage patterns to identify potential UX improvements

### 4. User Preference System
- **Integration**: Save preferences like theme and notifications
- **Flow**: Apply preferences immediately after selection
- **Now uses dedicated App Settings Service**: Cleaner separation of concerns

## User Testing Workflow

1. **Test Initial Onboarding**:
   - Reset onboarding state using the test script:
     ```bash
     node scripts/test-initial-onboarding.js
     ```
   - Navigate to http://localhost:5173/initial-onboarding
   - Select different user roles to test each path
   - Verify correct redirections based on role

2. **Test with New Users**:
   - Use SignOutButton to log out current user
   - Sign in with a new test account
   - Complete onboarding steps
   - Verify personalization based on selections

2. **Test Save & Exit Functionality**:
   - Begin onboarding process
   - Complete several steps
   - Use "Save & Exit" button
   - Sign out and back in with same account
   - Verify onboarding resumes at the correct step
   - Verify previously entered data is preserved

3. **Test Different User Paths**:
   - Test founder flow with different company stages
   - Test company member flow
   - Test service provider flow
   - Verify appropriate recommendations for each

## Security Considerations

1. **Data Privacy**:
   - Store only necessary information
   - Clearly communicate data usage to users
   - Implement proper access controls for profile data

2. **Input Validation**:
   - Validate all form inputs on client and server
   - Prevent manipulation of onboarding steps
   - Sanitize user inputs before storage

3. **Session Management**:
   - Ensure onboarding state is tied to authenticated sessions
   - Prevent unauthorized access to onboarding data
   - **Secure Sign Out Process**:
     - Clear all sensitive data from memory
     - Invalidate session tokens
     - Remove cached credentials

## Performance Considerations

1. **Lazy Loading**:
   - Load step components dynamically to reduce initial bundle size
   - Prefetch next likely step based on user selection

2. **Caching Strategy**:
   - Cache user selections in local storage to prevent data loss
   - Batch save operations to reduce API calls
   - Implement efficient saving mechanism for "Save & Exit" functionality

3. **Responsiveness**:
   - Optimize for various screen sizes and devices
   - Ensure smooth transitions between steps

## Testing Strategy

1. **Unit Testing**:
   - Test individual step components in isolation
   - Test onboarding service functions
   - Test sign out functionality

2. **Integration Testing**:
   - Test complete onboarding flows
   - Test integration with profile service
   - Test save & exit with resume functionality

3. **User Acceptance Testing**:
   - Test with representatives from each user category
   - Gather feedback on clarity and usefulness
   - Test multiple sign out and sign in sequences

4. **A/B Testing**:
   - Test different onboarding flows for conversion optimization
   - Measure completion rates and time spent

================
File: docs/onboarding-wizard/TESTING_GUIDE.md
================
# Onboarding Testing Guide

## Overview

This guide provides detailed instructions for testing the onboarding flow, including the new two-phase approach with the Initial Onboarding Wizard. It covers how to use the testing scripts, different testing scenarios, and common issues that might arise during testing.

## Prerequisites

Before testing the onboarding flow, ensure you have:

1. A local development environment set up
2. Access to the Supabase database (local or development)
3. Node.js installed (v16+)
4. The project dependencies installed (`npm install`)

## Testing Tools

### 1. Onboarding Reset Script

The `test-initial-onboarding.js` script resets the onboarding state for testing:

```bash
node scripts/test-initial-onboarding.js
```

This script:
- Connects to your Supabase database
- Finds the mock user profile (`mock-user-id`)
- Resets the `initialOnboardingComplete` flag to `false`
- Clears any previously stored onboarding data

### 2. Mock Authentication

The project uses a mock authentication service (`mock-auth.service.ts`) that automatically logs in a test user. This allows you to test the onboarding flow without needing to create real user accounts.

### 3. Sign Out Button

A SignOutButton component is available in the UI to fully sign out and start fresh. Use this when you want to test with different user accounts.

## Testing Workflow

### Testing Initial Onboarding

1. **Reset Onboarding State**
   ```bash
   node scripts/test-initial-onboarding.js
   ```

2. **Start the Development Server**
   ```bash
   npm run dev
   ```

3. **Access Initial Onboarding**
   - Navigate to: http://localhost:5173/initial-onboarding
   - You should see the first step of the onboarding wizard (role selection)

4. **Test Different Role Paths**

   a. **Founder Path**:
   - Select "Founder" role
   - Choose a company stage:
     - "Idea stage" → Should direct to Idea Playground
     - "Solid idea" → Should direct to Company Formation
     - "Existing company" → Should direct to Company Profile Setup

   b. **Company Member Path**:
   - Select "Company Member" role
   - Test company joining flow:
     - Valid company code
     - Invalid company code
     - Company lookup

   c. **Service Provider Path**:
   - Select "Service Provider" role
   - Select multiple service categories
   - Add specific services (if implemented)
   - Verify redirection to service provider features

5. **Verify Data Storage**
   - After completing the flow, check the database to ensure selections are saved
   - Verify the `initialOnboardingComplete` flag is set to `true`
   - Confirm redirections are appropriate based on selections

### Testing Multi-User Scenarios

1. **Test with Different Users**
   - Use the SignOutButton to fully log out
   - Log in with different test accounts
   - Verify the onboarding flow works correctly for each user

2. **Test Returning Users**
   - Complete the onboarding flow with a user
   - Sign out and sign back in
   - Verify the user is not shown the onboarding again
   - Test resetting the onboarding state

### Testing Persona Selection (Currently Disabled)

The PersonaSelector component is temporarily hidden during the onboarding overhaul. When it is re-enabled in the future, test:

1. **Persona Selection During Onboarding**
   - Creation of personas during onboarding
   - Switching between personas
   - Persona-specific onboarding paths

2. **Onboarding State Per Persona**
   - Each persona should have its own onboarding state
   - Completing onboarding for one persona should not affect others

## Common Issues and Troubleshooting

### Database Connection Issues

**Issue**: The reset script fails to connect to the database.

**Solution**:
- Check the Supabase connection details
- Ensure the Supabase server is running
- Verify environment variables are set correctly

### Redirect Issues

**Issue**: Redirections after onboarding completion don't work as expected.

**Solution**:
- Check routing configuration in `App.tsx`
- Verify that the `navigate` function is being called with the correct path
- Ensure the completion handler in `InitialOnboardingPage.tsx` is working properly

### State Persistence Issues

**Issue**: Onboarding state isn't being saved or is lost between steps.

**Solution**:
- Check the profile service implementation
- Verify Supabase connections and write permissions
- Ensure the profile update operations are awaited properly

### Role-Specific Components Not Showing

**Issue**: Company stage selector doesn't appear for founders, etc.

**Solution**:
- Check conditional rendering logic in `InitialOnboardingWizard.tsx`
- Verify step configuration in the wizard
- Ensure role selection is being saved correctly

### Skipping Onboarding

**Issue**: Users need to skip onboarding for testing.

**Solution**:
- Manually set `initialOnboardingComplete: true` in the database
- Use the App routing system to navigate directly to desired features
- For development, consider adding a "Skip" button (not for production)

## Advanced Testing

### Performance Testing

1. **Measure Load Times**
   - Track initial page load time
   - Measure step transition times
   - Identify slow database operations

2. **Network Analysis**
   - Monitor network requests during onboarding
   - Identify unnecessary data fetching
   - Look for redundant API calls

### Accessibility Testing

1. **Screen Reader Testing**
   - Test with VoiceOver, NVDA, or other screen readers
   - Verify all elements are properly announced
   - Ensure form controls have appropriate labels

2. **Keyboard Navigation**
   - Test completing the entire flow using only keyboard
   - Verify focus order is logical
   - Ensure all interactive elements are reachable

### Mobile Testing

1. **Device Testing**
   - Test on various screen sizes
   - Verify touch targets are appropriately sized
   - Check for responsive layout issues

2. **Orientation Changes**
   - Test rotating devices between portrait and landscape
   - Verify state is preserved during orientation changes
   - Check for layout issues in different orientations

## Adding New Tests

When adding new features to the onboarding flow:

1. Update this testing guide
2. Add test cases to cover new functionality
3. Consider adding automated tests for critical paths
4. Document any new testing scripts or utilities

## Future Testing Enhancements

1. **Automated End-to-End Tests**
   - Implement Cypress or Playwright tests
   - Create test scenarios for all common paths
   - Set up CI/CD integration

2. **User Session Recording**
   - Implement session recording for real users
   - Analyze onboarding completion funnels
   - Identify common drop-off points

3. **A/B Test Infrastructure**
   - Set up feature flags for A/B testing
   - Create metrics for comparing onboarding variations
   - Build a dashboard for visualizing test results

================
File: docs/AI_IMPLEMENTATION.md
================
# Wheel99 AI Implementation

## Table of Contents
1. [Overview](#overview)
2. [Three-Tiered Contextual Model](#three-tiered-contextual-model)
   - [General-Purpose Tier](#general-purpose-tier)
   - [Domain-Specific Tier](#domain-specific-tier)
   - [User-Specific Tier](#user-specific-tier)
3. [AI Services Architecture](#ai-services-architecture)
   - [Service Interfaces](#service-interfaces)
   - [Implementation Classes](#implementation-classes)
   - [Factory Pattern](#factory-pattern)
   - [Mock Services](#mock-services)
4. [UI Integration Points](#ui-integration-points)
   - [AI-Assisted Components](#ai-assisted-components)
   - [Smart Suggestion Buttons](#smart-suggestion-buttons)
   - [Contextual AI Panels](#contextual-ai-panels)
   - [AI Context Providers](#ai-context-providers)
5. [Prompt Engineering](#prompt-engineering)
   - [Prompt Templates](#prompt-templates)
   - [Context Management](#context-management)
   - [Response Processing](#response-processing)
   - [Error Handling](#error-handling)

## Overview

Wheel99 incorporates advanced AI capabilities to assist users throughout the business ideation and development process. The AI implementation is designed to be context-aware, adaptable to user needs, and seamlessly integrated into the user interface. A three-tiered contextual model ensures that AI assistance is relevant to the specific domain, feature, and user context.

The AI capabilities are implemented through a modular architecture that includes:

1. **AI Service Layer**: A set of TypeScript services that handle communication with language models
2. **Context Providers**: React context components that provide AI capabilities to UI components
3. **AI-Assisted UI Components**: Form inputs, text areas, and other components with built-in AI assistance
4. **Smart Suggestion Controls**: UI elements that provide contextual suggestions
5. **Prompt Engineering**: Carefully crafted prompts to guide the language models' responses

## Three-Tiered Contextual Model

Wheel99 employs a three-tiered contextual model that provides progressively more specific and personalized AI assistance:

```
┌───────────────────────────────────────────────────────────┐
│                                                           │
│                 User-Specific Context Tier                │
│                                                           │
│   • User's company information                            │
│   • User's previous ideas and interactions                │
│   • User's industry and focus areas                       │
│   • User preferences and patterns                         │
│                                                           │
└───────────────────────────────────────────────────────────┘
                           ▲
                           │
┌───────────────────────────────────────────────────────────┐
│                                                           │
│                Domain-Specific Context Tier               │
│                                                           │
│   • Business ideation and development domain knowledge    │
│   • Industry-specific knowledge and trends                │
│   • Business model patterns and best practices            │
│   • Market analysis frameworks                            │
│                                                           │
└───────────────────────────────────────────────────────────┘
                           ▲
                           │
┌───────────────────────────────────────────────────────────┐
│                                                           │
│                 General-Purpose Context Tier              │
│                                                           │
│   • General language understanding                        │
│   • Broad knowledge base                                  │
│   • Common sense reasoning                                │
│   • Basic creative capabilities                           │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

### General-Purpose Tier

The General-Purpose Tier forms the foundation of Wheel99's AI capabilities, providing broad knowledge and language understanding. This tier is implemented through GPT models with default settings.

- **Implementation**: Base models (GPT-3.5-Turbo or GPT-4) with minimal prompting
- **Use Cases**:
  - General text generation and completion
  - Initial brainstorming without specific constraints
  - Answering general knowledge questions
  - Basic formatting and structuring of content

- **Example Prompts**:
  ```
  Generate 5 potential business ideas without any specific constraints.
  ```

### Domain-Specific Tier

The Domain-Specific Tier adds business ideation and entrepreneurship knowledge to guide the AI responses toward practical, well-formed business concepts. This tier is implemented through specialized prompts that encode domain knowledge and best practices.

- **Implementation**: Base models with domain-specific prompts and system messages
- **Use Cases**:
  - Structured business idea generation
  - Industry-specific recommendations
  - Business model pattern application
  - Market analysis and competitive positioning

- **Example Prompts**:
  ```
  You are an expert business strategist with experience in technology startups. Generate 3 business ideas in the healthcare technology sector, focusing on preventative care. For each idea, include:
  1. Problem statement
  2. Solution concept
  3. Target audience
  4. Unique value proposition
  5. Preliminary business model
  ```

### User-Specific Tier

The User-Specific Tier incorporates the user's company information, previous ideas, and preferences to deliver highly personalized AI assistance. This tier is implemented through context-aware prompts that include user-specific data.

- **Implementation**: Base models with user context injection and history awareness
- **Use Cases**:
  - Company-contextual idea generation
  - Personalized recommendations based on user history
  - Adapting to user's industry and focus areas
  - Aligning suggestions with user's patterns and preferences

- **Example Prompts**:
  ```
  As an expert business strategist, generate 3 business ideas relevant to a company with the following profile:
  
  Company: Acme Healthcare Solutions
  Industry: Medical equipment manufacturing
  Size: 120 employees
  Focus areas: Patient monitoring, diagnostic tools, telemedicine
  
  The ideas should leverage the company's existing capabilities while exploring adjacent markets. The user has previously shown interest in AI-powered diagnostics and remote patient monitoring.
  ```

## AI Services Architecture

Wheel99's AI capabilities are implemented through a modular service architecture designed for flexibility, testability, and extensibility.

### Service Interfaces

The core of the AI service architecture is a set of TypeScript interfaces that define the contract for AI services:

#### AIServiceInterface

```typescript
export interface AIServiceInterface {
  // Core idea generation
  generateIdeas(params: IdeaGenerationParams): Promise<IdeaPlaygroundIdea[]>;
  
  // Refinement capabilities
  refineIdea(params: IdeaRefinementParams): Promise<IdeaRefinementResult>;
  
  // Component-level operations
  generateComponent(
    ideaId: string, 
    componentType: ComponentType, 
    context?: any
  ): Promise<IdeaPlaygroundComponent>;
  
  enhanceComponent(
    component: IdeaPlaygroundComponent, 
    direction: string
  ): Promise<IdeaPlaygroundComponent>;
  
  // Suggestion capabilities
  getSuggestions(
    context: any, 
    count?: number
  ): Promise<Suggestion[]>;
  
  // AI-assisted text capabilities
  completeText(
    text: string, 
    fieldType: string, 
    context?: any
  ): Promise<string>;
}
```

#### General LLM Service Interface

```typescript
export interface GeneralLLMServiceInterface {
  // General text generation
  generateText(
    prompt: string, 
    options?: GenerateOptions
  ): Promise<string>;
  
  // Structured output generation
  generateWithStructure<T>(
    prompt: string, 
    schema: any, 
    options?: GenerateOptions
  ): Promise<T>;
  
  // Multiple generations
  generateVariations(
    prompt: string, 
    count: number, 
    options?: GenerateOptions
  ): Promise<string[]>;
  
  // Stream responses
  streamText(
    prompt: string, 
    callback: (text: string, done: boolean) => void, 
    options?: GenerateOptions
  ): Promise<void>;
}
```

### Implementation Classes

The interfaces are implemented by concrete classes that handle the actual AI functionality:

#### Multi-Tiered AI Service

```typescript
export class MultiTieredAIService implements AIServiceInterface {
  private readonly generalLLMService: GeneralLLMServiceInterface;
  private readonly userContext: UserContext | null;
  private readonly tier: UserTier;
  
  constructor(
    generalLLMService: GeneralLLMServiceInterface,
    userContext: UserContext | null = null,
    tier: UserTier = 'standard'
  ) {
    this.generalLLMService = generalLLMService;
    this.userContext = userContext;
    this.tier = tier;
  }
  
  // Implementation of core methods
  async generateIdeas(params: IdeaGenerationParams): Promise<IdeaPlaygroundIdea[]> {
    // Build prompt based on tier and params
    const prompt = this.buildIdeaGenerationPrompt(params);
    
    // Generate structured output
    const ideas = await this.generalLLMService.generateWithStructure<IdeaPlaygroundIdea[]>(
      prompt,
      ideaSchema,
      this.getModelOptionsForTier()
    );
    
    return ideas;
  }
  
  // Private helper methods
  private buildIdeaGenerationPrompt(params: IdeaGenerationParams): string {
    let prompt = "Generate business ideas";
    
    // Add domain context
    prompt += this.addDomainContext();
    
    // Add user context if available and appropriate for tier
    if (this.userContext && (this.tier === 'premium' || this.tier === 'enterprise')) {
      prompt += this.addUserContext(params.useCompanyContext);
    }
    
    // Add parameter-specific constraints
    prompt += this.addParameterConstraints(params);
    
    return prompt;
  }
  
  private getModelOptionsForTier(): GenerateOptions {
    switch (this.tier) {
      case 'enterprise':
        return { model: 'gpt-4', temperature: 0.7, maxTokens: 2000 };
      case 'premium':
        return { model: 'gpt-4', temperature: 0.7, maxTokens: 1500 };
      case 'standard':
      default:
        return { model: 'gpt-3.5-turbo', temperature: 0.7, maxTokens: 1000 };
    }
  }
  
  // Additional implementations...
}
```

#### General LLM Service

```typescript
export class GeneralLLMService implements GeneralLLMServiceInterface {
  private readonly openAIClient: OpenAIClient;
  private readonly logger: Logger;
  
  constructor(
    openAIClient: OpenAIClient,
    logger: Logger = console
  ) {
    this.openAIClient = openAIClient;
    this.logger = logger;
  }
  
  async generateText(
    prompt: string, 
    options: GenerateOptions = {}
  ): Promise<string> {
    try {
      const completion = await this.openAIClient.createCompletion({
        model: options.model || 'gpt-3.5-turbo',
        prompt,
        max_tokens: options.maxTokens || 500,
        temperature: options.temperature || 0.7,
        // Additional OpenAI parameters
      });
      
      return completion.choices[0]?.text || '';
    } catch (error) {
      this.logger.error('Error generating text', error);
      throw new AIServiceError('Failed to generate text', error as Error);
    }
  }
  
  // Additional implementations...
}
```

### Factory Pattern

A factory pattern is used to create the appropriate AI service based on configuration and user tier:

```typescript
export class AIServiceFactory {
  private readonly generalLLMService: GeneralLLMServiceInterface;
  private readonly userContextProvider: UserContextProvider;
  private readonly featureFlagsService: FeatureFlagsService;
  
  constructor(
    generalLLMService: GeneralLLMServiceInterface,
    userContextProvider: UserContextProvider,
    featureFlagsService: FeatureFlagsService
  ) {
    this.generalLLMService = generalLLMService;
    this.userContextProvider = userContextProvider;
    this.featureFlagsService = featureFlagsService;
  }
  
  async createService(feature: string): Promise<AIServiceInterface> {
    // Get user info
    const user = await this.userContextProvider.getCurrentUser();
    const userContext = user ? await this.userContextProvider.getUserContext(user.id) : null;
    const tier = user?.subscription?.tier || 'standard';
    
    // Check for mock mode
    const useMock = await this.featureFlagsService.isFeatureEnabled('use_mock_ai');
    
    if (useMock) {
      return new MockAIService(feature);
    }
    
    // Create the appropriate service based on feature and tier
    return new MultiTieredAIService(
      this.generalLLMService,
      userContext,
      tier
    );
  }
}
```

### Mock Services

For development and testing purposes, mock implementations of the AI services are provided:

```typescript
export class MockAIService implements AIServiceInterface {
  private readonly feature: string;
  
  constructor(feature: string) {
    this.feature = feature;
  }
  
  async generateIdeas(params: IdeaGenerationParams): Promise<IdeaPlaygroundIdea[]> {
    // Return predefined mock ideas
    return [
      {
        id: 'mock-idea-1',
        canvas_id: 'mock-canvas',
        title: 'AI-Powered Health Diagnostics',
        description: 'A mobile app that uses AI to diagnose common health issues based on symptoms and medical history.',
        problem_statement: 'People often delay seeking medical help due to inconvenience, cost, or uncertainty about their symptoms.',
        solution_concept: 'An AI-powered mobile app that provides preliminary diagnoses, risk assessments, and guidance on when to seek professional medical help.',
        target_audience: 'Health-conscious individuals aged 25-55 who value convenience and preemptive healthcare.',
        unique_value: 'Immediate health insights without appointment waiting times or doctor visits for minor concerns.',
        business_model: 'Freemium model with basic diagnostics free and premium features requiring subscription.',
        marketing_strategy: 'Partner with health insurance providers to offer as a benefit to their customers.',
        revenue_model: 'Subscription fees, partnerships with healthcare providers, and anonymized data insights.',
        go_to_market: 'Launch in select markets with high smartphone penetration and healthcare costs.',
        market_size: 'The global digital health market is projected to reach $500 billion by 2025.',
        used_company_context: false,
        is_archived: false,
        version: 1,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      // Additional mock ideas...
    ];
  }
  
  // Other mock implementations...
}
```

## UI Integration Points

Wheel99 integrates AI capabilities directly into the user interface through specialized components and patterns.

### AI-Assisted Components

AI-assisted components enhance standard form inputs with intelligent suggestions and completions.

#### AI Assisted Input

```typescript
export interface AIAssistedInputProps extends Omit<InputProps, 'onChange'> {
  label: string;
  contextType: string;
  onValueChange: (value: string) => void;
  useAI?: boolean;
  showSuggestions?: boolean;
}

export const AIAssistedInput: React.FC<AIAssistedInputProps> = ({
  label,
  contextType,
  onValueChange,
  useAI = true,
  showSuggestions = true,
  ...props
}) => {
  const [value, setValue] = useState(props.value?.toString() || '');
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const { getSuggestions, completeText } = useAIContext();
  
  // Get suggestions when the input changes
  useEffect(() => {
    if (useAI && showSuggestions && value.length > 0) {
      const fetchSuggestions = async () => {
        const newSuggestions = await getSuggestions(value, contextType);
        setSuggestions(newSuggestions);
      };
      
      const timer = setTimeout(fetchSuggestions, 500);
      return () => clearTimeout(timer);
    } else {
      setSuggestions([]);
    }
  }, [value, useAI, showSuggestions, contextType, getSuggestions]);
  
  // Handle value changes
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setValue(newValue);
    onValueChange(newValue);
  };
  
  // Apply a suggestion
  const applySuggestion = (suggestion: string) => {
    setValue(suggestion);
    onValueChange(suggestion);
    setSuggestions([]);
  };
  
  // Complete the input
  const handleComplete = async () => {
    if (useAI && value.length > 0) {
      const completed = await completeText(value, contextType);
      setValue(completed);
      onValueChange(completed);
    }
  };
  
  return (
    <div className="relative">
      <label htmlFor={props.id} className="block text-sm font-medium text-gray-700">
        {label}
      </label>
      <div className="mt-1 flex rounded-md shadow-sm">
        <input
          {...props}
          type="text"
          className="focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md"
          value={value}
          onChange={handleChange}
        />
        {useAI && (
          <button
            type="button"
            className="ml-2 inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            onClick={handleComplete}
          >
            Complete
          </button>
        )}
      </div>
      
      {/* Suggestions dropdown */}
      {suggestions.length > 0 && (
        <div className="absolute z-10 mt-1 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-base ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none sm:text-sm">
          {suggestions.map((suggestion, index) => (
            <div
              key={index}
              className="cursor-pointer select-none relative py-2 pl-3 pr-9 text-gray-900 hover:bg-indigo-50"
              onClick={() => applySuggestion(suggestion)}
            >
              {suggestion}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

#### AI Assisted Text Area

Similar to AIAssistedInput but for multi-line text inputs, with additional features like section-by-section AI enhancement.

### Smart Suggestion Buttons

Smart suggestion buttons provide context-aware suggestions for specific actions or content.

```typescript
export interface SmartSuggestionButtonProps {
  contextType: string;
  contextData?: any;
  onSuggestionAccepted: (suggestion: string) => void;
  buttonText?: string;
  buttonClassName?: string;
}

export const SmartSuggestionButton: React.FC<SmartSuggestionButtonProps> = ({
  contextType,
  contextData,
  onSuggestionAccepted,
  buttonText = "Get Suggestion",
  buttonClassName = "",
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { getSuggestions } = useAIContext();
  
  const handleClick = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const suggestions = await getSuggestions(contextData, contextType);
      
      if (suggestions && suggestions.length > 0) {
        onSuggestionAccepted(suggestions[0]);
      } else {
        setError("No suggestions available");
      }
    } catch (err) {
      setError("Failed to get suggestions");
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div>
      <button
        type="button"
        className={`inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 ${buttonClassName}`}
        onClick={handleClick}
        disabled={isLoading}
      >
        {isLoading ? (
          <>
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Generating...
          </>
        ) : (
          buttonText
        )}
      </button>
      
      {error && (
        <p className="mt-2 text-sm text-red-600">
          {error}
        </p>
      )}
    </div>
  );
};
```

### Contextual AI Panels

Contextual AI panels provide in-context assistance and explanations to users.

```typescript
export interface ContextualAIPanelProps {
  contextType: string;
  contextData: any;
  title?: string;
  collapsed?: boolean;
}

export const ContextualAIPanel: React.FC<ContextualAIPanelProps> = ({
  contextType,
  contextData,
  title = "AI Insights",
  collapsed = false,
}) => {
  const [isCollapsed, setIsCollapsed] = useState(collapsed);
  const [insights, setInsights] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const { getContextualHelp } = useAIContext();
  
  useEffect(() => {
    if (!isCollapsed && !insights) {
      const loadInsights = async () => {
        setIsLoading(true);
        try {
          const help = await getContextualHelp(contextType, contextData);
          setInsights(help);
        } catch (error) {
          console.error("Failed to load AI insights", error);
          setInsights("Unable to load AI insights at this time.");
        } finally {
          setIsLoading(false);
        }
      };
      
      loadInsights();
    }
  }, [isCollapsed, insights, contextType, contextData, getContextualHelp]);
  
  return (
    <div className="bg-blue-50 rounded-lg shadow-sm p-4 mt-4">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-medium text-blue-800">{title}</h3>
        <button
          type="button"
          className="text-blue-600 hover:text-blue-800"
          onClick={() => setIsCollapsed(!isCollapsed)}
        >
          {isCollapsed ? 'Expand' : 'Collapse'}
        </button>
      </div>
      
      {!isCollapsed && (
        <div className="mt-2">
          {isLoading ? (
            <div className="flex justify-center">
              <svg className="animate-spin h-5 w-5 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            </div>
          ) : insights ? (
            <div className="prose max-w-none text-blue-700">
              {/* Use a markdown component to render insights */}
              <ReactMarkdown>{insights}</ReactMarkdown>
            </div>
          ) : (
            <p className="text-blue-700">No insights available.</p>
          )}
        </div>
      )}
    </div>
  );
};
```

### AI Context Providers

AI context providers make AI capabilities available to React components through the Context API.

```typescript
export interface AIContextValue {
  // Suggestion capabilities
  getSuggestions: (context: any, contextType: string) => Promise<string[]>;
  
  // Text completion
  completeText: (text: string, contextType: string) => Promise<string>;
  
  // Content enhancement
  enhanceContent: (content: string, enhancementType: string) => Promise<string>;
  
  // Contextual help
  getContextualHelp: (contextType: string, contextData: any) => Promise<string>;
  
  // Loading state
  isLoading: boolean;
}

export const AIContext = createContext<AIContextValue>({
  getSuggestions: async () => [],
  completeText: async (text) => text,
  enhanceContent: async (content) => content,
  getContextualHelp: async () => "",
  isLoading: false,
});

export interface AIContextProviderProps {
  children: React.ReactNode;
  feature: string;
}

export const AIContextProvider: React.FC<AIContextProviderProps> = ({
  children,
  feature,
}) => {
  const [aiService, setAIService] = useState<AIServiceInterface | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const aiServiceFactory = useAIServiceFactory();
  
  // Initialize the AI service
  useEffect(() => {
    const initService = async () => {
      try {
        const service = await aiServiceFactory.createService(feature);
        setAIService(service);
      } catch (error) {
        console.error("Failed to initialize AI service", error);
        // Fallback to mock service
        setAIService(new MockAIService(feature));
      }
    };
    
    initService();
  }, [feature, aiServiceFactory]);
  
  // AI context methods
  const getSuggestions = async (context: any, contextType: string): Promise<string[]> => {
    if (!aiService) return [];
    
    setIsLoading(true);
    try {
      const suggestions = await aiService.getSuggestions({ context, contextType });
      return suggestions.map(s => s.text);
    } catch (error) {
      console.error("Error getting suggestions", error);
      return [];
    } finally {
      setIsLoading(false);
    }
  };
  
  const completeText = async (text: string, contextType: string): Promise<string> => {
    if (!aiService) return text;
    
    setIsLoading(true);
    try {
      return await aiService.completeText(text, contextType);
    } catch (error) {
      console.error("Error completing text", error);
      return text;
    } finally {
      setIsLoading(false);
    }
  };
  
  const enhanceContent = async (content: string, enhancementType: string): Promise<string> => {
    if (!aiService) return content;
    
    setIsLoading(true);
    try {
      const component = {
        id: 'temp',
        idea_id: 'temp',
        component_type: enhancementType,
        content,
        is_selected: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };
      
      const enhanced = await aiService.enhanceComponent(component, "improve");
      return enhanced.content;
    } catch (error) {
      console.error("Error enhancing content", error);
      return content;
    } finally {
      setIsLoading(false);
    }
  };
  
  const getContextualHelp = async (contextType: string, contextData: any): Promise<string> => {
    if (!aiService) return "";
    
    setIsLoading(true);
    try {
      const suggestions = await aiService.getSuggestions({
        context: contextData,
        contextType: `help_${contextType}`,
      });
      
      return suggestions.length > 0 ? suggestions[0].text : "";
    } catch (error) {
      console.error("Error getting contextual help", error);
      return "";
    } finally {
      setIsLoading(false);
    }
  };
  
  const value: AIContextValue = {
    getSuggestions,
    completeText,
    enhanceContent,
    getContextualHelp,
    isLoading,
  };
  
  return (
    <AIContext.Provider value={value}>
      {children}
    </AIContext.Provider>
  );
};

// Custom hook for using the AI context
export const useAIContext = () => useContext(AIContext);
```

## Prompt Engineering

The effectiveness of the AI capabilities depends heavily on well-crafted prompts that guide the language models toward useful responses.

### Prompt Templates

Prompt templates define the structure of prompts used for different AI operations.

```typescript
export interface PromptTemplate {
  system: string;
  user: string;
}

export const IDEA_GENERATION_TEMPLATE: PromptTemplate = {
  system: `
    You are an expert business strategist and innovation consultant with experience across multiple industries.
    Your task is to generate innovative, practical, and market-viable business ideas based on the user's parameters.
    
    For each idea, provide:
    1. A concise title
    2. A brief description (2-3 sentences)
    3. A clear problem statement
    4. A solution concept that addresses the problem
    5. A defined target audience/customer segment
    6. A unique value proposition
    7. A potential business model
    8. A preliminary marketing strategy
    9. A revenue model
    10. A go-to-market approach
    11. An estimate of the potential market size
    
    Ensure that each idea is:
    - Specific and actionable
    - Addresses a real market need
    - Differentiated from obvious competitors
    - Realistic given current technology and market conditions
    - Scalable and potentially profitable
    
    Format your response as JSON object that can be parsed.
  `,
  
  user: `
    Generate {{count

================
File: docs/AI_SERVICES_FIX.md
================
# AI Services and Standup Bot Fix

## Issue Summary

The standup bot and other AI features were not working correctly. The error messages indicated two primary issues:

1. The supabase HTTP API returned a 406 (Not Acceptable) error when attempting to fetch user profiles
2. There was a 404 (Not Found) error when trying to call the `service_role_api.init_user_profile` function

## Root Causes

After investigation, we identified the following root causes:

1. **LLM Service Reset Issue**: The StandupAIService had previously disabled LLM service resets as it was causing issues, but this meant the service wasn't properly initializing with the latest feature flags.

2. **Feature Flag Conflicts**: There might have been conflicting feature flags (useRealAI vs. useMockAI) that were causing the AI services to use the wrong implementation.

3. **API Configuration**: The OpenAI API key might not have been properly configured or might have expired.

## Implemented Fixes

### 1. Fixed StandupAIService.ts

Re-enabled the LLM service reset with proper error handling:

```typescript
// Re-enabled LLM service reset with error handling
try {
  featureFlagsService.resetLLMService();
  console.log('LLM service reset successful');
} catch (resetError) {
  console.error('Error resetting LLM service:', resetError);
  // Continue execution despite reset error
}
```

This ensures that the LLM service gets updated when feature flags change, while preventing the reset from crashing the entire application if there's an issue.

### 2. Created Diagnostic Tools

Created several scripts to diagnose and fix AI service issues:

#### fix-ai-services.js
- Checks OpenAI API configuration in the database
- Verifies and corrects feature flags if they're misconfigured
- Resets the LLM service to use the correct configuration
- Tests basic LLM functionality and conversation memory

#### test-standup-bot.js
- Tests each component of the standup bot individually
- Verifies that section feedback, summaries, and task generation work
- Creates test data to validate the conversation flow

#### run-ai-diagnostics.sh
- Shell script to make it easy to run the diagnostic tools
- Provides a menu to select different diagnostic options
- Includes guidance for resolving persistent issues

## How to Use

1. Run the diagnostic script:
   ```
   ./scripts/run-ai-diagnostics.sh
   ```

2. Select an option:
   - Option 1: Run the general AI services diagnostic
   - Option 2: Run the standup bot test
   - Option 3: Run both diagnostics

3. Review the results and follow any suggested fixes

## Technical Details

The fix addresses several architectural considerations:

1. **Service Initialization**: The LLM service is now properly reset when feature flags change
2. **Error Handling**: Added robust error handling to prevent cascading failures
3. **Testing Isolation**: Created test user IDs and entries to avoid affecting production data
4. **Diagnostic Logging**: Enhanced logging to identify issues more easily

## Additional Recommendations

If issues persist, check:

1. Verify your OpenAI API key is valid and properly set in your database
2. Ensure network connectivity to OpenAI's API
3. Check for any firewall or proxy issues that might be blocking API calls
4. Verify your feature flags are properly set: useRealAI=true, useMockAI=false

================
File: docs/COMPANY_JOURNEY_PAGE_INTERACTIVE_AI.md
================
# Interactive, AI-Augmented Company Journey Page: Build Plan & Schema

## Overview

This document describes the architecture, features, and database schema for the new Company Journey page, designed to be highly interactive, founder-focused, and AI-augmented from the start.

---

## Features to Build

### 1. Interactive Journey Board
- Drag-and-drop board or timeline view for all journey steps, grouped by phase or status (Not Started, In Progress, Completed, Skipped, Not Needed).
- StepCard component for each step, supporting:
  - Marking as Complete, Skipped, Not Needed, or In Progress (single click or context menu).
  - Drag-and-drop reordering within/between phases/statuses.
  - Adding/editing notes, attaching documents, and viewing recommendations.
  - Adding custom steps or phases.
  - Marking steps as "Can be done in parallel" and visually grouping them.
  - Hiding/archiving steps.
- Filtering, sorting, and search for steps, notes, or resources.

### 2. AI-Powered Contextual Guidance
- AI Recommendation Panel:
  - Shows next best steps, focus areas, and parallelizable work based on company data and journey history.
  - Provides recommendations, tips, and resources for each step, personalized to the company’s context and what similar companies have done.
  - Allows founders to ask questions about their journey and get contextual answers (initially via a generic model, later a contextual one).
- All AI hooks are in place from the start, with a service abstraction for easy model upgrades.

### 3. Founder-Centric UX
- “My Journey” summary at the top: progress, focus, blockers, and next steps (AI-powered).
- All actions (status change, reorder, add note, etc.) are instant, undoable, and collaborative (real-time updates for all team members).
- Mobile-friendly, accessible, and visually engaging.

### 4. Technical/Service Considerations
- Modular UI: StepCard, PhaseColumn, JourneyBoard, AIRecommendationPanel, etc.
- Service methods for updating step status, order, notes, custom steps, and AI queries.
- Real-time updates (Supabase subscriptions or polling).

---

## SQL Migration

See `supabase/migrations/20250428_journey_page_interactive_enhancements.sql` for the following:

- Add support for custom step order, parallel steps, and archiving in `company_progress`
- Table for custom company steps: `company_custom_steps`
- Tables for AI recommendations and Q&A: `company_journey_ai_recommendations`, `company_journey_ai_questions`
- Indexes for efficient lookup

---

## Next Steps

1. Run the migration to update your schema.
2. Build the new Company Journey page and supporting services/components as outlined above.
3. Integrate AI hooks for recommendations and Q&A, starting with a generic model and planning for future contextual upgrades.

================
File: docs/COMPREHENSIVE_DOCUMENTATION.md
================
# Wheel99 Comprehensive Documentation

## Overview

This document serves as the master reference for Wheel99, a comprehensive business ideation and development platform with AI assistance at its core. This documentation covers all aspects of the platform including features, technical architecture, AI implementation, roadmap, and user stories.

## Table of Contents

1. [Introduction](#introduction)
2. [Documentation Structure](#documentation-structure)
3. [Current Implementation](#current-implementation)
4. [Feature Overview](#feature-overview)
5. [Technical Architecture](#technical-architecture)
6. [AI Implementation](#ai-implementation)
7. [Planned Improvements](#planned-improvements)
8. [User Stories](#user-stories)
9. [Getting Started](#getting-started)

## Introduction

Wheel99 is a platform designed to help entrepreneurs, business strategists, and innovation teams generate, refine, and develop business ideas with AI assistance. The platform democratizes business ideation by providing powerful AI-assisted tools that make the process of generating and developing business ideas more accessible, efficient, and effective.

The platform features three main components:

1. **Idea Playground** - A structured environment for business idea creation and development with multiple pathways for idea refinement
2. **Standup Bot** - AI-powered assistant for conducting effective standups by providing feedback, generating summaries, and suggesting tasks
3. **Task Generation** - Intelligent system for suggesting relevant, context-aware tasks based on user input and project status

By combining structured workflows with contextual AI assistance, Wheel99 helps users transform raw ideas into well-developed business concepts ready for implementation.

## Documentation Structure

This comprehensive documentation is organized into several detailed documents:

- **Core Features** ([CORE_FEATURES.md](./CORE_FEATURES.md)): Detailed description of all currently implemented features, their functionality, and implementation details.
- **Technical Architecture** ([TECHNICAL_ARCHITECTURE.md](./TECHNICAL_ARCHITECTURE.md)): System design, component architecture, data structures, API interfaces, and technical requirements.
- **AI Implementation** ([AI_IMPLEMENTATION.md](./AI_IMPLEMENTATION.md)): Detailed explanation of AI integration, context-aware features, prompt engineering, and AI service architecture.
- **Roadmap** ([ROADMAP.md](./ROADMAP.md)): Planned improvements, future features, and technical debt items.
- **User Stories** ([USER_STORIES.md](./USER_STORIES.md)): Detailed user stories with acceptance criteria and assumptions for all features.
- **Specialized Documentation**:
  - [STANDUP_BOT.md](./STANDUP_BOT.md): Detailed documentation of the Standup Bot feature.
  - [TASK_GENERATION.md](./TASK_GENERATION.md): Detailed documentation of the Task Generation feature.

## Current Implementation

The current implementation of Wheel99 has the following core capabilities:

### Idea Playground
- **Canvas Management**: Create, organize, and switch between multiple idea canvases
- **AI-Assisted Idea Generation**: Generate business ideas based on user-defined parameters
- **Idea Refinement**: Improve specific aspects of ideas with AI assistance
- **Multiple Development Pathways**: Three distinct approaches to idea development:
  - Problem-Solution Pathway
  - Industry-Based Pathway
  - Idea Library Pathway
- **Enhanced Workflow**: Structured, stage-based development from ideation to implementation
- **Idea Organization**: Tag, search, and organize ideas into collections
- **Export and Integration**: Share and export ideas in various formats

### Standup Bot
- **Section-by-Section Feedback**: Contextual feedback on standup entries
- **Standup Summary**: Comprehensive summaries of standup information
- **Context-Aware Responses**: Responses that consider conversation history and startup stage

### Task Generation
- **Context-Aware Task Suggestions**: Generate tasks based on user input and context
- **Comprehensive Task Details**: Rich task metadata including success metrics
- **Task Management**: Tools for organizing and tracking tasks

## Feature Overview

For detailed descriptions of all features, please refer to [CORE_FEATURES.md](./CORE_FEATURES.md).

### Idea Playground Key Features

- **Canvas Management**: Organize idea work into separate canvases with company context integration
- **Idea Generation**: Generate business ideas from parameters with AI assistance
- **Idea Organization**: Tag, search, and group ideas with a flexible organizational system
- **Idea Development Pathways**: Three distinct approaches to developing ideas
  - Problem-Solution Focus: Define problem, develop solutions, refine value proposition
  - Industry-Based Approach: Industry exploration, competitive analysis, idea comparison
  - Idea Library: Browse templates, customize selections, analyze viability
- **Enhanced Workflow**: Stage-based development process with progress tracking
- **Idea Refinement**: Targeted improvement of specific idea components with AI assistance
- **Idea Comparison**: Compare multiple ideas using custom criteria and benchmarks
- **Business Analysis**: Market validation, business model development, go-to-market planning

### Standup Bot Key Features

- **Feedback on Accomplishments**: Context-aware feedback on completed work
- **Work-in-Progress Insights**: Strategic guidance on current tasks
- **Blocker Solutions**: Suggestions for overcoming obstacles
- **Goal Setting Assistance**: Help with creating effective, aligned goals
- **Comprehensive Summaries**: Overview of standup with strategic recommendations
- **Context-Aware Dialogue**: Responses that consider historical context

### Task Generation Key Features

- **Input-Based Task Creation**: Generate tasks from standup entries and user input
- **Project Context Integration**: Tasks aligned with project stage and goals
- **Rich Task Metadata**: Detailed information including priorities and resources
- **Success Metrics**: Clear criteria for task completion
- **Task Organization**: Tools for managing and tracking task progress

## Technical Architecture

For detailed technical architecture documentation, please refer to [TECHNICAL_ARCHITECTURE.md](./TECHNICAL_ARCHITECTURE.md).

### Overview

Wheel99 follows a modern web application architecture with clear separation of concerns:

- **Frontend**: React 18 with TypeScript, Zustand for state management, TailwindCSS for styling
- **Backend**: Supabase for database, authentication, and storage
- **AI Integration**: OpenAI API with custom service layer

### Component Architecture

The application is organized into feature-specific components:

- **Idea Playground Components**: Canvas management, idea generation, organization, refinement
- **Pathway Components**: Problem-Solution, Industry-Based, Idea Library pathways
- **Enhanced Workflow Components**: Dashboard, navigation, stage-based development
- **Shared Components**: Reusable UI elements and AI-assisted components

### Service Layer

- **Core Services**: Authentication, profile management, feature flags
- **Feature Services**: Idea playground service, general LLM service
- **AI Services**: Multi-tiered AI service, standup service

### Data Architecture

- **Database Schema**: PostgreSQL tables via Supabase
- **TypeScript Types**: Well-defined interfaces matching database schema

## AI Implementation

For detailed AI implementation documentation, please refer to [AI_IMPLEMENTATION.md](./AI_IMPLEMENTATION.md).

### Three-Tiered Contextual Model

Wheel99 employs a three-tiered contextual model:

1. **General-Purpose Tier**: Broad knowledge and language understanding
2. **Domain-Specific Tier**: Business ideation and entrepreneurship knowledge
3. **User-Specific Tier**: Incorporating user's company and historical context

### AI Services Architecture

- **Service Interfaces**: TypeScript interfaces defining AI service contracts
- **Implementation Classes**: Concrete classes handling AI functionality
- **Factory Pattern**: Dynamic service creation based on configuration

### UI Integration Points

- **AI-Assisted Components**: Form inputs with intelligent suggestions
- **Smart Suggestion Buttons**: Context-aware suggestion generation
- **Contextual AI Panels**: In-context assistance and explanations
- **AI Context Providers**: React context for AI capabilities

## Planned Improvements

For detailed roadmap information, please refer to [ROADMAP.md](./ROADMAP.md).

### Short-term Enhancements

- **User Experience Improvements**: Onboarding enhancements, UI/UX refinements
- **Feature Refinements**: Enhanced idea comparison, collaboration features, advanced filtering
- **Technical Optimizations**: Performance improvements, architectural enhancements

### Long-term Vision

- **Advanced AI Capabilities**: Multi-model strategy, advanced context awareness
- **Platform Expansion**: Additional modules, ecosystem development
- **Ecosystem Integration**: External service integration, data exchange standards
- **Enterprise Features**: Organization-level capabilities, enterprise integration

### Technical Debt Items

- **Code Refactoring**: Component consolidation, architecture improvements
- **Test Coverage**: Unit testing, integration testing
- **Infrastructure Improvements**: Development environment, deployment pipeline
- **Performance Optimization**: Frontend and backend optimization

## User Stories

For detailed user stories with acceptance criteria and assumptions, please refer to [USER_STORIES.md](./USER_STORIES.md).

The user stories are organized by feature area and grouped into epics, providing a comprehensive view of the system from the user's perspective. Each user story includes:

- **Title**: A concise description
- **Description**: As a [role], I want [feature] so that [benefit]
- **Acceptance Criteria**: Specific requirements that must be met
- **Assumptions**: Key assumptions underlying the user story
- **Priority**: The relative importance (High/Medium/Low)

## Getting Started

### Development Setup

1. **Prerequisites**:
   - Node.js 16+
   - npm 8+
   - Supabase account
   - OpenAI API key

2. **Installation**:
   ```bash
   # Clone the repository
   git clone [repository-url]
   
   # Install dependencies
   cd wheel99
   npm install
   
   # Set up environment variables
   cp .env.example .env
   # Edit .env with your API keys and configuration
   
   # Run the development server
   npm run dev
   ```

3. **Database Setup**:
   ```bash
   # Run Supabase migrations
   npm run migrate
   
   # Initialize feature flags
   npm run init-feature-flags
   ```

### Key Development Commands

- `npm run dev`: Start the development server
- `npm run build`: Build for production
- `npm run test`: Run tests
- `npm run lint`: Run linting
- `npm run migrate`: Run database migrations
- `npm run init-feature-flags`: Initialize feature flags

### Feature Flag Management

Wheel99 uses feature flags for controlled feature rollout. Key flags include:

- `enable_enhanced_workflow`: Enables the enhanced workflow interface
- `enable_pathways`: Enables idea development pathways
- `use_mock_ai`: Uses mock AI services instead of real ones
- `enable_standup_bot`: Enables the Standup Bot feature
- `enable_task_generation`: Enables the Task Generation feature

These can be toggled in the admin interface or via the `feature-flags.service.ts` API.

---

This comprehensive documentation is maintained by the Wheel99 development team. For questions or contributions, please contact [support@wheel99.com](mailto:support@wheel99.com).

================
File: docs/CORE_FEATURES.md
================
# Wheel99 Core Features

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [Idea Playground](#idea-playground)
   - [Canvas Management](#canvas-management)
   - [Idea Generation](#idea-generation)
   - [Idea Organization](#idea-organization)
   - [Idea Development Pathways](#idea-development-pathways)
   - [Enhanced Idea Playground](#enhanced-idea-playground)
   - [Idea Refinement Tools](#idea-refinement-tools)
   - [Export and Integration](#export-and-integration)
3. [Standup Bot](#standup-bot)
   - [Section-by-Section Feedback](#section-by-section-feedback)
   - [Standup Summary](#standup-summary)
   - [Context-Aware Responses](#context-aware-responses)
4. [Task Generation](#task-generation)
   - [Context-Aware Task Suggestions](#context-aware-task-suggestions)
   - [Comprehensive Task Details](#comprehensive-task-details)
   - [Task Management](#task-management)

## Executive Summary

Wheel99 is a comprehensive business ideation and development platform designed to help entrepreneurs, business strategists, and innovation teams generate, refine, and develop business ideas with AI assistance. The platform's key features include:

1. **Idea Playground** - A structured environment for business idea creation and development with multiple pathways for idea refinement
2. **AI-Assisted Components** - Intelligent assistance throughout the ideation and refinement process using a three-tiered contextual AI model
3. **Standup Bot** - AI-powered assistant for conducting effective standups by providing feedback, generating summaries, and suggesting tasks
4. **Task Generation** - Intelligent system for suggesting relevant, context-aware tasks based on user input and project status

Wheel99 aims to democratize business ideation by providing powerful AI-assisted tools that make the process of generating and developing business ideas more accessible, efficient, and effective. By combining structured workflows with contextual AI assistance, it helps users transform raw ideas into well-developed business concepts ready for implementation.

## Idea Playground

The Idea Playground is the core feature of Wheel99, providing a structured environment for business idea creation and development.

### Canvas Management

- **Canvas Creation**: Users can create multiple canvases to organize related ideas
  - Implementation: `CreateCanvasModal.tsx` component
  - Functionality: Name, description, company context settings
  
- **Canvas Selection**: Users can view and switch between different idea canvases
  - Implementation: `CanvasSelector.tsx` component
  - Functionality: List view, filtering, sorting, archiving

- **Canvas Organization**: Management of canvas structure and relationships
  - Implementation: Database tables with canvas-idea relationships
  - Functionality: Moving ideas between canvases, duplicating canvases

### Idea Generation

- **AI-Assisted Idea Generation**: Generate business ideas based on user-defined parameters
  - Implementation: `IdeaGenerationForm.tsx` component, `AIServiceInterface`
  - Functionality: Multiple idea variations with detailed business attributes
  
- **Generation Parameters**: Customizable parameters for idea generation
  - Implementation: `IdeaGenerationParams` type
  - Parameters:
    - Industry focus
    - Target audience
    - Problem area
    - Technology focus
    - Business model preferences
    - Market size preferences
    - Innovation level
    - Resource constraints
    - Company context integration

- **Manual Idea Capture**: Entry of ideas with structured fields
  - Implementation: `IdeaCaptureScreen.tsx`
  - Functionality: Form-based entry with AI assistance for field completion

### Idea Organization

- **Idea Listing**: View and manage ideas within a canvas
  - Implementation: `IdeaList.tsx`, `IdeaCard.tsx`
  - Functionality: Grid/list views, filtering, sorting, search

- **Idea Tagging**: Categorize ideas with customizable tags
  - Implementation: Database tables for tags and idea-tag relationships
  - Functionality: Tag creation, assignment, filtering by tags

- **Idea Versioning**: Track changes to ideas over time
  - Implementation: Version field in idea records
  - Functionality: Version history, comparison, duplication

### Idea Development Pathways

Wheel99 provides three distinct pathways for idea development:

#### Pathway 1: Problem-Solution Focus

- **Problem Definition**: Structured workflow for defining the problem
  - Implementation: `ProblemSolutionScreen.tsx`
  - Functionality: Problem statement refinement, validation, contextual AI guidance

- **Solution Conceptualization**: Development of solution concepts
  - Implementation: `ProblemSolutionScreen.tsx`
  - Functionality: Solution ideation, refinement, problem-solution fit assessment

- **Target Audience & Value Proposition**: Refine target audience and value proposition
  - Implementation: `TargetValueScreen.tsx`
  - Functionality: Target segment definition, value proposition canvas, market size estimation

- **Business Model Development**: Create comprehensive business model
  - Implementation: `BusinessModelScreen.tsx`
  - Functionality: Revenue model, cost structure, key resources, partnerships

- **Go-to-Market Strategy**: Develop go-to-market approach
  - Implementation: `GoToMarketScreen.tsx`
  - Functionality: Marketing strategy, sales approach, channel selection, launch planning

#### Pathway 2: Industry-Based Approach

- **Industry Selection and Analysis**: Select and analyze industries
  - Implementation: `IndustrySelectionScreen.tsx`
  - Functionality: Industry browsing, trend analysis, opportunity mapping

- **Competitive Positioning**: Position ideas in competitive landscape
  - Implementation: Components in Pathway 2
  - Functionality: Competitor analysis, differentiation strategy, positioning matrix

- **Idea Comparison**: Compare multiple approaches
  - Implementation: `IdeaComparisonScreen.tsx`
  - Functionality: Side-by-side comparison, evaluation criteria, scoring system

- **Idea Refinement**: Refine ideas based on industry insights
  - Implementation: `IdeaRefinementScreen.tsx` (Pathway 2)
  - Functionality: Industry-specific refinement, competitive adjustment

#### Pathway 3: Idea Library Approach

- **Idea Template Browsing**: Browse pre-generated idea templates
  - Implementation: `IdeaLibraryScreen.tsx`
  - Functionality: Template browsing, filtering, preview

- **Template Customization**: Adapt existing templates
  - Implementation: Components in Pathway 3
  - Functionality: Template adaptation, contextualization

- **Idea Analysis**: Analyze selected templates
  - Implementation: `IdeaAnalysisScreen.tsx`
  - Functionality: Strength/weakness analysis, opportunity assessment

- **Idea Refinement**: Refine selected templates
  - Implementation: `IdeaRefinementScreen.tsx` (Pathway 3)
  - Functionality: Template-based refinement, customization

### Enhanced Idea Playground

The enhanced version of the Idea Playground provides a structured, stage-based approach to idea development:

- **Dashboard**: Overview of all ideas with progress tracking
  - Implementation: `Dashboard.tsx`
  - Functionality: Idea listing, filtering, sorting, progress visualization

- **Navigation**: Stage-based navigation through idea development
  - Implementation: `NavigationSidebar.tsx`
  - Functionality: Stage visualization, progress tracking, navigation controls

- **Workflow Management**: State machine for idea development workflow
  - Implementation: `idea-workflow.machine.ts`
  - Functionality: Stage transitions, state management, progress tracking

- **Stages Implementation**:
  - `IdeaGenerationStage.tsx`: Initial idea creation
  - `InitialAssessmentStage.tsx`: First-pass idea assessment
  - `DetailedRefinementStage.tsx`: In-depth idea refinement
  - `MarketValidationStage.tsx`: Market analysis and validation
  - `BusinessModelStage.tsx`: Business model development
  - `GoToMarketStage.tsx`: Go-to-market strategy
  - `CompanyFormationStage.tsx`: Implementation planning

### Idea Refinement Tools

- **AI-Assisted Refinement**: Targeted improvement of specific aspects
  - Implementation: `IdeaRefinementForm.tsx`
  - Functionality: Section-specific refinement, before/after comparison

- **Structured Feedback**: Automated evaluation against best practices
  - Implementation: Feedback system in various components
  - Functionality: Scoring, benchmarking, improvement recommendations

- **Components and Field Refinement**: Granular improvement of idea elements
  - Implementation: Various AI-assisted components
  - Functionality: Field-specific suggestions, content enhancement

### Export and Integration

- **Idea Export**: Export ideas in different formats
  - Implementation: `IdeaExportModal.tsx`
  - Functionality: PDF, presentation, document formats

- **Export Customization**: Configure export content and format
  - Implementation: Export parameters in the export modal
  - Functionality: Section selection, branding options, format settings

## Standup Bot

The Standup Bot is an AI-powered assistant that helps teams conduct more effective standups by providing feedback, generating summaries, and suggesting tasks.

### Section-by-Section Feedback

- **Accomplished Section Feedback**: Feedback on completed work
  - Implementation: `standup-context-provider.tsx`
  - Functionality: Contextual feedback, follow-up questions

- **Working On Feedback**: Insights on current tasks
  - Implementation: Standup AI service
  - Functionality: Improvement suggestions, priority guidance

- **Blockers Assistance**: Help identifying solutions to obstacles
  - Implementation: Standup AI components
  - Functionality: Solution suggestions, resource recommendations

- **Goals Guidance**: Help setting effective goals
  - Implementation: Goal-setting components
  - Functionality: Goal refinement, alignment with objectives

### Standup Summary

- **Comprehensive Summary**: Overview of standup information
  - Implementation: Summary generation in standup service
  - Functionality: Progress assessment, strengths identification, improvement areas

- **Strategic Recommendations**: Actionable next steps
  - Implementation: Recommendation engine in standup service
  - Functionality: Strategic guidance, opportunity highlighting

### Context-Aware Responses

- **Conversation Memory**: History-aware responses
  - Implementation: Context tracking in standup service
  - Functionality: Reference to past work and progress

- **Startup Stage Detection**: Stage-specific guidance
  - Implementation: Stage detection algorithms
  - Functionality: Tailored feedback for idea, early, or growth stages

- **Question Tracking**: Diverse follow-up questions
  - Implementation: Question history tracking
  - Functionality: Avoiding repetition, ensuring diverse inquiries

## Task Generation

The Task Generation system automatically suggests relevant tasks based on user input, standup entries, and project context.

### Context-Aware Task Suggestions

- **Input-Based Tasks**: Generate tasks from user entries
  - Implementation: Task generation service
  - Functionality: Contextual task creation from standup entries

- **Project Context Integration**: Incorporate project status
  - Implementation: Context-aware algorithms
  - Functionality: Tasks aligned with project stage and goals

### Comprehensive Task Details

- **Detailed Task Information**: Rich task metadata
  - Implementation: Task data structure and UI
  - Functionality: Title, description, priority, estimates, tips

- **Success Metrics**: Clear completion criteria
  - Implementation: Success metrics field in tasks
  - Functionality: Measurable outcomes for task completion

- **Resource Recommendations**: Suggested tools and references
  - Implementation: Resource linking in tasks
  - Functionality: Links to relevant tools, guides, references

### Task Management

- **Task Organization**: Manage task lists
  - Implementation: Task management components
  - Functionality: Filtering, sorting, categorization

- **Progress Tracking**: Monitor task completion
  - Implementation: Task status tracking
  - Functionality: Status updates, completion recording

================
File: docs/DASHBOARD_LOADING_FIX_DETAILS.md
================
# Dashboard Loading Fix

## Problem Diagnosis

The dashboard wasn't loading properly because of several interdependent issues:

1. **Error Propagation**: Errors in child components (TaskManager, StandupHistory) were causing the entire Dashboard to fail without proper fallbacks.

2. **Synchronous Loading Dependencies**: The Dashboard component was trying to load several components synchronously, causing a waterfall effect where one slow or failing component would block the entire dashboard.

3. **Lack of Error Boundaries**: While there was an ErrorBoundary at the app level, there weren't specific error boundaries for individual dashboard sections that could contain failures.

4. **React Suspense Issues**: Some components weren't properly wrapped in Suspense components, causing render failures when async data wasn't immediately available.

5. **Missing Fallback States**: When components failed to load or encountered errors, there weren't appropriate fallback UI states, resulting in blank screens instead of helpful user feedback.

## Solution Implemented

We implemented a comprehensive solution addressing all the identified issues:

1. **Component Isolation**: We wrapped each major dashboard component in its own ErrorBoundary to isolate failures.

2. **Lazy Loading with Suspense**: The TaskManager component is now lazy-loaded and wrapped in React.Suspense to prevent it from blocking other dashboard components.

3. **Better Error Recovery**: The ErrorBoundary component now attempts recovery after a timeout and provides more meaningful error messages when things go wrong.

4. **Cascading Fallbacks**: We've implemented a hierarchy of fallbacks:
   - Component-level fallbacks for individual sections
   - Page-level fallbacks for the entire dashboard
   - Global ErrorBoundary as a last resort

5. **Improved Loading States**: Added proper loading indicators for each section so users have visual feedback during the loading process.

6. **Enhanced Diagnostics**: The test-dashboard-load.js script now provides more detailed diagnostics, including:
   - Checking component visibility, not just existence
   - Detecting suspense fallbacks that might be stuck
   - Checking for empty containers that should have content
   - Retrying component detection several times with delays
   - Providing detailed error information

7. **App-Level Changes**: Updated the App.tsx file to wrap the Dashboard component in both an ErrorBoundary and a Suspense component at the route level for additional protection.

## Technical Implementation Details

### Dashboard Component Changes

1. Added React.lazy for the TaskManager component to prevent it from blocking other components
2. Wrapped each section in its own ErrorBoundary
3. Improved loading state indicators
4. Added more detailed error handling and logging

### Router-Level Changes

1. Added a dedicated ErrorBoundary in App.tsx for the dashboard route
2. Added proper Suspense fallback at the route level
3. Ensured routing doesn't get stuck during loading or error states

### Test Script Improvements

1. Added retry logic for component detection
2. Enhanced debugging and logging
3. Added visibility checks in addition to presence checks
4. Improved error diagnostics

## Verification

After implementing these changes, the dashboard now loads properly even when individual components encounter errors. You can verify this by using the browser console and running:

```javascript
const script = document.createElement('script');
script.src = '/scripts/test-dashboard-load.js';
document.body.appendChild(script);
```

The test script will check all components and report success if everything is loading correctly.

## Future Recommendations

To prevent similar issues in the future:

1. Always wrap asynchronous components in Suspense with appropriate fallbacks
2. Use ErrorBoundary components around key UI sections
3. Implement progressive loading strategies for complex pages
4. Add comprehensive test scripts for critical pages
5. Monitor for errors during page loading with improved logging

================
File: docs/DASHBOARD_LOADING_FIX.md
================
# Dashboard Loading Fix

The dashboard was failing to load properly due to several interdependent issues with component loading, error handling, and suspense fallback states.

## Fixes Implemented

1. Comprehensive error boundary implementation around all dashboard components
2. Proper React.Suspense usage for lazy-loaded components
3. Enhanced error recovery and fallback UI states
4. Improved loading indicators and user feedback
5. Better error isolation to prevent cascading failures

## How to Test the Fix

You can verify the dashboard is loading correctly by:

1. Running the application with `npm run dev`
2. Navigating to the dashboard page `/dashboard`
3. Running the test script by pasting this in the browser console:

```javascript
const script = document.createElement('script');
script.src = '/scripts/test-dashboard-load.js';
document.body.appendChild(script);
```

4. Check the console output - you should see "✅ SUCCESS: Dashboard loaded properly"

## Technical Details

For a complete technical explanation of the issues and fixes, see [DASHBOARD_LOADING_FIX_DETAILS.md](./DASHBOARD_LOADING_FIX_DETAILS.md)

================
File: docs/DISABLED_LOGGING_DOCUMENTATION.md
================
# Disabled Logging Services Documentation

## Overview

This document describes the changes made to disable logging services that were causing errors in the application. The goal was to maintain database functionality for most features while preventing errors related to logging, consent settings, and model training.

## Changes Made

### 1. Disabled Logging Service

The `logging.service.ts` has been modified to be a no-op service that:
- Maintains the same interface as the original service
- Logs to console instead of the database
- Returns mock data where needed
- Handles all method signatures required by the hooks

### 2. Disabled Privacy Service

The `privacy.service.ts` has been modified to be a no-op service that:
- Returns default consent settings
- Prevents 406 errors from consent_settings endpoints
- Logs operations to console only

### 3. Disabled Model Training Service

The `model-training.service.ts` has been modified to be a no-op service that:
- Prevents database errors from feature extraction
- Returns mock data for model evaluation
- Logs operations to console only

### 4. Enhanced Feature Flags Service

The `feature-flags.service.ts` has been modified to:
- Read from the database but not write to it
- Maintain in-memory state for feature flags
- Provide default values when database access fails

### 5. Enhanced Error Boundaries

The `ErrorBoundary.tsx` component has been enhanced with:
- More detailed error logging
- Performance tracking for recovery attempts
- Better error context information

### 6. Enhanced Dashboard Component

The `Dashboard.tsx` component has been enhanced with:
- More detailed console logging
- Better error handling for component loading
- Performance tracking for data loading operations
- Parallel data loading with Promise.allSettled

## How to Use

The application should now function normally with most database features working, but without logging to the database. The console will show detailed information about operations that would normally write to the database.

### Expected Console Output

You will see console messages like:
- `[LoggingService] Event (DISABLED): event_name`
- `[PrivacyService] getUserConsent called (DISABLED) for user: user_id`
- `[ModelTrainingService] No logs found for feature extraction`

### Testing

A test script has been created at `scripts/test-dashboard-load.js` to verify the changes, but it may require additional configuration to run properly in the project's environment.

## Reverting These Changes

To revert to full database logging in the future:
1. Restore the original implementations of the services
2. Ensure the database tables for logging, consent settings, and model training exist
3. Update the error handling in the Dashboard component if needed

## Troubleshooting

If you still see errors in the console:
1. Check if they are related to other services not covered by these changes
2. Verify that the browser is using the latest code (hard refresh may be needed)
3. Check the network tab for any remaining API calls that might be failing

================
File: docs/huggingface-integration.md
================
# Hugging Face LLM Microservice Integration

This document explains how the Wheel99 application integrates with the Hugging Face LLM microservice for AI capabilities.

## Overview

The Hugging Face LLM microservice provides an alternative to OpenAI for generating AI responses within the application. It offers:

1. **Multi-model support**:
   - Base Model for general requests
   - Company-specific Model fine-tuned with company data
   - Abstraction Model trained on business patterns

2. **Comprehensive logging** with the existing logging system
3. **UI controls** for enabling/disabling the service and specific models
4. **Seamless integration** with the existing application architecture

## Configuration

### Environment Variables

Add the following to your `.env` file:

```
# Hugging Face LLM Microservice URL
VITE_LLM_SERVICE_URL=http://localhost:3001/api

# Optional: Set these to true to enable by default
VITE_USE_HUGGINGFACE=false
VITE_USE_HF_COMPANY_MODEL=false
VITE_USE_HF_ABSTRACTION_MODEL=false
```

### Feature Flags

The following feature flags control the Hugging Face integration:

- `useHuggingFace`: Enables/disables the Hugging Face LLM microservice
- `useHFCompanyModel`: Uses the company-specific fine-tuned model
- `useHFAbstractionModel`: Uses the abstraction model trained on business patterns

These can be toggled in the Settings UI or programmatically:

```typescript
import { useAuthStore } from '../lib/store';

// Get the store and set feature flags
const { setFeatureFlags } = useAuthStore();

// Enable Hugging Face
setFeatureFlags({
  useHuggingFace: { enabled: true, visible: true }
});

// After changing providers, reset the service to apply changes
import { resetGeneralLLMService } from '../lib/services/general-llm.service';
resetGeneralLLMService();
```

## Architecture

### Client

The `huggingface-client.ts` file provides a client for the LLM microservice API:

```typescript
import huggingFaceClient from '../lib/huggingface-client';

// Generate text
const response = await huggingFaceClient.generate(
  'Generate a business idea for a tech startup',
  'base', // 'base', 'company', or 'abstraction'
  { companyId: 'company-123' }, // Optional context
  { temperature: 0.7 } // Optional parameters
);

console.log(response.generated_text);
```

### Service Implementation

The `huggingface-llm.service.ts` file implements the `GeneralLLMService` interface, making it compatible with the existing AI service layer:

```typescript
import { generalLLMService } from '../lib/services/general-llm.service';

// Use the service through the existing interface
const response = await generalLLMService.query(
  'Generate a business idea',
  {
    userId: 'user-123',
    companyId: 'company-456',
    useCompanyModel: true // Use the company-specific model
  }
);
```

### UI Component

The `LLMProviderSettings.tsx` component provides a user interface for toggling between OpenAI and Hugging Face, and selecting which specialized models to use.

## Starting the LLM Microservice

Before enabling the Hugging Face integration in the application, you need to start the LLM microservice:

1. Navigate to the LLM service directory
2. Run `npm start` to start the service
3. The service should be running at `http://localhost:3001`

## Troubleshooting

If you experience issues with the Hugging Face integration:

1. Check that the LLM microservice is running
2. Verify the `VITE_LLM_SERVICE_URL` environment variable is set correctly
3. Look for errors in the browser console
4. Check the server logs for the LLM microservice

## Using Multiple Models

The Hugging Face integration allows using different models for different scenarios:

- **Base Model**: Good for general questions and responses
- **Company Model**: Best for company-specific questions that require context about your business
- **Abstraction Model**: Useful for identifying business patterns and applying them to your specific scenario

You can select which model to use in the settings UI or by setting the appropriate context parameters when calling the service.

================
File: docs/JOURNEY_EXPERIENCE_REDESIGN.md
================
# Journey Experience Redesign

## Overview

This document outlines the redesigned journey experience for The Wheel platform. The journey section has been revamped to provide a more intuitive, user-friendly experience while maintaining all the powerful functionality that helps companies progress through their business journey.

## Design Goals

1. **Simplify the UX**: Create a cleaner, more straightforward interface that reduces cognitive load
2. **Enhance Discoverability**: Make it easier for users to find the right challenges and tools
3. **Improve Progress Tracking**: Provide clearer visual feedback on journey progress
4. **Focus on Action**: Design an interface that encourages completing challenges and moving forward
5. **Maintain Power**: Keep all functionality but present it in a more digestible way

## Key Improvements

### 1. Challenge-Based Journey Architecture

The journey experience has been refactored from a step-based to a challenge-based architecture. This focuses the user on actionable business challenges rather than abstract journey steps.

Benefits:
- More concrete goals for users to tackle
- Better alignment with business outcomes
- Clearer sense of progress and accomplishment

### 2. Three-View Navigation System

The redesign introduces a three-view navigation system for exploring the journey:

#### Overview View
- High-level progress summary across all phases
- Key metrics and completion percentages
- Quick links to in-progress challenges
- Phase-based progress visualization

#### Challenges View
- Filterable, searchable grid of business challenges
- Visual indicators for difficulty, status, and time investment
- Quick actions for starting, customizing, or marking challenges as irrelevant
- Clean, card-based interface for scanning options

#### Challenge Detail View
- Comprehensive view of a single business challenge
- Clear steps for completion
- Contextual tool recommendations
- Resource links and guidance

### 3. Improved Tool Selection

Tool selection has been greatly simplified:

- Tools are now presented in the context of specific challenges
- Personalized recommendations based on company profile and challenge context
- Clearer comparison of tool options
- Streamlined evaluation process

### 4. Visual Progress Indicators

The redesign implements consistent visual progress tracking:

- Progress bars for overall journey and individual phases
- Status badges for challenges (Not Started, In Progress, Completed, Skipped)
- Difficulty indicators to help prioritize work
- Time investment estimates for better planning

### 5. Customization Options

Users can now customize their journey more easily:

- Create custom challenges specific to their business needs
- Modify existing challenges to better fit their context
- Mark irrelevant challenges to declutter the interface
- Personalized recommendations based on previous choices

## Implementation Details

The redesign is implemented through several key components:

1. **ChallengeCard**: Displays individual business challenges with key metadata
2. **ChallengeList**: Renders a collection of challenges with filtering and searching
3. **PhaseProgress**: Visualizes progress through journey phases
4. **ChallengeEditor**: Allows creation and modification of challenges
5. **JourneyOverviewPage**: Provides a dashboard of overall journey progress
6. **JourneyChallengesPage**: Lists all available challenges with filtering options
7. **JourneyStepPage**: Displays detailed view of individual challenges

## Benefits for Different User Types

### For New Users
- Clearer starting point with recommended initial challenges
- Better onboarding into the journey concept
- Less overwhelming interface with progressive disclosure

### For Active Users
- Easier tracking of in-progress work
- Better context for decision-making
- Clearer next steps to maintain momentum

### For Advanced Users
- More customization options
- Better tool comparison for sophisticated decisions
- Ability to create tailored journey paths

## Future Enhancements

Potential future improvements to consider:

1. AI-powered challenge recommendations based on company profile
2. Drag-and-drop challenge prioritization
3. Challenge collections/pathways for specific business scenarios
4. Integration with calendar for scheduling challenge work
5. Social features to see how other similar companies tackled challenges

---

This redesign maintains all the powerful functionality of The Wheel's journey system while making it significantly more accessible and user-friendly through thoughtful information architecture, progressive disclosure, and consistent visual design.

================
File: docs/JOURNEY_REDESIGN_COMPONENTS_SUMMARY.md
================
# Journey Redesign Components Summary

This document provides a summary of all components created for the redesigned journey experience.

## Database Schema

### Tables
- `journey_phases`: Stores main journey phases
- `journey_challenges`: Stores business challenges (replacing steps)
- `company_challenge_progress`: Tracks company progress on challenges

### Migration Scripts
- `scripts/run-journey-transformation.js`: Migrates data from the old step-based system to the new challenge-based architecture

## Core Components

### Challenge Components

#### ChallengeCard
- **Purpose**: Display individual business challenges in a compact card format
- **Features**:
  - Status badge (Not Started, In Progress, Completed, Skipped)
  - Difficulty indicator (1-5 scale)
  - Estimated time display
  - Key outcomes preview
  - Action buttons (Start, Customize, Mark Irrelevant)
  
#### StatusBadge
- **Purpose**: Shows the current status of a challenge
- **Features**:
  - Color-coded badges for different statuses
  - Clear text labels
  - Compact design for embedding in cards

#### DifficultyIndicator
- **Purpose**: Visually indicates challenge difficulty
- **Features**:
  - 1-5 scale represented by dots
  - Color-coding (1=green to 5=red)
  - Tooltip with text description

#### EstimatedTime
- **Purpose**: Shows estimated time to complete a challenge
- **Features**:
  - Displays time range (min-max)
  - Appropriate time units (minutes, hours)
  - Clock icon for visual recognition

### Phase Components

#### PhaseProgress
- **Purpose**: Visualizes progress through a journey phase
- **Features**:
  - Progress bar showing completion percentage
  - Challenge count (completed/total)
  - Phase description
  - Clickable to filter challenges by phase

### List Components

#### ChallengeList
- **Purpose**: Displays collections of challenges
- **Features**:
  - Grid or list layout options
  - Filters and search capabilities
  - Empty state handling
  - Integration with progress data

### Editor Components

#### ChallengeEditor
- **Purpose**: Form for creating or editing challenges
- **Features**:
  - Form validation
  - Phase selection dropdown
  - Difficulty selector
  - Estimated time inputs
  - Key outcomes management (add/remove)

## Page Components

### JourneyOverviewPage
- **Purpose**: Dashboard view of journey progress
- **Features**:
  - Overall completion metrics
  - Phase-by-phase progress visualization
  - Quick action buttons for in-progress challenges
  - Recommendations for what to do next

### JourneyChallengesPage
- **Purpose**: Browse and filter all available challenges
- **Features**:
  - Search functionality
  - Phase filtering
  - Grid view of challenge cards
  - Create custom challenge button
  - Quick access to ongoing challenges

### JourneyStepPage (Enhanced)
- **Purpose**: Detailed view of a single challenge
- **Features**:
  - Step-by-step guidance
  - Tool recommendations
  - Progress tracking
  - Notes and collaboration
  - Related resources

## Service Layer

### JourneyChallengesService
- **Purpose**: Backend service for challenge operations
- **Methods**:
  - `getPhases()`: Get all journey phases
  - `getChallenges()`: Get all challenges
  - `getChallengesByPhase(phaseId)`: Get challenges for a specific phase
  - `getChallenge(challengeId)`: Get a single challenge by ID
  - `getCompanyProgress(companyId)`: Get progress for all challenges for a company
  - `updateChallengeStatus(companyId, challengeId, status, notes)`: Update status
  - `createChallenge(challenge)`: Create a new challenge
  - `updateChallenge(id, challenge)`: Update an existing challenge
  - `deleteChallenge(id)`: Delete a challenge

## Documentation

### User and Implementation Guides
- `docs/JOURNEY_EXPERIENCE_REDESIGN.md`: Overview of UX design principles
- `docs/JOURNEY_REDESIGN_IMPLEMENTATION_PLAN.md`: Technical implementation details
- `docs/THE_WHEEL_JOURNEY_USER_GUIDE.md`: End-user guide for the new experience

## Future Components (Planned)

### Advanced Features
- **AI Recommendations**: Smart challenge suggestions based on company profile
- **Challenge Collections**: Predefined groups of challenges for specific business scenarios
- **Calendar Integration**: Schedule challenge work in team calendars
- **Social Features**: See how similar companies tackled challenges
- **Export Functionality**: Generate progress reports in various formats

This component architecture provides a solid foundation for the challenge-based journey experience, with clear separation of concerns and reusable building blocks that can be extended as needed.

================
File: docs/JOURNEY_REDESIGN_IMPLEMENTATION_PLAN.md
================
# Journey Redesign Implementation Plan

## Overview

This document outlines the technical implementation plan for the redesigned journey experience in The Wheel platform. It provides a roadmap for developers to convert the existing step-based journey system to the new challenge-based architecture.

## Migration Strategy

The implementation will follow a phased approach to minimize disruption:

1. **Phase 1**: Database schema updates and data migration
2. **Phase 2**: Core UI component development
3. **Phase 3**: Page implementation and integration
4. **Phase 4**: Legacy route handling and compatibility layer
5. **Phase 5**: Testing and performance optimization

## Phase 1: Database Schema Updates

### Step 1: Create New Tables

```sql
-- Create journey_phases table
CREATE TABLE journey_phases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create journey_challenges table
CREATE TABLE journey_challenges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  phase_id UUID REFERENCES journey_phases(id) ON DELETE CASCADE,
  difficulty_level INTEGER NOT NULL CHECK (difficulty_level BETWEEN 1 AND 5),
  estimated_time_min INTEGER NOT NULL,
  estimated_time_max INTEGER NOT NULL,
  key_outcomes TEXT[] NOT NULL DEFAULT '{}',
  prerequisite_challenges UUID[] DEFAULT '{}',
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create company_challenge_progress table
CREATE TABLE company_challenge_progress (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
  challenge_id UUID REFERENCES journey_challenges(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('not_started', 'in_progress', 'completed', 'skipped')),
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(company_id, challenge_id)
);
```

### Step 2: Data Migration Scripts

Create scripts to:

1. Convert existing journey_steps to journey_phases
2. Convert journey_tasks to journey_challenges
3. Map company_progress data to company_challenge_progress
4. Update tool references to maintain connections

### Step 3: Schema Triggers and Functions

```sql
-- Function to update timestamps
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create timestamp triggers
CREATE TRIGGER update_journey_phases_timestamp
BEFORE UPDATE ON journey_phases
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_journey_challenges_timestamp
BEFORE UPDATE ON journey_challenges
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_company_challenge_progress_timestamp
BEFORE UPDATE ON company_challenge_progress
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
```

## Phase 2: Core UI Component Development

### Challenge Card Component

Create a card component to display individual business challenges:

```typescript
// ChallengeCard.tsx
import React from 'react';
import { JourneyChallenge, challenge_status } from '../../lib/types/journey-challenges.types';
import { DifficultyIndicator, StatusBadge, EstimatedTime } from './';

interface ChallengeCardProps {
  challenge: JourneyChallenge;
  status?: challenge_status;
  isSelected?: boolean;
  onClick?: () => void;
  onStartClick?: () => void;
  onCustomizeClick?: () => void;
  onMarkIrrelevantClick?: () => void;
}

// Implementation...
```

### Challenge List Component

Create a component to display and filter challenge collections:

```typescript
// ChallengeList.tsx
import React, { useState } from 'react';
import { ChallengeCard } from './ChallengeCard';
import { JourneyChallenge, CompanyChallengeProgress } from '../../lib/types/journey-challenges.types';

interface ChallengeListProps {
  challenges: JourneyChallenge[];
  progressData?: Record<string, CompanyChallengeProgress>;
  onChallengeClick?: (challenge: JourneyChallenge) => void;
  onStartClick?: (challenge: JourneyChallenge) => void;
  onCustomizeClick?: (challenge: JourneyChallenge) => void;
  onMarkIrrelevantClick?: (challenge: JourneyChallenge) => void;
}

// Implementation...
```

### Phase Progress Component

Create a component to visualize phase completion:

```typescript
// PhaseProgress.tsx
import React from 'react';

interface PhaseProgressProps {
  name: string;
  description: string;
  completedCount: number;
  totalCount: number;
  percentage: number;
  onClick: () => void;
}

// Implementation...
```

### Challenge Editor Component

Create a form component for creating/editing challenges:

```typescript
// ChallengeEditor.tsx
import React, { useState, useEffect } from 'react';
import { JourneyChallenge, JourneyPhase } from '../../lib/types/journey-challenges.types';
import { JourneyChallengesService } from '../../lib/services/journeyChallenges.service';

interface ChallengeEditorProps {
  initialChallenge?: JourneyChallenge;
  isEditing: boolean;
  onSubmit: (challenge: JourneyChallenge) => void;
  onCancel: () => void;
}

// Implementation...
```

## Phase 3: Page Implementation

### Journey Overview Page

```typescript
// JourneyOverviewPage.tsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { JourneyChallenge, JourneyPhase } from '../../lib/types/journey-challenges.types';
import { JourneyChallengesService } from '../../lib/services/journeyChallenges.service';
import { PhaseProgress } from '../../components/company/journey/PhaseProgress';

// Implementation...
```

### Challenges Page

```typescript
// JourneyChallengesPage.tsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { ChallengeList } from '../../components/company/journey/ChallengeList';
import { JourneyChallenge, JourneyPhase } from '../../lib/types/journey-challenges.types';
import { JourneyChallengesService } from '../../lib/services/journeyChallenges.service';

// Implementation...
```

### Challenge Detail Page (Enhanced JourneyStepPage)

```typescript
// JourneyStepPage.tsx (enhanced)
import React, { useState, useEffect } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import JourneyStepDetails from '../../components/company/journey/JourneyStepDetails';
import ChallengeEditor from '../../components/company/journey/ChallengeEditor/ChallengeEditor';
import { JourneyChallengesService } from '../../lib/services/journeyChallenges.service';

interface JourneyStepPageProps {
  mode?: 'view' | 'edit' | 'create';
}

// Implementation...
```

## Phase 4: Service Implementation

### Journey Challenges Service

```typescript
// journeyChallenges.service.ts
import { supabase } from '../supabase';
import { 
  JourneyChallenge, 
  JourneyPhase, 
  CompanyChallengeProgress, 
  challenge_status 
} from '../types/journey-challenges.types';

export class JourneyChallengesService {
  // Methods for CRUD operations on challenges, phases, and progress
  // ...
}
```

### Legacy Compatibility Layer

```typescript
// journeyCompatibility.service.ts
import { supabase } from '../supabase';
import { JourneyChallengesService } from './journeyChallenges.service';

export class JourneyCompatibilityService {
  // Methods to map between old and new data models
  // ...
}
```

## Phase 5: Route Updates

Update the main application routes to include the new journey pages:

```typescript
// App.tsx (route updates)
<Route path="company">
  // Existing routes
  
  // New journey routes
  <Route path="journey/overview" element={<JourneyOverviewPage />} />
  <Route path="journey/challenges" element={<JourneyChallengesPage />} />
  <Route path="journey/challenge/:challengeId" element={<JourneyStepPage />} />
  <Route path="journey/challenge/:challengeId/customize" element={<JourneyStepPage mode="edit" />} />
  <Route path="journey/challenges/create" element={<JourneyStepPage mode="create" />} />
  
  // Legacy route handling
  <Route path="journey" element={<JourneyMapPage />} />
  <Route path="journey/step/:stepId" element={<JourneyStepPage />} />
</Route>
```

## Phase 6: Testing and Optimization

### Testing Strategy

1. **Unit tests** for individual components
2. **Integration tests** for page components and service interactions
3. **Migration tests** to verify data integrity after schema updates
4. **End-to-end tests** for key user flows
5. **Performance tests** to ensure the new implementation maintains or improves response times

### Performance Optimization

1. Implement data caching for journey challenges and progress information
2. Use virtualization for challenge lists to improve rendering performance
3. Optimize database queries with proper indexing
4. Implement lazy loading for detailed challenge information

## Timeline

| Phase | Estimated Time | Dependencies |
|-------|----------------|--------------|
| Database Schema Updates | 1 week | None |
| Core UI Component Development | 2 weeks | Phase 1 |
| Page Implementation | 2 weeks | Phase 2 |
| Legacy Route Handling | 1 week | Phase 3 |
| Testing and Optimization | 2 weeks | Phase 4 |

Total estimated implementation time: **8 weeks**

## Migration Considerations

- Implement feature flags to enable gradual rollout
- Provide temporary dual navigation to both old and new interfaces
- Include comprehensive documentation for users transitioning to the new journey experience
- Create a feedback mechanism specifically for the redesign
- Monitor key metrics before and after launch to measure impact

## Conclusion

This implementation plan provides a systematic approach to transitioning from the existing journey system to the redesigned challenge-based architecture. By following these phases and considering the migration strategy, the development team can efficiently implement the new journey experience while minimizing disruption to existing users.

================
File: docs/JOURNEY_REDESIGN_SPRINT_PLAN.md
================
# Journey Redesign Sprint Plan

## Current Sprint: Sprint 1 (April 29 - May 12, 2025)

We are currently in **Sprint 1** of the Journey Experience Redesign implementation. This is the first of four planned two-week sprints to fully implement the redesigned challenge-based architecture.

## Overall Timeline

| Sprint | Dates | Focus | Status |
|--------|-------|-------|--------|
| Sprint 1 | Apr 29 - May 12 | Database Schema & Core Components | IN PROGRESS |
| Sprint 2 | May 13 - May 26 | Page Implementation & Service Layer | PLANNED |
| Sprint 3 | May 27 - Jun 9 | Integration & Legacy Support | PLANNED |
| Sprint 4 | Jun 10 - Jun 23 | Testing, Optimization & Launch | PLANNED |

## Sprint 1 Details (Current)

**Goal:** Establish foundation for the new challenge-based architecture

### Tasks Completed
- ✅ Created journey-challenges.types.ts with core data models
- ✅ Built StatusBadge component for challenge status visualization
- ✅ Developed ChallengeEditor component for creating/editing challenges
- ✅ Created PhaseProgress component for phase completion tracking
- ✅ Implemented JourneyChallengesService for core backend operations
- ✅ Developed migration script (run-journey-transformation.js)
- ✅ Created comprehensive documentation for the redesign

### Tasks In Progress
- 🔄 ChallengeCard component implementation
- 🔄 ChallengeList component development
- 🔄 Database migration script testing
- 🔄 EstimatedTime and DifficultyIndicator components

### Tasks Remaining
- ⬜ Set up initial database tables (journey_phases, journey_challenges, company_challenge_progress)
- ⬜ Create index export files for component directories
- ⬜ Unit tests for core components
- ⬜ Sprint 1 review and retrospective

## Sprint 2 Preview (May 13 - May 26)

**Goal:** Implement main page components and connect to backend services

### Key Deliverables
- JourneyOverviewPage implementation
- JourneyChallengesPage implementation
- Enhanced JourneyStepPage (challenge detail view)
- Search and filter functionality
- Phase-based navigation
- Initial integration with tool recommendation system

## Development Approach

We're following a component-first development approach:

1. Build and test individual UI components
2. Develop service layer functions
3. Implement page components that use these elements
4. Integrate with existing systems

This allows us to create a solid foundation of reusable components before assembling them into full pages.

## Current Focus

The team is currently focused on completing the remaining core UI components and preparing for the database migration that will convert existing journey steps to the new challenge-based format.

## Next Actions

1. Complete remaining Sprint 1 tasks
2. Finalize database migration script and test with sample data
3. Prepare for Sprint 2 planning (scheduled for May 12, 2025)
4. Review UI component designs with design team

## Blockers

None currently identified.

================
File: docs/JOURNEY_STEP_PAGE_IMPLEMENTATION.md
================
# Journey Step Page Implementation Documentation

## Overview
This document outlines the comprehensive plan for implementing a modern, dynamic, and context-aware journey step page. The page is designed to be visually appealing, responsive, and tailored to the company's current context and user interactions.

---

## Layout and Design Principles
- **Responsive Grid Layout**: Utilizes a full-width responsive grid (Tailwind CSS recommended) to ensure optimal use of screen real estate.
- **Main Content Area**: Occupies the majority of the viewport, displaying detailed step information, advice, tools, notes, and feedback.
- **Sticky Sidebar**: Provides quick access to key actions such as marking steps complete, skipping, focusing, tool selection, and expert assistance.
- **Modern Card Styling**: Cards feature rounded corners, subtle shadows, clear headers, and intuitive icons for enhanced readability and aesthetics.

---

## Dynamic and Contextual Content Rendering
- **Section Registry**: Maintains a registry of all possible sections (overview, description, guidance, tools, options, resources, checklists, tips, key considerations, milestones, skills, notes, feedback).
- **Conditional Rendering**: Sections are dynamically rendered based on data availability and relevance to the company's current phase, progress, and profile.
- **Dismissible Advice Cards**: Users can dismiss advice or sections, with the state persisted to ensure a personalized experience. Users can reset dismissed sections if needed.

---

## Actionable Sidebar
- **Sticky/Floating Sidebar**: Remains accessible as users scroll, providing persistent access to essential actions.
- **Key Actions**:
  - Mark Complete
  - Skip Step
  - Set as Focus Area
  - Track Manually
  - Tool Selection
  - Ask Expert / Ask Wheel (conditional)

---

## Tool Selection and Recommendations
- **Dedicated Tools Section**: Highlights recommended tools, with options to view all available tools or add custom tools.
- **Interactive Tool Actions**: Users can launch, compare, evaluate, or upload documents related to tools directly from the step page.

---

## Notes and Feedback Integration
- **Inline Editable Notes**: Supports autosave functionality and displays the last updated timestamp.
- **Feedback Section**: Allows users to submit ratings and comments, displaying aggregated feedback when available.

---

## Adaptive and Information-Rich Experience
- **Desktop View**: Multiple columns and expanded sections provide a dense, information-rich interface.
- **Mobile View**: Sections stack vertically for clarity and ease of use.
- **Adaptive Content**: Automatically adjusts layout to maintain visual balance, ensuring the page never appears collapsed or sparse.

---

## Personalization and Extensibility
- **Contextual Filtering**: Content visibility is tailored based on company context and user interactions.
- **Support for Custom Steps**: Gracefully handles user-added steps and custom fields, ensuring flexibility and extensibility.
- **Registry Pattern**: Facilitates easy addition and management of new section types.

---

## Implementation Flow
1. Fetch all relevant step and company context data.
2. Evaluate each section in the registry for data presence and relevance.
3. Render relevant sections as dismissible advice/info cards.
4. Provide persistent sidebar with key actions.
5. Ensure responsive and adaptive layout across devices.

---

## Visual Layout Diagram
```mermaid
flowchart TD
    subgraph MainGrid
      A[Step Overview] --- B[Advice/Info Cards]
      B --- C[Tools & Recommendations]
      C --- D[Notes & Feedback]
    end
    E[Sticky Sidebar/Action Bar] -.-> MainGrid
```

---

This documentation serves as a reference for the implementation and future maintenance of the journey step page, ensuring alignment with design principles and functional requirements.

================
File: docs/JOURNEY_STEPS_IMPLEMENTATION_STATUS.md
================
# Journey Steps Implementation Status

## Sprint 1 Completed Deliverables (May 1 - May 5, 2025)

We've successfully completed the initial phase of the Journey UX Improvement project, which focused on setting up the database foundation and creating the data mapping layer between steps and the enhanced UI.

### 1. Database Views & Functions
- ✅ Created `journey_steps_enhanced` view that adds UI-focused properties to steps
- ✅ Created `company_step_progress` view for better progress tracking
- ✅ Implemented `get_enhanced_step` function to fetch steps with tool associations
- ✅ Implemented `get_personalized_step_tools` function for personalized recommendations

These database objects serve as the foundation for our approach, allowing us to use the original steps data structure while taking advantage of the improved UI design.

### 2. Type Definitions
- ✅ Created comprehensive types in `journey-steps.types.ts`
- ✅ Added interfaces for enhanced steps, progress tracking, and tool references
- ✅ Implemented helper functions for step-challenge mapping
- ✅ Added filtering interfaces for better data retrieval

The type system provides a complete bridge between the steps data model and the UI components, ensuring type safety throughout the application.

### 3. Service Layer
- ✅ Implemented `journeySteps.service.ts` with full CRUD operations
- ✅ Added methods for progress tracking and calculations
- ✅ Created personalized recommendation functions
- ✅ Added backward compatibility methods for challenge-based code

This service layer abstracts the database access and provides a clean API for components to interact with steps data.

### 4. Testing
- ✅ Created comprehensive test script in `test-journey-steps-service.js`
- ✅ Tests verify database views and functions
- ✅ Tests validate service methods with real data
- ✅ Tests ensure compatibility with existing tool system

## What's Coming Next

### Sprint 2: Component Rebrand & Service Completion (May 6 - May 12, 2025)

1. **Core Component Renaming**
   - Rename `ChallengeCard` → `StepCard`
   - Rename `ChallengeList` → `StepList` 
   - Update StatusBadge, DifficultyIndicator, EstimatedTime components
   - Update component references and exports

2. **Page Component Updates**
   - Rename page components (`JourneyChallengesPage` → `JourneyStepsPage`)
   - Update JourneyOverviewPage to use step terminology
   - Update references in imports and exports

3. **Tool Integration Services**
   - Update tool selection service to work with steps
   - Modify personalized recommendation functions
   - Update tool comparison functionality
   - Test tool association with steps data

4. **Service Layer Completion**
   - Complete remaining service methods
   - Create comprehensive test coverage
   - Document API changes

## Getting Started with the New Implementation

To use the new step-based Journey system:

1. Run the database migration:
   ```bash
   cd supabase
   npx supabase db push migrations/20250501000000_create_step_enhanced_views.sql
   ```

2. Test the implementation:
   ```bash
   node scripts/test-journey-steps-service.js
   ```

3. Import the new service in components:
   ```typescript
   import journeyStepsService from "../lib/services/journeySteps.service";
   
   // Example usage
   const steps = await journeyStepsService.getEnhancedSteps();
   ```

## Backward Compatibility

If your code uses the old challenge-based model, you can use the backward compatibility methods:

```typescript
// Instead of:
import journeyChallengesService from "../lib/services/journeyChallenges.service";
const challenge = await journeyChallengesService.getChallengeById(id);

// Use:
import journeyStepsService from "../lib/services/journeySteps.service";
const challenge = await journeyStepsService.getChallengeById(id);
```

The returned data structure is compatible with existing challenge-based components, ensuring a smooth transition.

================
File: docs/JOURNEY_STEPS_UX_IMPROVEMENTS.md
================
# Journey Steps UI/UX Improvements

## Overview

This document outlines the improvements made to the Journey section of The Wheel application as part of Sprint 2. The redesign aims to simplify the user experience while maintaining all the powerful functionality of the journey feature.

## Problem Statement

The previous implementation of the journey map and associated pages was:
- Cluttered and visually busy
- Not user-friendly for startup founders
- Confusing in its navigation and information architecture
- Overwhelming with too many options presented simultaneously

## Solution Approach

The redesign followed these key principles:
1. **Simplicity First**: Create clean, focused interfaces that present only what's needed
2. **Progressive Disclosure**: Reveal additional complexity only when needed
3. **Consistent Patterns**: Use familiar UI patterns to reduce cognitive load
4. **Visual Hierarchy**: Prioritize information to guide user attention

## Key Components Developed

### Core Components

1. **StepCard**: A clean, focused card component for displaying journey steps
   - Includes StatusBadge, DifficultyIndicator, and EstimatedTime subcomponents
   - Supports compact and expanded views for different contexts
   - Clear visual indicators for progress and importance

2. **StepList**: An organized, filterable list of journey steps
   - Support for search, filters, and sorting
   - Empty state handling and responsive design
   - Clear section headings and intuitive grouping

3. **PhaseProgress**: Interactive component showing phase progress
   - Visual timeline of the startup journey
   - Progress indicators for each phase
   - Selection mechanism to filter steps by phase

4. **JourneyStepsPage**: Main page component integrating the components
   - Clear page structure and navigation
   - Contextual filtering and search
   - Status tracking and organization

### Supporting Functionality

1. **JourneyStepsRedirect**: Backward compatibility component
   - Ensures existing bookmarks and URLs continue to work
   - Seamless transition from the old "challenges" terminology

2. **Route updates**: Additional routes in App.tsx
   - New routes for the steps-based UI
   - Maintained legacy routes with redirects

## Implementation Details

### Component Structure

```
src/components/company/journey/
├── StepCard/
│   ├── StepCard.tsx          # Main card component
│   ├── StatusBadge.tsx       # Status indicator (not started, in progress, etc.)
│   ├── DifficultyIndicator.tsx # Visual difficulty level (1-5 dots)
│   ├── EstimatedTime.tsx     # Estimated time display (intelligent formatting)
│   └── index.ts              # Barrel export file
├── StepList/
│   ├── StepList.tsx          # List component with filtering
│   └── index.ts              # Barrel export file
└── PhaseProgress/
    ├── PhaseProgress.tsx     # Phase navigation and progress tracking
    └── index.ts              # Barrel export file
```

### Page Components

```
src/pages/company/
├── JourneyStepsPage.tsx      # Main page for steps view
└── JourneyStepsRedirect.tsx  # Redirect component for backward compatibility
```

### Visual Design

- Clean, minimal design with focus on content
- Clear hierarchy of information
- Consistent spacing and typography
- Actionable elements are clearly indicated
- Status and progress are visually emphasized

## Benefits of the New Design

1. **Improved Usability**
   - More intuitive navigation and interaction
   - Reduced cognitive load for users
   - Clear next steps and progression

2. **Better Organization**
   - Logical grouping of related steps
   - Progressive disclosure of details
   - Contextual filters and search

3. **Enhanced Visual Design**
   - Cleaner, more modern aesthetic
   - Consistent styling and patterns
   - Better use of whitespace and visual hierarchy

4. **Increased Efficiency**
   - Faster access to relevant information
   - Reduced clicks for common tasks
   - More scannable interface

## Future Improvements

- Consider adding keyboard navigation for power users
- Implement drag-and-drop for step reordering
- Add animation for transitions between views
- Implement user preference saving for filters and views
- Consider a "favorites" or "pinned" feature for frequently accessed steps

## Technical Debt Addressed

- Replaced inconsistent styling with a more systematic approach
- Added proper TypeScript typing for all components
- Improved component modularity and reusability
- Added comprehensive test coverage
- Enhanced accessibility with proper ARIA attributes and keyboard navigation

## Conclusion

The redesigned Journey Steps interface provides a more user-friendly, efficient, and visually appealing experience while maintaining all the functionality of the previous implementation. By focusing on simplicity, progressive disclosure, and consistent patterns, we've created a more intuitive and enjoyable user experience.

================
File: docs/JOURNEY_STEPS_UX_SPRINT_PLAN.md
================
# Journey UX Improvement Sprint Plan
## Rebranding "Challenges" to "Steps" While Keeping Enhanced UI

## Sprint 1: Foundation & Database (May 1 - May 5, 2025)

### Goal: 
Set up the database foundation and create the data mapping layer between steps and enhanced UI.

### Tasks:
1. **Database Views & Functions** (DBA, 2 days)
   - Create `journey_steps_enhanced` view 
   - Create `company_step_progress` view
   - Create mapping functions (`get_enhanced_step`, `get_personalized_step_tools`)
   - Test queries against existing data

2. **Type Definition Updates** (Frontend Dev, 1 day)
   - Create `journey-steps.types.ts` with enhanced fields
   - Update interfaces for `JourneyStep`, `CompanyStepProgress`
   - Define mapping types between step/challenge structures

3. **Initial Service Layer Updates** (Backend Dev, 2 days)
   - Create `journeySteps.service.ts` with enhanced methods
   - Update core query functions to use views/functions
   - Create unit tests for data mapping

### Deliverables:
- Working database views and mapping functions
- Type definitions that bridge step/challenge concepts
- Core service functions that access step data with enhanced fields
- Unit tests for database and service functions

### KPIs:
- 100% of existing step data accessible through new interfaces
- Query performance for enhanced views within 10% of direct table access
- All unit tests passing

---

## Sprint 2: Component Rebrand & Service Completion (May 6 - May 12, 2025)

### Goal:
Rename UI components to use "step" terminology while preserving enhanced functionality.

### Tasks:
1. **Core Component Renaming** (Frontend Dev A, 2 days)
   - Rename `ChallengeCard` → `StepCard`
   - Rename `ChallengeList` → `StepList` 
   - Update StatusBadge, DifficultyIndicator, EstimatedTime components
   - Update component references and exports

2. **Page Component Updates** (Frontend Dev B, 2 days)
   - Rename page components (`JourneyChallengesPage` → `JourneyStepsPage`)
   - Update JourneyOverviewPage to use step terminology
   - Update references in imports and exports

3. **Tool Integration Services** (Backend Dev, 3 days)
   - Update tool selection service to work with steps
   - Modify personalized recommendation functions
   - Update tool comparison functionality
   - Test tool association with steps data

4. **Service Layer Completion** (Backend Dev, 1 day)
   - Complete remaining service methods
   - Create comprehensive test coverage
   - Document API changes

### Deliverables:
- Renamed component files with preserved functionality
- Updated service layer for all tool operations
- Complete test suite for component and service functionality

### KPIs:
- All components successfully render with step data
- Tool recommendations work consistently with step IDs
- Code review confirms consistent terminology use
- Test coverage >90% for changed files

---

## Sprint 3: Navigation & UI Text (May 13 - May 19, 2025)

### Goal:
Update routes, navigation, and UI text throughout the application.

### Tasks:
1. **Route Updates** (Frontend Dev A, 1 day)
   - Update App.tsx routes to use step paths
   - Create redirect component for legacy URLs
   - Test all navigation paths

2. **UI Text Updates** (Frontend Dev B, 3 days)
   - Create script to find all "challenge" references
   - Update all UI text to reference "steps"
   - Review for proper grammatical forms and capitalization
   - Update button labels, headings, and tooltips

3. **System-wide Testing** (QA, 3 days)
   - Test all user flows with updated components
   - Verify data integrity throughout flows
   - Test tool integration features
   - Validate redirects from bookmarked URLs

4. **Initial Bug Fixes** (Dev Team, 1 day)
   - Address high-priority issues found in testing
   - Focus on data integrity and user flow issues

### Deliverables:
- Updated routes and navigation with redirects
- Consistent terminology throughout UI
- Test report with identified issues
- Fixed critical bugs

### KPIs:
- 0% references to "challenges" visible in UI
- 100% of old URLs successfully redirect
- All primary user flows complete successfully
- Critical bugs resolved

---

## Sprint 4: Documentation & Optimization (May 20 - May 26, 2025)

### Goal:
Update documentation, optimize performance, and finalize the transition.

### Tasks:
1. **Documentation Updates** (Technical Writer, 3 days)
   - Update user guide documentation
   - Update technical documentation
   - Create migration notes for internal teams
   - Update API documentation

2. **Performance Optimization** (Backend Dev, 2 days)
   - Profile database view performance
   - Optimize slow queries
   - Add caching where beneficial
   - Improve rendering performance for lists

3. **Final Bug Fixes & Polish** (Dev Team, 2 days)
   - Address all remaining issues from testing
   - Polish visual details and interactions
   - Conduct final accessibility review

4. **Launch Preparation** (Project Manager, 1 day)
   - Create release notes
   - Prepare announcement communications
   - Schedule gradual rollout
   - Create monitoring dashboard

### Deliverables:
- Updated user and technical documentation
- Performance improvements for high-impact areas
- Complete bug resolution
- Launch plan and communications

### KPIs:
- Documentation coverage for all changed features
- Page load times equivalent to or better than previous version
- Zero known bugs in production-ready build
- Comprehensive release plan

---

## Sprint 5: Launch & Feedback (May 27 - Jun 2, 2025)

### Goal:
Launch the updated interface, gather user feedback, and make rapid improvements.

### Tasks:
1. **Phased Rollout** (DevOps, 2 days)
   - Deploy to staging environment
   - Roll out to 10% of users
   - Monitor for issues
   - Expand to full deployment

2. **User Feedback Collection** (UX Research, 3 days)
   - Set up feedback mechanisms
   - Conduct user interviews
   - Analyze usage analytics
   - Compile feedback report

3. **Quick Wins Implementation** (Dev Team, 2 days)
   - Implement high-impact, low-effort improvements
   - Address any launch issues
   - Fine-tune based on initial feedback

4. **Success Measurement** (Product Manager, 1 day)
   - Compare metrics to pre-launch baseline
   - Document improvements in key metrics
   - Prepare success report for stakeholders

### Deliverables:
- Successfully deployed system
- User feedback report
- Quick win improvements
- Success metrics report

### KPIs:
- Successful deployment to 100% of users
- User satisfaction ratings equal or higher than previous interface
- Engagement metrics for journey section improved by 15%
- Tool selection rate increased by 10%

---

## Resources Required

### Team Composition:
- 2× Frontend Developers
- 2× Backend Developers
- 1× Database Administrator
- 1× QA Engineer
- 1× Technical Writer
- 1× UX Researcher
- 1× Project Manager

### Tools:
- Version control system
- CI/CD pipeline for testing and deployment
- Database management tools
- Performance profiling tools
- A/B testing framework
- Feedback collection system

### Dependencies:
- Access to production data (anonymized) for testing
- Testing environments that mirror production
- Sign-off from security and compliance teams
- Stakeholder availability for reviews

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Data mapping issues | Medium | High | Thorough testing with production-like data, implement data validation |
| Performance degradation | Medium | Medium | Performance benchmarking at each sprint, optimize critical paths |
| Terminology inconsistencies | High | Low | Automated scanning for terms, multiple review passes |
| User confusion | Medium | Medium | Clear communication about changes, tooltips explaining new layouts |
| Legal/compliance issues | Low | High | Early review by legal team, maintain data integrity |

---

## Success Criteria

1. **User Experience**:
   - Users report the interface is more intuitive and easier to use
   - Tool discovery and selection metrics improve
   - Task completion rates increase

2. **Technical**:
   - All functionality works with step data
   - No data loss during transition
   - Performance metrics meet or exceed previous version

3. **Business**:
   - Reduction in support tickets related to journey section
   - Increased engagement with tool recommendations
   - Faster progression through journey steps

---

This plan provides a structured approach to rebranding "challenges" back to "steps" while preserving all the UX improvements from the redesign. By organizing the work into focused sprints with clear goals and deliverables, we ensure a smooth transition that maintains data integrity while improving the user experience.

================
File: docs/JOURNEY_SYSTEM_MIGRATION_GUIDE.md
================
# Journey System: Migration Guide

**Date:** May 3, 2025  
**Version:** 1.0

This guide helps developers migrate from the existing challenges/steps dual system to the new unified journey system.

## Overview

The Journey System has been redesigned to consolidate the previously separate "steps" and "challenges" concepts into a single cohesive model. This guide will help you transition your code to use the new unified system.

## Migration Timeline

| Phase | Date | Description |
|-------|------|-------------|
| Phase 1 | May 2025 | Compatibility layer available |
| Phase 2 | June 2025 | UI components migrated |
| Phase 3 | July 2025 | Old system deprecated (warnings begin) |
| Phase 4 | August 2025 | Old system removed |

## Key Changes

### Database Tables & Views

**Old System:**
```
journey_challenges
company_challenge_progress
challenge_tool_recommendations
```

**New System:**
```
journey_steps
company_journey_steps  
step_tools
company_step_tools
```

**Compatibility Views:**
```
company_challenge_progress_view → maps to company_journey_steps
challenge_tool_recommendations_view → maps to step_tools
```

### Service Changes

**Old Services:**
```typescript
import { JourneyChallengesService } from '../lib/services/journeyChallenges.service';
import { CompanyJourneyService } from '../lib/services/companyJourney.service';
```

**New Unified Service:**
```typescript
import { JourneyUnifiedService } from '../lib/services/journey-unified.service';
```

## Migration Steps

### Step 1: Update Imports

Replace:
```typescript
import { JourneyChallenge } from '../lib/types/journey-challenges.types';
import { CompanyChallengeProgress } from '../lib/types/journey-challenges.types';
```

With:
```typescript
import { JourneyChallenge, CompanyChallengeProgress } from '../lib/types/journey-unified.types';
```

### Step 2: Replace Service Calls

**Old Way:**
```typescript
const challenges = await JourneyChallengesService.getChallenges();
const progress = await CompanyJourneyService.getChallengeProgress(companyId, challengeId);
```

**New Way:**
```typescript 
const challenges = await JourneyUnifiedService.getSteps();
const progress = await JourneyUnifiedService.getStepProgress(companyId, challengeId);
```

### Step 3: Update Tool-Related Code

**Old Way:**
```typescript
const tools = await JourneyChallengesService.getToolsForChallenge(challengeId);
const evaluation = await CompanyJourneyService.evaluateTool(companyId, challengeId, toolId, rating);
```

**New Way:**
```typescript
const tools = await JourneyUnifiedService.getToolsForStep(challengeId);
const evaluation = await JourneyUnifiedService.updateToolEvaluation(companyId, challengeId, toolId, { rating });
```

## API Mapping

| Old API | New API | Notes |
|---------|---------|-------|
| `getChallenges()` | `getSteps()` | Direct replacement |
| `getChallengeById(id)` | `getStepById(id)` | Direct replacement |
| `getChallengeProgress(companyId, challengeId)` | `getStepProgress(companyId, stepId)` | Direct replacement |
| `updateChallengeProgress(companyId, challengeId, data)` | `updateStepProgress(companyId, stepId, data)` | Status values remain the same |
| `getToolsForChallenge(challengeId)` | `getToolsForStep(stepId)` | Direct replacement |
| `evaluateTool(companyId, challengeId, toolId, rating)` | `updateToolEvaluation(companyId, stepId, toolId, { rating })` | New version accepts an options object |

## TypeScript Types

### Type Aliases

The new system provides type aliases for backward compatibility:

```typescript
// In journey-unified.types.ts
export type JourneyChallenge = JourneyStep;
export type CompanyChallengeProgress = CompanyJourneyStep;
```

This means existing code that expects `JourneyChallenge` types will continue to work.

### Updated Interfaces

New interfaces have more comprehensive properties:

```typescript
export interface JourneyStep {
  id: string;
  name: string;
  description: string;
  phase_id: string;
  difficulty_level: number;
  estimated_time_min: number;
  estimated_time_max: number;
  key_outcomes: string[];
  prerequisite_steps: string[];
  order_index: number;
  created_at: string;
  updated_at: string;
}
```

## Common Migration Patterns

### Pattern 1: Challenge Lists

**Before:**
```tsx
function ChallengeList() {
  const [challenges, setChallenges] = useState<JourneyChallenge[]>([]);
  
  useEffect(() => {
    async function loadChallenges() {
      const data = await JourneyChallengesService.getChallenges();
      setChallenges(data);
    }
    loadChallenges();
  }, []);
  
  return (
    <div>
      {challenges.map(challenge => (
        <ChallengeCard key={challenge.id} challenge={challenge} />
      ))}
    </div>
  );
}
```

**After:**
```tsx
function ChallengeList() {
  const [challenges, setChallenges] = useState<JourneyChallenge[]>([]);
  
  useEffect(() => {
    async function loadChallenges() {
      const data = await JourneyUnifiedService.getSteps();
      setChallenges(data);
    }
    loadChallenges();
  }, []);
  
  return (
    <div>
      {challenges.map(challenge => (
        <ChallengeCard key={challenge.id} challenge={challenge} />
      ))}
    </div>
  );
}
```

### Pattern 2: Tool Selection

**Before:**
```tsx
function ToolSelector({ challengeId }) {
  const [tools, setTools] = useState([]);
  
  useEffect(() => {
    async function loadTools() {
      const data = await JourneyChallengesService.getToolsForChallenge(challengeId);
      setTools(data);
    }
    loadTools();
  }, [challengeId]);
  
  // Rest of component
}
```

**After:**
```tsx
function ToolSelector({ challengeId }) {
  const [tools, setTools] = useState([]);
  
  useEffect(() => {
    async function loadTools() {
      const data = await JourneyUnifiedService.getToolsForStep(challengeId);
      setTools(data);
    }
    loadTools();
  }, [challengeId]);
  
  // Rest of component remains the same
}
```

## Testing Your Migration

1. Begin by using the new service alongside the old one
2. Compare results to ensure data matches
3. Test with a small component first
4. Gradually migrate larger parts of the UI
5. Verify all functionality in the test environment

## Troubleshooting

### Common Issues

1. **Type Errors**: If you see TypeScript errors, check if you're using properties that have been renamed in the new schema
   - Solution: Review the type definitions in `journey-unified.types.ts`

2. **Missing Data**: If data appears to be missing after migration
   - Solution: Verify you're not accessing renamed properties or using filters that no longer apply

3. **Performance Issues**: If you notice slower performance after migration
   - Solution: Check that you're using the appropriate indexes and not doing unnecessary joins

### Support

For assistance with migration, please contact:
- #journey-migration-support channel in Slack
- Email journey-support@thewheel.com
- Create a ticket in the migration project board

================
File: docs/JOURNEY_SYSTEM_REDESIGN_STATUS.md
================
# Journey System Redesign: Current Status

**Date:** May 3, 2025  
**Status:** Sprint 1 - Week 1 Complete

## Overview

We are in the process of unifying our journey system to consolidate the previously separate "steps" and "challenges" concepts into a single cohesive model. This document provides a snapshot of the current status and next steps based on the JOURNEY_SYSTEM_UNIFIED_REDESIGN and JOURNEY_SYSTEM_SPRINT1_DATA_FOUNDATION documents.

## What We've Accomplished

### Week 1 (Completed)

1. **Database Schema**
   - Created unified tables (`journey_steps`, `company_journey_steps`, `step_tools`, `company_step_tools`)
   - Implemented migration scripts to preserve existing data
   - Built adaptive compatibility layer for different environments

2. **Core Service Layer**
   - Implemented `JourneyUnifiedService` with core functionality
   - Created comprehensive unit tests
   - Added tool-related methods and tests

3. **Compatibility Layer**
   - Created dynamic compatibility views to adapt to schema variations
   - Implemented RPC functions for advanced operations
   - Built fallback mechanisms for greater resilience

## Current Challenges

1. **Schema Variations**
   - Different environments have varying column names and structures
   - Solution: Implemented dynamic SQL view generation that adapts at runtime

2. **Company ID Handling**
   - Some tables use `company_id` while others might have different identifiers
   - Solution: Compatibility view handles this by detecting and mapping columns appropriately

3. **Tool Association Migration**
   - Complex relationships between tools, steps, and companies
   - Solution: Multi-stage migration with validation at each step

## What's Next for Week 2

### Monday-Tuesday
- Complete remaining service methods
- Implement React hooks for common operations
- Add comprehensive error handling

### Wednesday
- Complete unified testing framework
- Finalize compatibility layer testing
- Address any issues found during testing

### Thursday-Friday
- Create documentation for developers
- Begin UI component updates
- Plan for Sprint 2 (UI migration)

## Key Insights

1. The adaptive compatibility approach provides more stability across environments than a static approach would have.

2. The mock-based testing strategy is working well, allowing us to test service logic independently from database specifics.

3. The dynamic SQL approach to compatibility views has proven very useful for accommodating database variations.

## Recommendation

Based on our progress, we should:

1. Continue with the unified approach as planned
2. Add more diagnostic logging to the compatibility layer
3. Emphasize documentation for developers during Week 2
4. Begin planning for UI component migration in Sprint 2

## Success Criteria for Sprint 1

| Criteria | Status | Notes |
|----------|--------|-------|
| Unified data model | ✅ Complete | Implemented in schema migrations |
| Service layer | 🔶 In Progress | Core methods complete, some advanced methods pending |
| Compatibility layer | ✅ Complete | Dynamic views and functions implemented |
| Unit tests | 🔶 In Progress | Base tests complete, some advanced tests pending |
| Documentation | 🔶 In Progress | Migration guide created, API docs pending |

## Important Files and Components

1. **Service Layer**
   - `src/lib/services/journey-unified.service.ts` - Main service for the unified system
   - `src/tests/journey-unified.service.test.ts` - Unit tests for core functionality
   - `src/tests/journey-unified-tools.test.ts` - Tool-specific unit tests

2. **Database Migration**
   - `supabase/migrations/20250505000000_journey_system_unification.sql` - Core schema migration
   - `supabase/migrations/20250505040000_add_compatibility_layer.sql` - Compatibility views and functions

3. **Documentation**
   - `docs/JOURNEY_SYSTEM_MIGRATION_GUIDE.md` - Guide for developers to migrate their code
   - `docs/JOURNEY_SYSTEM_SPRINT1_SUMMARY.md` - Overall Sprint 1 progress summary

4. **Scripts**
   - `scripts/test-journey-migration.js` - Test script to verify migration success
   - `scripts/migrate-journey-data.cjs` - Data migration utility
   - `scripts/migrate-tools-final.cjs` - Tool association migration

## Conclusion

Sprint 1 Week 1 has successfully established the foundation for the unified journey system. The adaptive approach to compatibility addresses the variation in our database schema effectively. Week 2 should focus on completing the service layer and preparing for UI migration in Sprint 2.

With the compatibility layer in place, we can continue the migration without disrupting existing functionality. The dynamic nature of our compatibility views provides resilience against schema variations, which will be valuable as we transition.

================
File: docs/JOURNEY_SYSTEM_SPRINT1_DATA_FOUNDATION.md
================
# The Wheel: Journey System Redesign
## Sprint 1: Data Foundation

**Date Range:** May 5 - May 16, 2025  
**Status:** Planning  
**Sprint Lead:** TBD  

## Overview

Sprint 1 focuses on establishing a solid data foundation for the Journey System redesign by consolidating the current parallel implementations (steps and challenges) into a unified, flexible data model. This is the critical first step that will enable all subsequent UI improvements and feature enhancements.

## Objectives

1. Create a unified data schema that preserves all existing functionality
2. Develop migration scripts to safely transition existing data
3. Implement a consistent service layer API
4. Ensure backward compatibility for existing code
5. Establish comprehensive test coverage for data operations

## Deliverables

### 1. Unified Schema Design

```sql
-- Core schema updates

-- 1. journey_phases (enhance existing table)
ALTER TABLE journey_phases
ADD COLUMN color VARCHAR(20) NULL,
ADD COLUMN updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW();

-- 2. Update journey_steps with enhanced fields (combines step/challenge functionality)
ALTER TABLE journey_steps
ADD COLUMN difficulty_level INTEGER NOT NULL DEFAULT 3 CHECK (difficulty_level BETWEEN 1 AND 5),
ADD COLUMN estimated_time_min INTEGER NOT NULL DEFAULT 30,
ADD COLUMN estimated_time_max INTEGER NOT NULL DEFAULT 60,
ADD COLUMN key_outcomes TEXT[] NULL DEFAULT '{}',
ADD COLUMN prerequisite_steps UUID[] NULL DEFAULT '{}',
ADD COLUMN is_custom BOOLEAN NOT NULL DEFAULT FALSE;

-- 3. Create or update company_journey_steps to track company-specific progress/customization
CREATE TABLE IF NOT EXISTS company_journey_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  status VARCHAR(20) NOT NULL CHECK (status IN ('not_started', 'in_progress', 'completed', 'skipped')),
  notes TEXT NULL,
  custom_difficulty INTEGER NULL CHECK (custom_difficulty BETWEEN 1 AND 5),
  custom_time_estimate INTEGER NULL,
  completion_percentage INTEGER NULL CHECK (completion_percentage BETWEEN 0 AND 100),
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ NULL,
  UNIQUE(company_id, step_id)
);

-- 4. Create or update step_tools mapping
CREATE TABLE IF NOT EXISTS step_tools (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  relevance_score DECIMAL(3,2) NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(step_id, tool_id)
);

-- 5. Create or update company_step_tools for company-specific tool selections
CREATE TABLE IF NOT EXISTS company_step_tools (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  is_custom BOOLEAN NOT NULL DEFAULT FALSE,
  rating INTEGER NULL CHECK (rating BETWEEN 1 AND 5),
  notes TEXT NULL,
  selected_at TIMESTAMPTZ NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(company_id, step_id, tool_id)
);

-- Triggers for updating timestamps
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_journey_phases_timestamp
BEFORE UPDATE ON journey_phases
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_journey_steps_timestamp
BEFORE UPDATE ON journey_steps
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_company_journey_steps_timestamp
BEFORE UPDATE ON company_journey_steps
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_company_step_tools_timestamp
BEFORE UPDATE ON company_step_tools
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
```

### 2. Migration Scripts

```typescript
// migration-script.ts - Executable script to perform the data migration

import { supabase } from '../lib/supabase';

async function migrateJourneyData() {
  console.log('Starting journey data migration...');
  
  // 1. Migrate challenges to steps format
  console.log('Migrating challenges to steps...');
  const { data: challenges, error: challengesError } = await supabase
    .from('journey_challenges')
    .select('*');
    
  if (challengesError) {
    console.error('Error fetching challenges:', challengesError);
    return;
  }
  
  for (const challenge of challenges) {
    // Check if a corresponding step already exists
    const { data: existingStep } = await supabase
      .from('journey_steps')
      .select('id')
      .eq('id', challenge.id)
      .single();
      
    if (existingStep) {
      // Update existing step with challenge data
      const { error: updateError } = await supabase
        .from('journey_steps')
        .update({
          difficulty_level: challenge.difficulty_level,
          estimated_time_min: challenge.estimated_time_min,
          estimated_time_max: challenge.estimated_time_max,
          key_outcomes: challenge.key_outcomes,
          prerequisite_steps: challenge.prerequisite_challenges,
          is_custom: challenge.is_custom || false
        })
        .eq('id', challenge.id);
        
      if (updateError) {
        console.error(`Error updating step ${challenge.id}:`, updateError);
      }
    } else {
      // Insert new step from challenge
      const { error: insertError } = await supabase
        .from('journey_steps')
        .insert({
          id: challenge.id, // Preserve the ID
          name: challenge.name,
          description: challenge.description,
          phase_id: challenge.phase_id,
          order_index: challenge.order_index,
          difficulty_level: challenge.difficulty_level,
          estimated_time_min: challenge.estimated_time_min,
          estimated_time_max: challenge.estimated_time_max,
          key_outcomes: challenge.key_outcomes,
          prerequisite_steps: challenge.prerequisite_challenges,
          is_custom: challenge.is_custom || false
        });
        
      if (insertError) {
        console.error(`Error inserting step from challenge ${challenge.id}:`, insertError);
      }
    }
  }
  
  // 2. Migrate company challenge progress
  console.log('Migrating company challenge progress...');
  const { data: challengeProgress, error: progressError } = await supabase
    .from('company_challenge_progress')
    .select('*');
    
  if (progressError) {
    console.error('Error fetching challenge progress:', progressError);
    return;
  }
  
  for (const progress of challengeProgress) {
    // Check if a corresponding company_journey_step record exists
    const { data: existingProgress } = await supabase
      .from('company_journey_steps')
      .select('id')
      .eq('company_id', progress.company_id)
      .eq('step_id', progress.challenge_id)
      .single();
      
    if (existingProgress) {
      // Update existing progress
      const { error: updateError } = await supabase
        .from('company_journey_steps')
        .update({
          status: progress.status,
          notes: progress.notes,
          completion_percentage: progress.status === 'completed' ? 100 : 
                                 progress.status === 'not_started' ? 0 : 
                                 progress.completion_percentage || 50,
          completed_at: progress.completed_at
        })
        .eq('id', existingProgress.id);
        
      if (updateError) {
        console.error(`Error updating progress ${existingProgress.id}:`, updateError);
      }
    } else {
      // Insert new progress record
      const { error: insertError } = await supabase
        .from('company_journey_steps')
        .insert({
          company_id: progress.company_id,
          step_id: progress.challenge_id,
          status: progress.status,
          notes: progress.notes,
          completion_percentage: progress.status === 'completed' ? 100 : 
                                progress.status === 'not_started' ? 0 : 
                                progress.completion_percentage || 50,
          order_index: progress.order_index || 0,
          completed_at: progress.completed_at
        });
        
      if (insertError) {
        console.error(`Error inserting progress for company ${progress.company_id}, step ${progress.challenge_id}:`, insertError);
      }
    }
  }
  
  // 3. Migrate tool associations
  console.log('Migrating tool associations...');
  // (Similar pattern for tools)
  
  console.log('Migration complete!');
}

// Execute the migration
migrateJourneyData().catch(console.error);
```

### 3. Compatibility Views

```sql
-- Create views for backward compatibility

-- View for journey_steps in challenge format
CREATE OR REPLACE VIEW journey_challenges_view AS
SELECT
  js.id,
  js.name,
  js.description,
  js.phase_id,
  js.difficulty_level,
  js.estimated_time_min,
  js.estimated_time_max,
  js.key_outcomes,
  js.prerequisite_steps AS prerequisite_challenges,
  js.order_index,
  js.created_at,
  js.updated_at,
  js.is_custom
FROM
  journey_steps js;

-- View for company progress in challenge format
CREATE OR REPLACE VIEW company_challenge_progress_view AS
SELECT
  cjs.id,
  cjs.company_id,
  cjs.step_id AS challenge_id,
  cjs.status,
  cjs.notes,
  cjs.completion_percentage,
  cjs.order_index,
  cjs.created_at,
  cjs.updated_at,
  cjs.completed_at
FROM
  company_journey_steps cjs;
```

### 4. TypeScript Type Definitions

```typescript
// Updated type definitions in journey.types.ts

export type step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped';
export type difficulty_level = 1 | 2 | 3 | 4 | 5;

// Unified data models
export interface JourneyPhase {
  id: string;
  name: string;
  description?: string;
  order_index: number;
  color?: string;
  created_at: string;
  updated_at: string;
}

export interface JourneyStep {
  id: string;
  name: string;
  description?: string;
  phase_id: string;
  difficulty_level: difficulty_level;
  estimated_time_min: number;
  estimated_time_max: number;
  key_outcomes?: string[];
  prerequisite_steps?: string[];
  order_index: number;
  created_at: string;
  updated_at: string;
  is_custom?: boolean;
}

export interface CompanyJourneyStep {
  id: string;
  company_id: string;
  step_id: string;
  status: step_status;
  notes?: string;
  custom_difficulty?: number;
  custom_time_estimate?: number;
  completion_percentage?: number;
  order_index: number;
  created_at: string;
  updated_at: string;
  completed_at?: string;
}

export interface Tool {
  id: string;
  name: string;
  description?: string;
  url?: string;
  logo_url?: string;
  type: string;
  category?: string;
  pricing_model?: string;
  is_premium: boolean;
}

export interface StepTool {
  id: string;
  step_id: string;
  tool_id: string;
  relevance_score: number;
  created_at: string;
}

export interface CompanyStepTool {
  id: string;
  company_id: string;
  step_id: string;
  tool_id: string;
  is_custom: boolean;
  rating?: number;
  notes?: string;
  selected_at?: string;
  created_at: string;
  updated_at: string;
}

// Legacy type aliases for backward compatibility
export type JourneyChallenge = JourneyStep;
export type CompanyChallengeProgress = CompanyJourneyStep;
```

### 5. Core Service Layer

```typescript
// src/lib/services/journeySteps.service.ts

import { supabase } from '../supabase';
import { 
  JourneyPhase,
  JourneyStep,
  CompanyJourneyStep,
  step_status
} from '../types/journey.types';

export class JourneyStepsService {
  /**
   * Get all journey phases
   */
  static async getPhases(): Promise<JourneyPhase[]> {
    const { data, error } = await supabase
      .from('journey_phases')
      .select('*')
      .order('order_index');
      
    if (error) {
      console.error('Error fetching phases:', error);
      return [];
    }
    
    return data || [];
  }
  
  /**
   * Get steps, optionally filtered by phase
   */
  static async getSteps(options?: {
    phaseId?: string;
    includeCustom?: boolean;
  }): Promise<JourneyStep[]> {
    let query = supabase
      .from('journey_steps')
      .select('*')
      .order('order_index');
      
    if (options?.phaseId) {
      query = query.eq('phase_id', options.phaseId);
    }
    
    if (options?.includeCustom === false) {
      query = query.eq('is_custom', false);
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error('Error fetching steps:', error);
      return [];
    }
    
    return data || [];
  }
  
  /**
   * Get a single step by ID
   */
  static async getStep(stepId: string): Promise<JourneyStep | null> {
    const { data, error } = await supabase
      .from('journey_steps')
      .select('*')
      .eq('id', stepId)
      .single();
      
    if (error) {
      console.error(`Error fetching step ${stepId}:`, error);
      return null;
    }
    
    return data;
  }
  
  /**
   * Get company's progress on steps
   */
  static async getCompanyProgress(
    companyId: string,
    options?: {
      stepId?: string;
      status?: step_status | step_status[];
    }
  ): Promise<CompanyJourneyStep[]> {
    let query = supabase
      .from('company_journey_steps')
      .select('*')
      .eq('company_id', companyId)
      .order('order_index');
      
    if (options?.stepId) {
      query = query.eq('step_id', options.stepId);
    }
    
    if (options?.status) {
      if (Array.isArray(options.status)) {
        query = query.in('status', options.status);
      } else {
        query = query.eq('status', options.status);
      }
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error(`Error fetching company progress for ${companyId}:`, error);
      return [];
    }
    
    return data || [];
  }
  
  /**
   * Update company's progress on a step
   */
  static async updateStepProgress(
    companyId: string,
    stepId: string,
    updates: {
      status?: step_status;
      notes?: string;
      completion_percentage?: number;
      custom_difficulty?: number;
      custom_time_estimate?: number;
    }
  ): Promise<boolean> {
    // If status is being set to completed, add completed_at timestamp
    const updateData = { ...updates };
    if (updates.status === 'completed') {
      updateData.completed_at = new Date().toISOString();
    }
    
    // Check if record exists
    const { data: existing } = await supabase
      .from('company_journey_steps')
      .select('id')
      .eq('company_id', companyId)
      .eq('step_id', stepId)
      .single();
      
    let error;
    
    if (existing) {
      // Update existing record
      const result = await supabase
        .from('company_journey_steps')
        .update(updateData)
        .eq('company_id', companyId)
        .eq('step_id', stepId);
        
      error = result.error;
    } else {
      // Get maximum order_index
      const { data: maxOrderResult } = await supabase
        .from('company_journey_steps')
        .select('order_index')
        .eq('company_id', companyId)
        .order('order_index', { ascending: false })
        .limit(1)
        .single();
        
      const nextOrder = (maxOrderResult?.order_index || 0) + 10;
      
      // Insert new record
      const result = await supabase
        .from('company_journey_steps')
        .insert({
          company_id: companyId,
          step_id: stepId,
          ...updateData,
          order_index: nextOrder
        });
        
      error = result.error;
    }
    
    if (error) {
      console.error(`Error updating progress for company ${companyId}, step ${stepId}:`, error);
      return false;
    }
    
    return true;
  }
  
  /**
   * Reorder company's steps
   */
  static async reorderCompanySteps(
    companyId: string,
    stepOrders: { stepId: string; order: number }[]
  ): Promise<boolean> {
    // Start a transaction
    const { error } = await supabase.rpc('begin_transaction');
    if (error) {
      console.error('Failed to begin transaction:', error);
      return false;
    }
    
    try {
      // Update each step order
      for (const { stepId, order } of stepOrders) {
        const { error } = await supabase
          .from('company_journey_steps')
          .update({ order_index: order })
          .eq('company_id', companyId)
          .eq('step_id', stepId);
          
        if (error) throw error;
      }
      
      // Commit transaction
      await supabase.rpc('commit_transaction');
      return true;
    } catch (error) {
      console.error('Error reordering steps:', error);
      // Rollback transaction
      await supabase.rpc('rollback_transaction');
      return false;
    }
  }
}
```

## Testing Plan

### 1. Unit Tests

Create unit tests for all core service functions:

```typescript
// src/tests/journeySteps.service.test.ts

import { JourneyStepsService } from '../lib/services/journeySteps.service';
import { mockSupabase } from './mocks/supabase.mock';

// Mock Supabase
jest.mock('../lib/supabase', () => mockSupabase);

describe('JourneyStepsService', () => {
  beforeEach(() => {
    mockSupabase.reset();
  });
  
  test('getPhases returns phases ordered by order_index', async () => {
    mockSupabase.mockResponse('journey_phases', [
      { id: 'phase1', name: 'Phase 1', order_index: 10 },
      { id: 'phase2', name: 'Phase 2', order_index: 20 }
    ]);
    
    const phases = await JourneyStepsService.getPhases();
    
    expect(phases).toHaveLength(2);
    expect(phases[0].id).toBe('phase1');
    expect(phases[1].id).toBe('phase2');
    expect(mockSupabase.called('journey_phases')).toBe(true);
  });
  
  test('getSteps filters by phaseId when provided', async () => {
    mockSupabase.mockResponse('journey_steps', [
      { id: 'step1', name: 'Step 1', phase_id: 'phase1' }
    ]);
    
    await JourneyStepsService.getSteps({ phaseId: 'phase1' });
    
    expect(mockSupabase.calledWith('journey_steps', { eq: ['phase_id', 'phase1'] })).toBe(true);
  });
  
  test('updateStepProgress sets completed_at when status is completed', async () => {
    mockSupabase.mockResponse('company_journey_steps', [{ id: 'progress1' }]);
    
    await JourneyStepsService.updateStepProgress('company1', 'step1', { status: 'completed' });
    
    expect(mockSupabase.lastUpdatedData('company_journey_steps')).toHaveProperty('completed_at');
  });
  
  // Add more tests for each service method
});
```

### 2. Migration Tests

Create tests to validate the migration process:

```typescript
// src/tests/migration.test.ts

import { migrateJourneyData } from '../scripts/migration-script';
import { mockSupabase } from './mocks/supabase.mock';

jest.mock('../lib/supabase', () => mockSupabase);

describe('Journey Data Migration', () => {
  beforeEach(() => {
    mockSupabase.reset();
  });
  
  test('challenges are correctly migrated to steps', async () => {
    // Setup mock data
    mockSupabase.mockResponse('journey_challenges', [
      { 
        id: 'challenge1', 
        name: 'Challenge 1', 
        phase_id: 'phase1', 
        difficulty_level: 3,
        estimated_time_min: 30,
        estimated_time_max: 60,
        key_outcomes: ['Outcome 1'],
        prerequisite_challenges: ['challenge2']
      }
    ]);
    
    mockSupabase.mockResponse('journey_steps', []);
    
    // Run migration
    await migrateJourneyData();
    
    // Check results
    const insertedData = mockSupabase.lastInsertedData('journey_steps');
    expect(insertedData).toBeDefined();
    expect(insertedData.id).toBe('challenge1');
    expect(insertedData.prerequisite_steps).toEqual(['challenge2']);
  });
  
  test('existing steps are updated with challenge data', async () => {
    // Setup mock data
    mockSupabase.mockResponse('journey_challenges', [
      { 
        id: 'challenge1', 
        name: 'Challenge 1', 
        difficulty_level: 4
      }
    ]);
    
    mockSupabase.mockResponse('journey_steps', [
      { id: 'challenge1', name: 'Step 1', difficulty_level: 2 }
    ]);
    
    // Run migration
    await migrateJourneyData();
    
    // Check results
    const updatedData = mockSupabase.lastUpdatedData('journey_steps');
    expect(updatedData).toBeDefined();
    expect(updatedData.difficulty_level).toBe(4);
  });
  
  // Add more tests for tool migration, company progress, etc.
});
```

### 3. Database Schema Tests

Create tests to validate the database schema:

```typescript
// src/tests/schema.test.ts

import { supabase } from '../lib/supabase';

describe('Database Schema', () => {
  test('journey_steps table has all required columns', async () => {
    const { data, error } = await supabase.rpc('get_table_columns', { table_name: 'journey_steps' });
    
    expect(error).toBeNull();
    expect(data).toBeDefined();
    
    const columnNames = data.map(col => col.column_name);
    
    expect(columnNames).toContain('id');
    expect(columnNames).toContain('name');
    expect(columnNames).toContain('phase_id');
    expect(columnNames).toContain('difficulty_level');
    expect(columnNames).toContain('estimated_time_min');
    expect(columnNames).toContain('estimated_time_max');
    expect(columnNames).toContain('key_outcomes');
    expect(columnNames).toContain('prerequisite_steps');
  });
  
  test('company_journey_steps table has all required columns', async () => {
    const { data, error } = await supabase.rpc('get_table_columns', { table_name: 'company_journey_steps' });
    
    expect(error).toBeNull();
    expect(data).toBeDefined();
    
    const columnNames = data.map(col => col.column_name);
    
    expect(columnNames).toContain('id');
    expect(columnNames).toContain('company_id');
    expect(columnNames).toContain('step_id');
    expect(columnNames).toContain('status');
    expect(columnNames).toContain('completion_percentage');
    expect(columnNames).toContain('order_index');
  });
  
  // Add more tests for other tables
});
```

## Daily Tasks Breakdown

### Week 1 (May 5 - May 9)

**Monday (May 5)**
- Kick-off meeting
- Detailed analysis of current data models
- Create schema design document
- Begin drafting SQL schema updates

**Tuesday (May 6)**
- Finalize SQL schema updates
- Create database migration plan
- Begin implementing core SQL schema changes
- Setup test environments

**Wednesday (May 7)**
- Complete SQL schema changes
- Begin implementing TypeScript type definitions
- Start writing migration scripts
- Begin unit test framework setup

**Thursday (May 8)**
- Complete TypeScript type definitions
- Continue migration script implementation
- Begin service layer implementation
- Add first unit tests

**Friday (May 9)**
- Complete first version of migration scripts
- Continue service layer implementation
- Expand unit tests
- Team review of week's progress

### Week 2 (May 12 - May 16)

**Monday (May 12)**
- Finish service layer implementation
- Create compatibility views for legacy code
- Expand unit tests for service layer
- Begin migration script testing

**Tuesday (May 13)**
- Complete migration script implementation
- Test migration against staging data
- Address any issues found in testing
- Begin documentation of API changes

**Wednesday (May 14)**
- Finalize migration scripts and compatibility views
- Complete unit tests for all components
- Begin integration testing
- Update API documentation

**Thursday (May 15)**
- Integration testing with other services
- Performance testing for key queries
- Bug fixes and optimizations
- Complete documentation

**Friday (May 16)**
- Final testing and review
- Prepare demo of the data foundation
- Plan for Sprint 2 (UI Components)
- Sprint 1 retrospective

## Team Allocation

- **Database Engineer**: Schema design, SQL implementation, migration scripts
- **Backend Developer**: Service layer implementation, compatibility views
- **Testing Engineer**: Unit tests, migration tests, integration tests
- **Tech Lead**: Architecture oversight, code reviews, risk management

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Data loss during migration | Low | High | Create full backups before migration, run in staging first, comprehensive testing |
| Performance issues with new schema | Medium | Medium | Index key columns, optimize queries, performance test with production-scale data |
| Integration issues with existing code | Medium | High | Create compatibility views, thorough integration testing, phased rollout |
| Timeline slippage | Medium | Medium | Prioritize core functionality, have contingency buffer in schedule |
| Knowledge gaps about existing data | Medium | High | Thorough analysis phase, involve original developers where possible |

## Metrics for Success

- 100% of existing data successfully migrated
- Zero data loss or corruption
- All unit tests passing
- Key query performance equal to or better than before
- Backward compatibility maintained for existing features
- Core service API documented and demonstrated

## Next Steps After Sprint 1

Once the data foundation is established in Sprint 1, Sprint 2 will focus on:

1. Developing core UI components based on the new data model
2. Creating the component library for the redesigned journey system
3. Implementing the base layouts and navigation structures
4. Building the StepCard, PhaseNavigation, and ToolCard components

================
File: docs/JOURNEY_SYSTEM_SPRINT1_IMPLEMENTATION_SUMMARY.md
================
# Journey System Redesign - Sprint 1 Implementation Summary

**Date:** May 3, 2025  
**Status:** Completed

## Overview

This document summarizes the implementation work done in Sprint 1 of the Journey System Redesign project. The sprint focused on unifying the journey data structure, creating a centralized service layer, and implementing React hooks for improved component development.

## Key Deliverables

### 1. Unified Data Schema
- **SQL Migration:** Created a comprehensive unified schema for journey data
- **Compatibility Layer:** Added views and functions for backward compatibility
- **Entity Relationships:** Improved relationships between phases, steps, and tools

### 2. JourneyUnifiedService
- Implemented a centralized service with methods for:
  - Getting and updating journey phases and steps
  - Managing company progress on steps
  - Handling tool selection and evaluation
  - Providing personalized recommendations

### 3. Error Handling System
- Created domain-specific error types:
  - `JourneyError` - Base error class
  - `StepNotFoundError` - For handling missing steps
  - `PhaseNotFoundError` - For handling missing phases
  - `ToolNotFoundError` - For handling missing tools
  - `ValidationError` - For data validation issues
  - `DatabaseError` - For database operation failures
  - `NotAuthorizedError` - For permission issues

### 4. Validation System
- Implemented comprehensive validators for:
  - Step properties (name, difficulty, time estimates)
  - Tool properties (name, type, URL validation)
  - Status values
  - Rating values
  - Completion percentages

### 5. React Hooks for Components
- **useJourneySteps:** For managing and displaying journey steps
  - Loading and refreshing steps
  - Tracking company progress
  - Getting steps in the right order with progress information

- **useJourneyTools:** For tool management and selection
  - Loading and searching for tools
  - Managing company-specific tool evaluations
  - Comparing multiple tools

- **useCompanyJourney:** For company journey overview
  - Loading phase and step progress
  - Updating step statuses
  - Getting completion percentages
  - Tracking overall journey progress
  
- **useStepProgress:** For individual step interactions
  - Loading step details with related tools
  - Managing tool selection and rating
  - Updating step progress
  - Getting personalized tool recommendations

### 6. Documentation and Examples
- Created API documentation for JourneyUnifiedService
- Added usage examples for the React hooks
- Documented validation rules and error handling
- Created migration guide for existing code

## Implementation Approach

1. **Schema First:** Started with a solid database foundation
2. **Service Layer:** Built a comprehensive service API
3. **Error Handling:** Implemented consistent error handling patterns
4. **React Hooks:** Created hooks that encapsulate common patterns
5. **Documentation:** Documented the new system for developers

## Testing & Validation

- Created unit tests for the JourneyUnifiedService
- Added validation for all user inputs
- Tested the migration process with real data
- Verified compatibility with existing code

## Next Steps (Sprint 2)

1. **Component Migration:**
   - Update journey-related components to use the new hooks
   - Implement enhanced UX based on the new capabilities

2. **Enhanced Visualization:**
   - Create improved journey visualization components
   - Implement milestone tracking and celebrations

3. **Analytics Integration:**
   - Connect the journey system to analytics tracking
   - Implement usage dashboards for insights

## Conclusion

Sprint 1 successfully established a solid foundation for the Journey System Redesign. By unifying the data model, implementing a comprehensive service layer, and creating React hooks for common patterns, we've created a more maintainable and extensible system. The new structure allows for easier feature development in future sprints while maintaining compatibility with existing code.

================
File: docs/JOURNEY_SYSTEM_SPRINT1_SUMMARY.md
================
# Journey System Redesign: Sprint 1 Summary

**Date:** May 3, 2025  
**Status:** In Progress

## Overview

Sprint 1 of the Journey System Redesign focused on establishing the foundation for unifying the journey steps and challenges into a coherent, consolidated data model. The goal is to simplify the overall architecture while ensuring backward compatibility with existing features.

## Completed Work

### 1. Database Schema

- ✅ Created unified schema with `journey_steps` as the central entity
- ✅ Added support tables for tool associations (`step_tools`, `company_step_tools`)
- ✅ Implemented company progress tracking with `company_journey_steps`
- ✅ Added migration capabilities to preserve existing data

### 2. Service Layer

- ✅ Implemented core JourneyUnifiedService methods:
  - Phase management
  - Step retrieval and filtering
  - Step progress tracking
  - Tool association and evaluation

- ✅ Created comprehensive unit tests:
  - General service functionality
  - Tool-specific operations
  - Error handling

### 3. Compatibility Layer

- ✅ Created backward compatibility views:
  - Dynamic `company_challenge_progress_view` that adapts to actual schema
  - `challenge_tool_recommendations_view` for tool mappings
  
- ✅ Implemented support functions:
  - `get_tool_evaluations_for_step`
  - `get_tool_comparison_data`

- ✅ Added SQL diagnostic capabilities to assist with debugging
- ✅ Built fallback mechanisms for schema variations

## In Progress

### 1. UI Integration

- 🔶 Update UI components to use the unified service
- 🔶 Modify tool selection and evaluation components 
- 🔶 Create new Dashboard widgets for the unified model

### 2. Documentation

- 🔶 Technical documentation for developers
- 🔶 API reference for JourneyUnifiedService
- 🔶 Migration guide for existing code

## Technical Challenges Encountered

### Schema Variations

The existing database schema had variations across environments that required a more flexible approach:

- **Solution**: Created a dynamic SQL view generator that inspects the actual database schema and adapts the compatibility view accordingly
- **Benefit**: More resilient compatibility layer that works across different environments

### Type Safety

Ensuring TypeScript type safety while maintaining backward compatibility:

- **Solution**: Created type aliases that map between the old and new data models
- **Benefit**: Code can gradually migrate without breaking existing type checks

## Next Steps for Sprint 2

1. Complete the remaining service layer methods:
   - Advanced recommendation capabilities
   - Analytics integration
   - Bulk operations

2. Update UI components:
   - Step cards and lists
   - Tool selector components
   - Progress tracking widgets

3. Finalize documentation:
   - Service API reference
   - Migration guides
   - Architectural overview

4. Begin refactoring existing UI to use the unified service:
   - Journey board
   - Step details
   - Tool selection and evaluation

## Technical Decisions & Rationale

### Why Dynamic SQL Views?

The decision to use dynamically generated SQL views accommodates schema variations:

1. Different environments might have different column names
2. Schema might evolve over time
3. The approach adapts at runtime rather than being hardcoded
4. Better resilience against database changes

### Why Mock Testing?

The unit tests use a mocked Supabase client because:

1. Tests should be isolated from actual database calls
2. Mocks allow precise control over test conditions
3. Tests run faster without real database connections
4. More predictable test results

## Migration Path

The migration strategy follows these steps:

1. **Deploy Unified Schema**: Add new tables without disrupting existing ones
2. **Create Compatibility Layer**: Add views and functions for backward compatibility
3. **Migrate Service Layer**: Update code to use the new unified service
4. **Update UI Components**: Gradually update UI to use the new service
5. **Remove Deprecated Code**: Once migration is complete (several sprints later)

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Schema compatibility issues | Medium | High | Dynamic views, diagnostic logging |
| Performance impact | Low | Medium | Index optimization, monitoring |
| Data loss | Very Low | Very High | Multiple backups, validation scripts |
| UI regression | Medium | Medium | Incremental updates, automated tests |

## Conclusion

Sprint 1 has successfully established the foundation for the Journey System Redesign. The unified data model and compatibility layer provide a solid base for further development. The focus for Sprint 2 will be on completing the service layer implementation and beginning the UI integration.

================
File: docs/JOURNEY_SYSTEM_SPRINT1_WEEK2_PLAN.md
================
# Journey System Redesign - Sprint 1 Week 2 Plan

**Date:** May 3, 2025  
**Status:** In Progress

## Overview

Following the successful completion of Week 1 of Sprint 1, this document outlines the plan for Week 2, which focuses on completing the service layer, building React hooks, finalizing testing, and preparing for UI migration in Sprint 2.

## Week 2 Schedule

### Monday

1. **Complete Service Layer Methods**
   - ✅ Add getStepComplete method
   - ✅ Add addCustomTool method
   - ✅ Update compareTools (alias for compareTool) for backward compatibility
   - ❌ Add unit tests for newer methods

2. **React Hooks Implementation - Part 1**
   - ✅ Create useJourneySteps hook
   - ✅ Create useJourneyTools hook
   - ❌ Create unit tests for hooks

### Tuesday

1. **React Hooks Implementation - Part 2**
   - ✅ Create useCompanyJourney hook
   - ✅ Create useStepProgress hook
   - ❌ Add usage examples for hooks

2. **Error Handling Enhancements**
   - ✅ Implement domain-specific error types
   - ✅ Add comprehensive validation
   - ✅ Create consistent error responses

### Wednesday

1. **Testing Framework Completion**
   - ❌ Complete service method tests
   - ❌ Implement hook testing utility
   - ❌ Add integration tests for critical paths

2. **Compatibility Layer Testing**
   - ❌ Test dynamically generated SQL views
   - ❌ Verify backward compatibility
   - ❌ Create migration verification script

### Thursday

1. **Developer Documentation**
   - ✅ Create JourneyUnifiedService API reference
   - ❌ Document React hooks usage
   - ❌ Create migration guide for developers

2. **UI Component Planning**
   - ❌ Review existing components
   - ❌ Create plan for updating components
   - ❌ Document component migration approach

### Friday

1. **Sprint 2 Planning**
   - ❌ Create UI migration plan
   - ❌ Document UI component refactoring approach
   - ❌ Setup prioritization for Sprint 2

2. **Wrap-up and Review**
   - ❌ Final code review
   - ❌ Integration testing
   - ❌ Document Week 2 learnings

## Implementation Progress

### Completed Items

1. **Service Methods**
   - Added getStepComplete method to retrieve a step with all related data
   - Added addCustomTool method to create custom tools for companies
   - Created compareTools alias for backward compatibility
   - Updated error handling in core methods

2. **React Hooks**
   - Created useJourneySteps hook for step management
   - Created useJourneyTools hook for tool management
   - Created useCompanyJourney hook for company journey management
   - Created useStepProgress hook for individual step management

3. **Error Handling**
   - Implemented domain-specific error types (JourneyError, StepNotFoundError, etc.)
   - Added comprehensive validation utilities in journey-validators.ts
   - Created consistent error response patterns

4. **Documentation**
   - Created JourneyUnifiedService API reference

### In-Progress Items

1. **Service Methods Testing**
   - Adding tests for newer methods
   - Verifying edge case handling

2. **Hook Testing**
   - Setting up testing environment for hooks
   - Creating mock data for testing

### Upcoming Items

1. **Hook Usage Examples**
   - Need to create example components using the new hooks
   - Demonstrate best practices for hook implementation

2. **Documentation**
   - React hooks usage documentation
   - UI component migration plan
   - Migration guide for developers

## Key Challenges

1. **Testing Hook Functionality**
   - React hooks require a different testing approach
   - Need to mock React's state management

2. **Ensuring Backward Compatibility**
   - Must verify all existing code continues to work
   - Need comprehensive integration tests

3. **Schema Variation Handling**
   - Different environments have different column names
   - Need to ensure compatibility layer works in all cases

## Conclusion

We've made significant progress in Week 2, completing the React hooks and error handling ahead of schedule. We're still on track to finish the remaining tasks by the end of the week, which will set us up well for the UI migration in Sprint 2. The focus for the next couple of days will be on testing, documentation, and planning for the UI component updates.

================
File: docs/JOURNEY_SYSTEM_SPRINT2_PLAN.md
================
# Journey System Redesign - Sprint 2 Plan

**Date:** May 5, 2025  
**Status:** Planning  
**Duration:** 2 Weeks (May 6 - May 19, 2025)

## Overview

Following the successful completion of Sprint 1, which established the foundational data structures, service layer, and React hooks, Sprint 2 will focus on implementing the UI components and user experience enhancements. This sprint will leverage the hooks and services created in Sprint 1 to deliver an improved journey experience for users.

## Sprint 2 Objectives

1. **Component Migration & Enhancement**
   - Migrate existing journey components to use the new unified system
   - Implement enhanced UI components with improved user experience
   - Create new interactive visualization components

2. **Analytics Integration**
   - Implement comprehensive journey analytics tracking
   - Create analytics dashboards for admins and users
   - Add milestone tracking and celebration features

3. **Performance Optimization**
   - Optimize data loading patterns for journey components
   - Implement data prefetching for common user flows
   - Reduce unnecessary re-renders in journey components

4. **Advanced Features**
   - Implement enhanced recommendation system in the UI
   - Add adaptive difficulty and time estimates
   - Create improved tool comparison and selection features

## Week 1 Schedule

### Monday (May 6)

1. **JourneyOverview Component**
   - Update to use useCompanyJourney hook
   - Implement enhanced progress visualization
   - Add phase-based filtering and sorting

2. **JourneyStepList Component**
   - Update to use useJourneySteps hook
   - Enhance drag-and-drop capabilities
   - Implement virtual scrolling for large step lists

### Tuesday (May 7)

1. **StepDetail Component**
   - Update to use useStepProgress hook
   - Improve layout and responsive design
   - Add enhanced status update UI

2. **ToolSelector Component**
   - Update to use hook-based tool selection
   - Implement enhanced filtering and searching
   - Add visual comparison features

### Wednesday (May 8)

1. **Journey Analytics Components**
   - Create company progress analytics charts
   - Implement time tracking visualization
   - Add tool usage analytics

2. **Milestone Tracking**
   - Create milestone detection service
   - Implement milestone celebration UI
   - Add notification system for achievements

### Thursday (May 9)

1. **Dashboard Integration**
   - Update dashboard widgets to use new journey system
   - Create journey progress summary widget
   - Add next steps recommendation widget

2. **Mobile Optimization**
   - Test and optimize journey components for mobile
   - Implement responsive designs for all new components
   - Create mobile-specific interaction patterns

### Friday (May 10)

1. **Week 1 Testing**
   - Comprehensive testing of updated components
   - Fix any identified issues
   - Performance testing and optimization

2. **Week 1 Documentation**
   - Update component documentation
   - Create usage examples for new components
   - Document any API changes

## Week 2 Schedule

### Monday (May 13)

1. **Enhanced Visualization Components**
   - Create interactive journey map component
   - Implement step relationship visualization
   - Add progress path visualization

2. **User Feedback Components**
   - Implement inline rating components for steps
   - Create step improvement suggestion form
   - Add tool rating aggregation

### Tuesday (May 14)

1. **Recommendation Components**
   - Implement personalized tool recommendation UI
   - Create next best steps recommendation component
   - Add intelligent prompts based on user progress

2. **Advanced Search & Filter**
   - Create advanced step search component
   - Implement multi-criteria filtering
   - Add saved search feature

### Wednesday (May 15)

1. **Step Assistant Components**
   - Create intelligent step assistant UI
   - Implement contextual help features
   - Add AI-powered guidance for steps

2. **Notification Center**
   - Implement journey-related notifications
   - Create notification preferences UI
   - Add email notification templates

### Thursday (May 16)

1. **Admin Components**
   - Create journey analytics dashboard for admins
   - Implement company comparison tools
   - Add journey customization interfaces

2. **Integration Testing**
   - Test all components together
   - Verify data flow between components
   - Validate UX consistency

### Friday (May 17)

1. **Final Testing & Polish**
   - End-to-end testing of journey system
   - Performance optimization
   - UX improvements based on testing feedback

2. **Documentation & Sprint Review**
   - Complete all documentation
   - Prepare sprint review presentation
   - Plan for Sprint 3

## Implementation Details

### Component Migration Strategy

We'll follow these steps for each component:

1. Create wrapper components that use both old and new data sources during transition
2. Update one component at a time, starting with leaf components
3. Implement comprehensive error boundaries for graceful degradation
4. Use feature flags to enable gradual rollout

### Key New Components

1. **InteractiveJourneyMap**
   - Visual representation of the entire journey
   - Interactive navigation between phases and steps
   - Real-time progress visualization
   - Drag-and-drop step reordering

2. **StepRelationshipGraph**
   - Visualize relationships between steps
   - Show dependencies and recommended sequences
   - Highlight completion paths and bottlenecks

3. **JourneyAnalyticsDashboard**
   - Time spent per phase/step
   - Completion rates and bottlenecks
   - Tool selection analytics
   - Custom metrics and KPIs

4. **MilestoneCelebration**
   - Animated celebrations for key achievements
   - Customizable rewards and recognition
   - Social sharing capabilities

### Performance Optimization Techniques

1. **Selective Rendering**
   - Use React.memo for pure components
   - Implement shouldComponentUpdate optimizations
   - Use useCallback for event handlers

2. **Data Loading**
   - Implement data prefetching for common paths
   - Use optimistic UI updates for better UX
   - Implement local caching of journey data

3. **Virtualization**
   - Use virtualized lists for large datasets
   - Implement progressive loading for journey map
   - Optimize image and asset loading

## Success Criteria

1. All existing journey components successfully migrated to new system
2. Performance improvements measured and documented:
   - 30% reduction in initial load time
   - 50% reduction in data transfer for journey pages
   - 40% improvement in interaction responsiveness

3. User experience improvements:
   - Enhanced visualization of journey progress
   - Improved tool selection experience
   - More personalized recommendations

4. Analytics capabilities:
   - Comprehensive tracking of journey interactions
   - Useful insights for both users and admins
   - Performance metrics for continuous improvement

## Risks and Mitigation

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| API incompatibilities discovered | High | Medium | Thorough testing during each component migration, temporary adapters if needed |
| Performance issues with large journeys | High | Medium | Progressive loading, virtualization, optimize queries |
| UX inconsistencies across components | Medium | High | Develop shared component library, UI review checkpoints |
| Mobile responsiveness challenges | Medium | Medium | Mobile-first design approach, device testing matrix |
| Data migration issues | High | Low | Comprehensive testing with production-like data, rollback plan |

## Dependencies

1. **External**
   - Analytics service API changes (in progress)
   - Updated design system components (ready)
   - New notification service (planned for mid-sprint)

2. **Internal**
   - Completion of all Sprint 1 items (complete)
   - Updated journey data types (complete)
   - Error handling system (complete)

## Post-Sprint Activities

1. **Usability Studies**
   - Conduct user testing with selected customers
   - Gather feedback on new journey experience
   - Identify opportunities for further improvement

2. **Performance Analysis**
   - Measure and document performance improvements
   - Identify any remaining bottlenecks
   - Create optimization plan for specific issues

3. **Documentation**
   - Update technical documentation
   - Create user guides for new features
   - Document component API changes

## Conclusion

Sprint 2 builds on the solid foundation established in Sprint 1 by implementing enhanced UI components and user experiences. By leveraging the React hooks and services already created, we aim to deliver a significantly improved journey system with better visualization, personalization, and performance. The components developed in this sprint will provide users with a more engaging and effective way to navigate their journey within the system.

================
File: docs/JOURNEY_SYSTEM_SPRINT3_PLAN.md
================
# Journey System Sprint 3 Plan: Main Journey Page Implementation
**Date:** May 3, 2025  
**Status:** Draft  
**Target Completion:** June 13, 2025

## Overview

Sprint 3 builds on the foundation established in the first two sprints:

- **Sprint 1:** Data model consolidation, service layer refactoring
- **Sprint 2:** Core UI components (SimplePhaseProgress, JourneyOverview)

This sprint focuses on implementing the main Journey page with timeline and list views, incorporating the new unified data model and reusable components.

## Objectives

1. Implement the complete main Journey page
2. Create both Timeline and List views with seamless switching
3. Develop the Action Panel with personalized recommendations
4. Build the Step Panel with preview functionality
5. Implement state management for all Journey views

## Key Deliverables

### 1. Main Journey Page
- Complete responsive layout with adaptive views
- Integration with the unified journey data model
- Consistent design system implementation
- Accessibility compliance (WCAG 2.1 AA)

### 2. Timeline & List Views
- Timeline View:
  - Horizontal, scrollable timeline visualization
  - Phase grouping with visual separators
  - Variable card heights based on step importance
  - Click interactions for step selection

- List View:
  - Vertical list with collapsible phase sections
  - Detailed step information with status indicators
  - Sorting and filtering capabilities
  - Quick action buttons for each step

### 3. Action Panel
- Personalized recommendations based on company progress
- Smart filtering controls
- Next best action suggestions
- Quick links to relevant tools and resources

### 4. Step Panel
- Expandable preview of selected step details
- Quick actions without leaving the main page
- Tool preview with key information
- Status update capabilities

### 5. State Management
- Context-based state management for selected steps/phases
- Efficient data loading patterns
- Caching strategies for performance
- Optimistic UI updates

## Technical Approach

### Component Architecture

```
JourneyPage (Container)
├── JourneyHeader
│   ├── PhaseNavigation 
│   └── ViewToggle (Timeline/List)
├── MainSection
│   ├── TimelineView | ListView (toggleable)
│   │   └── StepCard[]
│   │       ├── StatusBadge
│   │       ├── DifficultyIndicator
│   │       └── TimeEstimate
│   └── ActionPanel
│       ├── NextRecommendations
│       └── FilterControls
└── StepPreviewPanel (expandable)
    ├── StepQuickView
    ├── ActionButtons
    └── ToolPreview
```

### State Management Approach

1. **Journey Context**
   - Selected phase
   - Selected step
   - View mode (timeline/list)
   - Filter settings

2. **Custom Hooks**
   - `useJourneyNavigation` - Handle navigation between phases/steps
   - `useStepSelection` - Manage step selection state
   - `useViewToggle` - Toggle between timeline and list views
   - `useStepRecommendations` - Get personalized recommendations

### Data Flow

1. Data fetched from unified service layer
2. Loaded into context providers
3. Components consume context through hooks
4. UI updates based on state changes
5. User interactions trigger state updates
6. Service layer persists changes when needed

## Tasks & Timeline

### Week 1 (June 2 - June 6)

1. **Layout Structure** (2 days)
   - Implement responsive page layout
   - Create header with phase navigation
   - Build view toggle mechanism

2. **Timeline View** (3 days)
   - Develop horizontal timeline visualization
   - Implement phase grouping in timeline
   - Create scrolling and interaction behaviors

### Week 2 (June 9 - June 13)

3. **List View** (2 days)
   - Build vertical list with phase sections
   - Implement step cards with detailed information
   - Add sorting and filtering capabilities

4. **Action Panel** (1.5 days)
   - Create recommendation engine integration
   - Build filtering controls
   - Implement next action suggestions

5. **Step Preview Panel** (1.5 days)
   - Build expandable step preview
   - Create quick actions interface
   - Implement tool preview component

### Stretch Goals (if time permits)

- Drag and drop functionality for reordering steps
- Enhanced visualization options for the timeline
- Advanced filtering mechanisms
- Animation enhancements for transitions

## Technical Considerations

### Performance Optimization

- Use virtualized lists for large datasets
- Implement lazy loading for step details
- Optimize API queries with pagination and filtering
- Cache frequently accessed data in memory

### Accessibility

- Ensure keyboard navigability for all interactions
- Implement proper ARIA attributes for custom controls
- Test with screen readers
- Ensure color contrast meets WCAG requirements

### Mobile Optimization

- Create responsive layouts that adapt to small screens
- Implement touch-friendly interactions
- Simplify views for mobile without removing functionality
- Test on various screen sizes

## Dependencies

- Unified data model from Sprint 1
- UI components from Sprint 2 (especially SimplePhaseProgress and JourneyOverview)
- Design system integration
- API endpoints for journey data
- Recommendation engine integration

## Testing Strategy

1. **Component Tests**
   - Unit tests for each new component
   - Snapshot tests for UI stability
   - Interaction tests for user flows

2. **Integration Tests**
   - Test component integration
   - Verify data flow
   - Test state management

3. **E2E Tests**
   - Test key user flows
   - Verify data persistence
   - Cross-browser testing

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Timeline view complexity | High | Medium | Start early, break into smaller components |
| Performance issues with large datasets | High | Medium | Implement virtualization and pagination |
| Mobile responsiveness challenges | Medium | Low | Mobile-first development approach |
| State management complexity | Medium | Medium | Clear data flow documentation, thorough testing |
| API integration issues | Medium | Low | Mock APIs for development, close work with backend team |

## Success Criteria

1. Main Journey page fully implemented with both Timeline and List views
2. Action panel with working recommendations
3. Step preview panel with functional quick actions
4. State management handling all user interactions
5. Performance meets established metrics (< 1s initial load, < 100ms interactions)
6. All components pass accessibility tests
7. Mobile experience fully functional

## Next Steps

Upon successful completion of Sprint 3, the team will move to Sprint 4, which focuses on:
- Step details page with tabs
- Tool selection and comparison
- Tool evaluation workflow
- Custom tool addition
- Integration with recommendation engine

================
File: docs/JOURNEY_SYSTEM_UNIFIED_REDESIGN.md
================
# The Wheel: Journey System Unified Redesign
## Technical Specification & Implementation Plan

**Document Version:** 1.0  
**Date:** May 2, 2025  
**Status:** Draft  
**Author:** Cline  

## Table of Contents
1. [Executive Summary](#1-executive-summary)
2. [Problem Statement](#2-problem-statement)
3. [Design Principles](#3-design-principles)
4. [Information Architecture](#4-information-architecture)
5. [Data Model](#5-data-model)
6. [Component Architecture](#6-component-architecture)
7. [UI/UX Specifications](#7-uiux-specifications)
8. [Development Plan](#8-development-plan)
9. [Sprint Schedule](#9-sprint-schedule)
10. [Quality Assurance](#10-quality-assurance)
11. [Risk Management](#11-risk-management)
12. [Metrics & Success Criteria](#12-metrics--success-criteria)
13. [Appendices](#13-appendices)

## 1. Executive Summary

The Journey feature of The Wheel platform is being redesigned to address complexity issues, parallel implementations, and inconsistent user experiences. This document provides a comprehensive plan to unify the system around a step-based architecture with a clean, intuitive interface while preserving all existing functionality.

The redesign will:
- Simplify the UI without sacrificing functionality
- Consolidate parallel implementations (steps/challenges)
- Improve the tool selection and evaluation experience
- Ensure journey customization capabilities
- Implement progressive disclosure techniques
- Enhance performance and maintainability

Implementation will occur over five sprints (10 weeks), from data model consolidation through UI development to testing and refinement.

## 2. Problem Statement

### 2.1 Current State Assessment

The Journey system has evolved into a complex feature set with multiple overlapping implementations:

1. **Parallel Data Models**: Existence of both "steps" and "challenges" representing similar concepts
2. **UI Complexity**: Overwhelming interfaces showing too much information at once
3. **Technical Debt**: Duplicate code, inconsistent patterns, and legacy approach
4. **Performance Issues**: Inefficient data loading patterns
5. **Maintenance Challenges**: Difficult to add features or fix bugs due to complexity

### 2.2 Root Causes

1. **Feature Evolution Without Refactoring**: As functionality expanded, new features were added without restructuring
2. **Multiple Implementation Approaches**: Different teams implemented similar features differently
3. **Lack of Unified Vision**: Absence of a comprehensive design system and architecture
4. **Incremental Changes**: Series of small changes eventually created inconsistent UX

### 2.3 Key Requirements

The redesigned Journey system must:

1. **Maintain All Functionality**: No features can be lost
2. **Simplify User Experience**: Cleaner, more intuitive interface
3. **Unite Data Models**: Single consistent approach
4. **Preserve Customization**: Companies must be able to customize their journey
5. **Support Tool Evaluation**: Full tool comparison and selection workflow

## 3. Design Principles

The redesign will adhere to these principles:

1. **Simplicity First**: Clean interfaces showing only what's needed at any moment
2. **Progressive Disclosure**: Reveal complexity only when needed
3. **Consistent Patterns**: Use repeatable UI patterns that become familiar
4. **Visual Hierarchy**: Make important elements stand out
5. **Performance Focus**: Optimize loading patterns and rendering
6. **Component-Based Architecture**: Modular design with reusable components
7. **Test-Driven Development**: Comprehensive testing at unit and integration levels
8. **Mobile-First Approach**: Design for smaller screens first, then expand
9. **Accessibility Standards**: WCAG 2.1 AA compliance

## 4. Information Architecture

### 4.1 Core Concepts

1. **Phases**: Major stages in the startup journey
2. **Steps**: Individual actions or milestones within phases
3. **Tools**: Software or services that help complete steps
4. **Progress**: Company's advancement through their journey

### 4.2 User Flows

1. **Journey Management Flow**:
   - View journey map
   - Customize steps (add, remove, reorder)
   - Track progress
   - Get recommendations

2. **Step Completion Flow**:
   - View step details
   - Select tools
   - Complete tasks
   - Mark step as done

3. **Tool Selection Flow**:
   - View recommendations
   - Compare tools
   - Evaluate options
   - Select final tool

### 4.3 Navigation Structure

1. **Main Navigation**:
   - Dashboard
   - Journey
   - Tools
   - Analytics

2. **Journey Navigation**:
   - Phase navigation
   - Step list/timeline
   - Step details
   - Tool selection

## 5. Data Model

### 5.1 Core Entities

```typescript
// Primary entities
interface JourneyPhase {
  id: string;
  name: string;
  description?: string;
  order_index: number;
  color?: string;
  created_at: string;
  updated_at: string;
}

interface JourneyStep {
  id: string;
  name: string;
  description?: string;
  phase_id: string;
  difficulty_level: 1 | 2 | 3 | 4 | 5;
  estimated_time_min: number;
  estimated_time_max: number;
  key_outcomes?: string[];
  prerequisite_steps?: string[];
  order_index: number;
  created_at: string;
  updated_at: string;
  is_custom?: boolean;
}

interface CompanyJourneyStep {
  id: string;
  company_id: string;
  step_id: string;
  status: 'not_started' | 'in_progress' | 'completed' | 'skipped';
  notes?: string;
  custom_difficulty?: number;
  custom_time_estimate?: number;
  completion_percentage?: number;
  order_index: number;
  created_at: string;
  updated_at: string;
  completed_at?: string;
}

interface Tool {
  id: string;
  name: string;
  description?: string;
  url?: string;
  logo_url?: string;
  type: string;
  category?: string;
  pricing_model?: string;
  is_premium: boolean;
}

interface StepTool {
  id: string;
  step_id: string;
  tool_id: string;
  relevance_score: number;
  created_at: string;
}

interface CompanyStepTool {
  id: string;
  company_id: string;
  step_id: string;
  tool_id: string;
  is_custom: boolean;
  rating?: number;
  notes?: string;
  selected_at?: string;
  created_at: string;
  updated_at: string;
}
```

### 5.2 Database Schema

The database schema will use the following tables:

1. `journey_phases` - Phases of the journey
2. `journey_steps` - Steps within phases
3. `company_journey_steps` - Company progress on steps
4. `tools` - Available tools
5. `step_tools` - Tools associated with steps
6. `company_step_tools` - Company tool selections and ratings
7. `tool_evaluations` - Company evaluations of tools
8. `tool_comparison_criteria` - Criteria for comparing tools

### 5.3 Data Migration Strategy

1. Create unified schema first
2. Migrate challenge data to step format
3. Preserve IDs for backward compatibility
4. Create compatibility views to support legacy code

## 6. Component Architecture

### 6.1 Core Components

1. **Page Components**:
   - JourneyPage
   - StepDetailsPage
   - ToolSelectorPage
   - JourneyEditorPage

2. **Container Components**:
   - JourneyView
   - StepDetailsView
   - ToolSelectorView
   - JourneyEditorView

3. **Presentation Components**:
   - PhaseNavigation
   - StepCard
   - ToolCard
   - StatusBadge
   - DifficultyIndicator
   - TimeEstimate

### 6.2 Component Hierarchy

```
JourneyPage
├── PhaseNavigation
├── JourneyView
│   ├── TimelineView | ListView (toggleable)
│   │   └── StepCard[]
│   │       ├── StatusBadge
│   │       ├── DifficultyIndicator
│   │       └── TimeEstimate
│   └── ActionPanel
│       ├── NextActions
│       └── FilterControls
└── StepPanel
    ├── QuickActions
    └── ToolPreview

StepDetailsPage
├── StepHeader
├── TabNavigation
├── OverviewTab
├── ToolsTab
│   ├── ToolList
│   │   └── ToolCard[]
│   └── ToolComparisonTable
├── GuidanceTab
├── ResourcesTab
└── NotesTab

JourneyEditorPage
├── PhaseSelector
├── StepLibrary
├── JourneyBuilder
│   └── DraggableStepCard[]
└── StepDetailsSidebar
```

### 6.3 State Management

1. **Local State**:
   - UI state (expanded/collapsed sections)
   - Form values
   - Temporary selections

2. **Context-Based State**:
   - Current phase
   - Selected step
   - Filter settings

3. **Server State**:
   - Journey data
   - Step details
   - Tool information
   - Company progress

4. **Custom Hooks**:
   - `useJourneyData`
   - `useStepDetails`
   - `useToolRecommendations`
   - `useCompanyProgress`

## 7. UI/UX Specifications

### 7.1 Main Journey Page

#### Layout

The main journey page uses a clean two-panel layout with an expandable details panel:

1. **Top Section**:
   - Phase navigation bar (horizontal)
   - View toggle (Timeline/List)

2. **Main Section**:
   - Left: Journey visualization (Timeline or List)
   - Right: Action panel with recommendations and filters

3. **Bottom Section** (expandable):
   - Selected step details
   - Quick actions
   - Tool preview

#### Visual Design

- Clean, minimalist interface with ample whitespace
- Color-coding for phases and status indicators
- Card-based design for steps
- Clear visual hierarchy through typography and spacing
- Responsive layout adapting to screen sizes

### 7.2 Timeline View

- Horizontal, scrollable timeline with steps as cards
- Steps grouped by phase with visual separators
- Card height varies by step importance/status
- Drag handles for reordering
- Compact display focusing on essential information
- Visual indicators for relationships between steps

### 7.3 List View

- Vertical list of steps grouped by phase
- Collapsible phase sections
- More detailed step information
- Quick action buttons
- Sortable by different criteria
- Filtering options

### 7.4 Step Details View

- Tab-based interface to organize information
- Overview tab with key details
- Tools tab with recommendations and comparison
- Guidance tab with instructions
- Resources tab with links and documents
- Notes tab for company-specific information

### 7.5 Tool Selection Experience

- Initial view: Top 3 recommendations
- Expandable to show all available tools
- Add to comparison functionality (up to 5 tools)
- Side-by-side comparison table
- Rating and evaluation interface
- Custom tool addition form

### 7.6 Journey Editor

- Three-panel layout:
  - Left: Available steps library
  - Center: Current journey with drag-drop ordering
  - Right: Step details and actions
- Batch operations for multiple steps
- Filtering and searching
- Add custom steps functionality

## 8. Development Plan

### 8.1 Development Approach

1. **Component-First**: Build and test individual components before integration
2. **Feature Flags**: Implement behind feature flags for controlled rollout
3. **Parallel Development**: Work on UI and data model simultaneously
4. **Regular Integration**: Frequent integration to catch issues early
5. **Continuous Testing**: Automated tests for each component and integration

### 8.2 Development Stages

1. **Foundation** (2 weeks):
   - Data model consolidation
   - Core service layer refactoring
   - Component library setup

2. **Core Components** (2 weeks):
   - Basic UI components
   - Layout structure
   - Navigation system

3. **Main Views** (2 weeks):
   - Main journey page
   - Step details
   - Tool selection

4. **Integration** (2 weeks):
   - Feature integration
   - State management
   - API connections

5. **Refinement** (2 weeks):
   - Performance optimization
   - Edge case handling
   - Visual polish

### 8.3 Technical Considerations

1. **Performance Optimization**:
   - Virtualized lists for large data sets
   - Optimistic UI updates
   - Efficient data loading patterns
   - Caching strategies

2. **Accessibility**:
   - Semantic HTML
   - ARIA attributes
   - Keyboard navigation
   - Color contrast compliance

3. **Mobile Optimization**:
   - Responsive layouts
   - Touch-friendly interactions
   - Adaptive content presentation

4. **Browser Compatibility**:
   - Testing across major browsers
   - Graceful degradation for older browsers

## 9. Sprint Schedule

### Sprint 1: Data Foundation (May 5 - May 16)

**Objective**: Consolidate data models and establish services

**Key Deliverables**:
- Unified data model for steps (consolidating steps/challenges)
- Migration scripts for existing data
- Core service layer with consistent API
- Database views for backward compatibility
- Unit tests for data layer

**Tasks**:
1. Create unified schema design (3 days)
2. Implement migration scripts (3 days)
3. Develop core service layer (4 days)
4. Create database compatibility views (2 days)
5. Write unit tests (3 days)

### Sprint 2: UI Components (May 19 - May 30)

**Objective**: Build fundamental UI components

**Key Deliverables**:
- StepCard component with variants
- PhaseNavigation component
- ToolCard component
- Base layouts for main views
- Component storybook documentation

**Tasks**:
1. Develop StepCard and variants (3 days)
2. Create PhaseNavigation component (2 days)
3. Build ToolCard component (2 days)
4. Implement TimelineView and ListView (4 days)
5. Create ActionPanel component (2 days)
6. Storybook documentation (2 days)

### Sprint 3: Main Journey Page (June 2 - June 13)

**Objective**: Implement the main journey page

**Key Deliverables**:
- Complete main journey page
- Timeline and list views
- Action panel with recommendations
- Step panel with preview
- State management for journey views

**Tasks**:
1. Implement main page layout (2 days)
2. Develop timeline view interactions (3 days)
3. Build list view with grouping (3 days)
4. Create action panel functionality (3 days)
5. Implement step panel with preview (2 days)
6. Connect components with state management (2 days)

### Sprint 4: Step Details & Tools (June 16 - June 27)

**Objective**: Complete step details and tool selection functionality

**Key Deliverables**:
- Step details page with tabs
- Tool selection and comparison
- Tool evaluation workflow
- Custom tool addition
- Integration with recommendation engine

**Tasks**:
1. Build step details page framework (2 days)
2. Implement tab navigation system (1 day)
3. Create tool selection interface (3 days)
4. Develop tool comparison table (3 days)
5. Build evaluation workflow (3 days)
6. Implement custom tool addition (2 days)
7. Connect to recommendation engine (1 day)

### Sprint 5: Journey Editor & Refinement (June 30 - July 11)

**Objective**: Complete journey editor and refine the entire system

**Key Deliverables**:
- Journey editor with drag-drop
- Custom journey management
- Performance optimizations
- Visual polish
- Comprehensive testing
- User documentation

**Tasks**:
1. Implement journey editor (4 days)
2. Build custom journey management (3 days)
3. Optimize performance (2 days)
4. Visual refinements (2 days)
5. Integration testing (3 days)
6. Create user documentation (1 day)

## 10. Quality Assurance

### 10.1 Testing Strategy

1. **Unit Testing**:
   - Test individual components in isolation
   - Service layer testing
   - Utility function testing

2. **Integration Testing**:
   - Component integration tests
   - API integration tests
   - State management tests

3. **End-to-End Testing**:
   - Key user flows
   - Cross-browser testing
   - Mobile testing

4. **Performance Testing**:
   - Load time measurement
   - Interaction responsiveness
   - Memory usage monitoring

### 10.2 Testing Automation

- Jest for unit and integration tests
- React Testing Library for component tests
- Cypress for end-to-end testing
- Lighthouse for performance testing

### 10.3 Quality Metrics

- 90%+ code coverage for core components
- < 1s initial load time
- < 100ms interaction response time
- 0 a11y violations (WCAG 2.1 AA)
- Cross-browser compatibility (latest 2 versions)

## 11. Risk Management

### 11.1 Identified Risks

1. **Data Migration Complexity**: Existing data may be more complex than anticipated
   - Mitigation: Thorough data analysis before migration, staged migration approach

2. **Feature Regression**: Important functionality could be lost in redesign
   - Mitigation: Comprehensive feature inventory, thorough testing

3. **Performance Issues**: New UI could introduce performance problems
   - Mitigation: Performance testing throughout development, code review focus

4. **User Resistance**: Users may resist changes to familiar workflows
   - Mitigation: Clear communication, gradual rollout, comprehensive documentation

5. **Timeline Slippage**: Complex integration could delay completion
   - Mitigation: Buffer time in schedule, prioritization of critical features

### 11.2 Contingency Plans

1. **Phased Rollout**: Roll out changes gradually with feature flags
2. **Rollback Plan**: Ability to revert to previous implementation if critical issues arise
3. **Alternative Solutions**: Prepare simplified implementations for complex features if needed

## 12. Metrics & Success Criteria

### 12.1 Success Metrics

1. **User Experience Metrics**:
   - Task completion rate
   - Time on task
   - Error rate
   - User satisfaction score

2. **Technical Metrics**:
   - Page load time
   - Interaction response time
   - Bundle size
   - API response time

3. **Business Metrics**:
   - Journey completion rate
   - Tool selection frequency
   - User retention rate
   - Support ticket volume

### 12.2 KPIs for Launch

- 20% reduction in time to complete common tasks
- 30% reduction in support tickets related to journey features
- 95% of existing functionality successfully migrated
- 90% user satisfaction rating in post-launch survey
- 15% increase in journey step completion rate

## 13. Appendices

### 13.1 Component API Specifications

Detailed API documentation for key components:

```typescript
// StepCard Component
interface StepCardProps {
  step: JourneyStep;
  status?: StepStatus;
  mode?: 'compact' | 'standard' | 'detailed';
  isSelected?: boolean;
  isDraggable?: boolean;
  onClick?: (step: JourneyStep) => void;
  onStatusChange?: (stepId: string, status: StepStatus) => void;
  className?: string;
}

// PhaseNavigation Component
interface PhaseNavigationProps {
  phases: JourneyPhase[];
  activePhaseId?: string;
  onPhaseSelect: (phaseId: string) => void;
  showProgress?: boolean;
  className?: string;
}

// ToolCard Component
interface ToolCardProps {
  tool: Tool;
  isRecommended?: boolean;
  relevanceScore?: number;
  isSelected?: boolean;
  isCompared?: boolean;
  onAddToCompare?: (toolId: string) => void;
  onRemoveFromCompare?: (toolId: string) => void;
  onSelect?: (toolId: string) => void;
  onClick?: (tool: Tool) => void;
  className?: string;
}
```

### 13.2 API Endpoints

Core API endpoints for the journey system:

- `GET /api/journey/phases` - Get all journey phases
- `GET /api/journey/steps` - Get steps (filterable)
- `GET /api/journey/steps/:id` - Get step details
- `GET /api/journey/company/:companyId/progress` - Get company progress
- `POST /api/journey/company/:companyId/reorder` - Reorder steps
- `PATCH /api/journey/company/:companyId/step/:stepId` - Update step status
- `GET /api/tools/step/:stepId` - Get tools for step
- `GET /api/tools/recommendations/:stepId/:companyId` - Get personalized recommendations
- `POST /api/tools/company/:companyId/evaluate` - Save tool evaluation

### 13.3 Design System Integration

The journey redesign will fully leverage The Wheel's design system:

- Color palette adhering to design system specifications
- Typography following established hierarchies
- Spacing using the standardized scale
- Component patterns consistent with global patterns
- Icons from the approved icon set

### 13.4 Accessibility Guidelines

All components will adhere to WCAG 2.1 AA standards:

- Proper semantic HTML structure
- ARIA labels and landmarks
- Keyboard navigation support
- Color contrast compliance (minimum 4.5:1)
- Screen reader compatibility
- Focus management
- Touch target sizing (minimum 44x44px)

================
File: docs/JOURNEY_UI_SPRINT3_IMPLEMENTATION_PREVIEW.md
================
# Journey UI Sprint 3 - Implementation Preview

This document provides a visual preview and implementation guide for the new components added in Sprint 3 of the Journey UI enhancements.

## Analytics Dashboard Overview

The new JourneyAnalyticsDashboard component provides an interactive, data-rich visualization of a company's journey progress. It includes:

- Interactive tabs for Overview, Phase Progress, and Industry Comparison
- Time range filters (Week, Month, Quarter, Year, All)
- Responsive charts for progress visualization
- Comparative analytics with similar companies

### How to Access the Analytics Dashboard

The dashboard is accessible through the "Timeline" view in the JourneyMapPage:

1. Navigate to the Company Journey page
2. Click on the "Timeline" view option in the FilterBar
3. The dashboard will display with the default "month" timeframe

## Component Structure

```
src/
└── components/
    └── company/
        └── journey/
            ├── Analytics/
            │   ├── index.ts
            │   └── JourneyAnalyticsDashboard.tsx
            ├── StepRecommendations/
            │   ├── NextBestSteps.tsx
            │   ├── StepRelationshipMap.tsx
            │   └── index.ts
            └── ...
```

## Sample Usage

```tsx
// In any component
import { JourneyAnalyticsDashboard } from '@/components/company/journey/Analytics';

const MyComponent = () => {
  return (
    <div className="container">
      <h2>Journey Analytics</h2>
      <JourneyAnalyticsDashboard 
        timeRange="month" 
        className="my-6"
      />
    </div>
  );
};
```

## UI Preview

When implemented, the dashboard will display as follows:

### Overview Tab
![Overview Tab]()
- Key metrics summary (completion rate, steps completed, avg. completion time)
- Timeline chart showing progress over selected time period
- Interactive cards with hover states

### Phase Progress Tab
![Phase Progress Tab]()
- Bar charts showing completion status by phase
- Time estimation accuracy comparison 
- Interactive tooltips with detailed information

### Industry Comparison Tab
![Industry Comparison Tab]()
- Pie chart comparing company progress against industry benchmarks
- Progress bars visualizing relative standing
- Table of popular industry steps with adoption rates

## Analytics Integration

The dashboard utilizes the RecommendationService to fetch journey analytics data:

```tsx
// In the JourneyAnalyticsDashboard component
const fetchAnalytics = async () => {
  if (!currentCompany?.id) return;
  
  setLoading(true);
  try {
    const data = await RecommendationService.getJourneyAnalytics(currentCompany.id);
    setAnalytics(data);
  } catch (error) {
    console.error('Error loading journey analytics:', error);
  } finally {
    setLoading(false);
  }
};
```

## User Experiences

### Filter Interaction
Users can filter the analytics view by time range:
- Week: Shows detailed progress in the last 7 days
- Month: Shows progress over the current calendar month (default)
- Quarter: Shows progress over the last 3 months
- Year: Shows annual progress view
- All: Shows all-time progress with no time filtering

### Mobile Responsiveness
The dashboard is fully responsive:
- On mobile devices, cards stack vertically
- Charts resize to fit screen width
- Tab navigation remains accessible at all screen sizes

## Next Steps

1. **Complete the StepAssistant component** - This will provide AI-powered contextual help based on the current step
2. **Add user feedback collection** - Implement the InlineRatingComponent for gathering user feedback
3. **Enhance visual effects** - Add celebration animations for milestone achievements

## Dependencies

- chart.js: Used for rendering data visualizations
- react-chartjs-2: React wrapper for Chart.js
- framer-motion: Used for animations and transitions

## Installation

The required dependencies have been added to the project:

```
npm install chart.js react-chartjs-2
```

> Note: Framer-motion was already included in the project dependencies

================
File: docs/JOURNEY_UI_SPRINT3_IMPLEMENTATION_STATUS.md
================
# Journey UI Sprint 3 Implementation Status

This document tracks the implementation status of the Journey UI Sprint 3 enhancements aimed at improving the user experience with advanced interactivity and intelligence.

## Summary

Sprint 3 focuses on enhancing the journey map with intelligent recommendations, advanced interactions, better visualization, and AI-powered assistance. This phase builds upon the clean, intuitive foundation established in Sprint 2.

## Completed Components

### 1. Intelligent Recommendation Engine

- ✅ **Recommendation Service Enhancement**
  - Added advanced ML-based scoring algorithm with personalization
  - Implemented path optimization and relationship analysis
  - Added usage analytics tracking

- ✅ **Next Best Steps Component**
  - Implemented interactive card expansion for detailed information
  - Added filtering capability (quick wins, high impact, prerequisites)
  - Integrated time constraint filtering
  - Added keyboard navigation shortcuts
  - Implemented analytics tracking for recommendation impressions and selections

- ✅ **Step Relationship Map**
  - Implemented visualization of connections between steps
  - Color-coded relationships (prerequisites, dependencies, related)
  - Interactive navigation between connected steps

### 2. Drag-and-Drop Enhanced Interactions

- ✅ **DraggableStepCard Component**
  - Implemented motion animations for better interaction feedback
  - Added drag analytics tracking for user interaction insights
  - Enhanced accessibility with keyboard interaction

- ✅ **DraggableStepList Component**
  - Implemented reordering with detailed analytics
  - Added toast notifications for user feedback
  - Optimized drag-and-drop performance

### 3. Analytics Integration

- ✅ **RecommendationAnalytics Hook**
  - Implemented event tracking for recommendations
  - Added tracking for step selection events
  - Added tracking for relationship interactions
  - Added filtering event tracking

## Completed Components (continued)

### 4. Progress Analytics Dashboard

- ✅ **JourneyAnalyticsDashboard Component**
  - Interactive dashboard with completion rates, timeline visualization, and comparative analytics
  - Multiple view modes including Overview, Phase Progress, and Industry Comparison
  - Responsive charts for step completion, time estimation accuracy, and industry benchmarking
  - Integrated with Recommendation Service for data fetching

### 5. AI Assistant Integration

- ✅ **StepAssistant Component** 
  - Contextual help based on current step
  - Integration with knowledge base
  - Intelligent question suggestions
  - Resource recommendations
  - Interactive Q&A interface

## Upcoming Features

### 1. User Feedback System

- 📝 **InlineRatingComponent**
- 📝 **FeedbackCollectionService**
- 📝 **StepImprovementSuggestionForm**

### 2. Advanced Visualization

- 📝 **Interactive Journey Map**
- 📝 **Milestone Celebration Animations**
- 📝 **Advanced Progress Indicators**

## Technical Debt and Optimizations

1. Need to optimize rendering performance for large journey maps
2. Need to implement proper error boundaries for recommendation components
3. Consider implementing virtualization for large step lists

## Next Steps

1. ✅ Completed all Sprint 3 components
2. Begin implementation of the feedback collection system (Sprint 4)
3. Conduct user testing with the new components
4. Implement advanced visualization features (Sprint 4)
5. Address technical debt and optimizations identified during development
6. Perform performance testing with large datasets

## Notes

The recommendation system is now significantly more sophisticated, using multiple factors for scoring:
- Prerequisite completion (0-3 points)
- Industry relevance (0-2 points)
- Common next step patterns (0-2.5 points)
- Company stage relevance (0-1.5 points)
- Business model alignment (0-1 point)
- Similar company patterns (0-2 points)
- Focus area alignment (0-1.5 points)
- Time constraint compatibility (0-1 point)

This provides a much more personalized experience than the previous version, which only considered basic prerequisites and industry averages.

================
File: docs/JOURNEY_UI_SPRINT3_IMPLEMENTATION.md
================
# Journey UI Sprint 3 Implementation

This document outlines the implementation details of Sprint 3 of the Journey UI enhancement project, focusing on adding advanced interactive features and intelligent assistance.

## Components Implemented

### 1. Recommendation Engine

#### Database Components
- Created SQL functions for step recommendations and relationships:
  - `get_steps_by_industry_popularity`: Ranks steps by popularity within an industry
  - `get_common_step_sequences`: Identifies common next steps based on other companies' journeys
  - `journey_step_relationships`: View that maps connections between steps
  - `journey_step_recommendations`: View that provides personalized recommendations

#### Service Layer
- Implemented `RecommendationService` with methods:
  - `getRecommendations`: Calculates personalized step recommendations
  - `getStepRelationships`: Retrieves relationships between steps

#### UI Components
- **NextBestSteps**: Shows personalized step recommendations sorted by relevance
  - Displays reasoning behind recommendations
  - Shows difficulty and time estimates
  - Optimized loading state with skeleton animation
  - Interactive UI with hover and selection effects

- **StepRelationshipMap**: Visual representation of step relationships
  - Interactive node graph showing prerequisites and dependents
  - Color-coded relationship types
  - Animated transitions for better UX
  - Support for both simple and complex relationship networks

### 2. Core Utilities

- Created `time-utils.ts` with functions:
  - `formatTimeRange`: Formats time estimates in a human-readable way
  - `calculateTimeEstimate`: Generates time estimates from min/max values
  - `getCompletionEstimate`: Calculates remaining time based on progress
  - `formatDate` and `getRelativeTime`: Helper functions for date display

### 3. Migration Scripts

- Created comprehensive migration scripts:
  - `run-recommendation-system-migration.js`: Combined script for both migrations
  - Enhanced error reporting and validation
  - Database object verification to confirm successful migrations

## Technical Design Decisions

### Database Layer

1. **Progressive Enhancement Approach**
   - All database changes are implemented with safeguards to check for column existence
   - Views provide a consistent interface regardless of underlying schema changes
   - Functions encapsulate complex logic for better maintainability

2. **Performance Considerations**
   - Created views and materialized results for expensive calculations
   - Indexed common query patterns
   - Used JSON aggregation to reduce query count

3. **Data Enrichment**
   - Enhanced steps with additional metadata (difficulty, time estimates)
   - Added relationship tracking between steps
   - Implemented popularity metrics based on company behavior

### Frontend Architecture

1. **Component Design**
   - Used React's modern patterns including hooks and functional components
   - Separated concerns with clear component boundaries
   - Added proper TypeScript interfaces for all components

2. **UI/UX Considerations**
   - Implemented skeleton loaders for better perceived performance
   - Used animations for state transitions (Framer Motion)
   - Consistent color coding for relationship types and scores
   - Clear, informative tooltips and helper text

3. **Accessibility**
   - Ensured color contrast meets WCAG 2.1 standards
   - Provided keyboard navigation support
   - Used semantic HTML elements
   - Added screen reader support with aria attributes

## Integration with Existing System

The new components integrate seamlessly with the existing journey steps UI:

1. **Database Integration**
   - Enhanced existing tables rather than creating new ones
   - Used views for backward compatibility
   - Added functions that work with both old and new data structures

2. **UI Integration**
   - Components can be placed in multiple locations:
     - Inside step detail views
     - On dashboard widgets
     - Within the journey map interface
   - Consistent styling with the design system
   - Shared TypeScript interfaces with existing components

## Testing Strategy

1. **Database Testing**
   - Migration script includes verification steps
   - Checks for expected database objects after migration
   - Tests with sample data

2. **Component Testing**
   - Unit tests for individual components
   - Integration tests for component interactions
   - Browser compatibility tests

## Deployment Plan

1. **Database Migration**
   - Run `scripts/run-recommendation-system-migration.js`
   - Verify all database objects are created correctly
   - Run validation queries to ensure data integrity

2. **Frontend Deployment**
   - Regular build process with the new components
   - Gradual rollout with feature flags
   - Monitor performance and user feedback

## Future Enhancements

1. **Machine Learning Integration**
   - Replace rule-based scoring with ML model
   - Incorporate user feedback for improved recommendations
   - Add personalized difficulty estimates

2. **Enhanced Visualizations**
   - Add zooming and panning to relationship map
   - Implement heat maps for step popularity
   - Add timeline visualization

3. **Advanced Interactions**
   - Drag and drop for reordering steps
   - Custom step sequences
   - Keyboard shortcuts for power users

## Conclusion

Sprint 3 delivers a powerful recommendation system that enhances the journey experience by providing personalized guidance for users. The implementation balances technical sophistication with user experience considerations, resulting in a system that is both powerful and intuitive.

================
File: docs/JOURNEY_UI_SPRINT3_MOCKUPS.md
================
# Journey UI Sprint 3 - Design Mockups

This document provides visual mockups and design concepts for the key features planned for Sprint 3 of the Journey UI enhancement project.

## Intelligent Step Recommendations

![Intelligent Step Recommendations](https://via.placeholder.com/800x400?text=Intelligent+Step+Recommendations)

```mermaid
graph TD
    A[User Profile Data] --> D[Recommendation Engine]
    B[Company Progress] --> D
    C[Industry Benchmarks] --> D
    D --> E[Score & Rank Steps]
    E --> F[Next Best Steps Panel]
    E --> G[Affinity Map Visualization]
    F --> H[User Interface]
    G --> H
```

### Key Components:

1. **Next Best Steps Panel**
   ```
   ┌─────────────────────────────────────┐
   │ RECOMMENDED NEXT STEPS              │
   ├─────────────────────────────────────┤
   │ ★ Create Financial Projections      │
   │   High impact · 65% of startups do  │
   │   this next in your industry        │
   │                                     │
   │ ★ Develop Customer Acquisition Plan │
   │   Builds on your recent progress    │
   │   Est. 3 hours to complete          │
   │                                     │
   │ ★ Refine Your MVP Scope             │
   │   90% complete prerequisite steps   │
   │   Recommended by advisor Sarah T.   │
   └─────────────────────────────────────┘
   ```

2. **Step Affinity Visualization**
   ```
   ┌─────────────────────────────────────┐
   │ STEP RELATIONSHIPS                   │
   │                                     │
   │      Market       ┌───────┐         │
   │      Research ────┤ Value │         │
   │        │          │ Prop  │         │
   │        │          └───────┘         │
   │        ▼             │              │
   │    ┌───────┐         │              │
   │    │Customer│        ▼              │
   │    │Segments├──► Financial          │
   │    └───────┘     Projections        │
   │                                     │
   └─────────────────────────────────────┘
   ```

## Enhanced Interaction Capabilities

![Drag and Drop Functionality](https://via.placeholder.com/800x400?text=Drag+and+Drop+Journey+Steps)

### Draggable Step Cards:

```
┌─────────────────────────────────┐  ╔═══════════════════════════════╗
│ MARKET RESEARCH                 │  ║ CUSTOMER SEGMENTATION       ▼ ║
│ ●●●○○ Difficulty                │  ║ ●●●●○ Difficulty              ║
│ █████████░░ 90% Complete        │  ║ █████░░░░░ 50% Complete       ║
│ ⏱ Est: 4-6 hours                │  ║ ⏱ Est: 8-12 hours             ║
│                                 │  ║                               ║
│             [ More details ]    │  ║             [ More details ]  ║
└─────────────────────────────────┘  ╚═══════════════════════════════╝
                 │                                    ▲
                 │                                    │
                 │         ┌──────┐                   │
                 └─────────►MOVING◄───────────────────┘
                           └──────┘
```

### Keyboard Shortcuts Overlay:

```
┌─────────────────────────────────────────────┐
│ KEYBOARD SHORTCUTS                           │
├─────────────────────────────────────────────┤
│ Navigation:                                  │
│ ⇧+↑/↓   Navigate between steps               │
│ ⇧+→/←   Navigate between phases              │
│ Esc     Close current detail view            │
│                                              │
│ Actions:                                     │
│ ⌘+D     Mark step as complete                │
│ ⌘+N     Add note to current step             │
│ ⌘+S     Save current changes                 │
│ ⌘+Space Toggle step details                  │
│                                              │
│ Organization:                                │
│ ⌘+↑/↓   Move step up/down in sequence        │
│ ⌘+⇧+P   Pin step to dashboard                │
└─────────────────────────────────────────────┘
```

## Progress Analytics Dashboard

![Analytics Dashboard](https://via.placeholder.com/800x500?text=Journey+Progress+Analytics)

### Journey Progress Overview:

```
┌──────────────────────────────────────────────────────────────────┐
│ JOURNEY PROGRESS                                                  │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│ ■ Ideation Phase     ■ Validation Phase     ■ Growth Phase       │
│                                                                   │
│ █████████████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ │
│ 0%                    50%                   100%                  │
│                                                                   │
│ Phase Breakdown                    Time Investment               │
│ ┌────────────────────┐            ┌────────────────────┐         │
│ │ Growth      ██ 15% │            │ Customer Dev  ███  │         │
│ │ Validation  ███ 30%│            │ Product       ████ │         │
│ │ Ideation    █████ 55%           │ Financial     ██   │         │
│ └────────────────────┘            └────────────────────┘         │
│                                                                   │
│ Recent Milestones                                                │
│ ✓ Completed Customer Validation                                  │
│ ✓ Finalized MVP Feature Set                                      │
│ ✓ Established Pricing Strategy                                   │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

### Step Completion Analysis:

```
┌──────────────────────────────────────────────────────────────┐
│ STEP COMPLETION ANALYTICS                                     │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│ Average completion time by phase:                             │
│                                                               │
│ Ideation     ███████████████  14.5 days                       │
│ Validation   ██████████████████  18.2 days                    │
│ Growth       ████████  8.7 days                               │
│                                                               │
│ Your pace vs. industry average:                               │
│                                                               │
│ Your startup:     ███████████████                             │
│ Industry average: ██████████████████                          │
│                   0        10        20        30 days        │
│                                                               │
│ Bottleneck Detection:                                         │
│ ❗️ Financial Projections - Above avg time (overdue 5 days)   │
│ ❗️ Customer Acquisition - Stuck at 40% for 7 days            │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

## AI-Powered Step Assistant

![AI Step Assistant](https://via.placeholder.com/800x450?text=AI+Step+Assistant)

### Contextual Assistant Interface:

```
┌───────────────────────────────────────────────────────────────┐
│ AI ASSISTANT - FINANCIAL PROJECTIONS STEP                      │
├───────────────────────────────────────────────────────────────┤
│                                                                │
│ 🤖 Looking at your current progress, you need help with        │
│    creating revenue projections for your SaaS business.        │
│                                                                │
│ 💬 What specific aspect of financial projections are you       │
│    struggling with?                                            │
│                                                                │
│    [ ] Customer acquisition costs                              │
│    [ ] Monthly recurring revenue modeling                      │
│    [ ] Churn rate forecasting                                  │
│    [ ] Cash flow projections                                   │
│    [ ] Custom: ______________________________                  │
│                                                                │
│ 📚 RELEVANT RESOURCES:                                         │
│                                                                │
│  • SaaS Financial Projection Template                          │
│  • Video: Realistic Revenue Forecasting (4 min)                │
│  • Example: Financial Model from Similar Company               │
│  • Expert Advice: Sarah T. on B2B SaaS Pricing                 │
│                                                                │
│ 🔄 SUGGESTED NEXT ACTIONS:                                     │
│                                                                │
│  1. Fill out the projection template with initial numbers      │
│  2. Schedule a review with a financial mentor                  │
│  3. Integrate projections with your pitch deck                 │
│                                                                │
└───────────────────────────────────────────────────────────────┘
```

## User Feedback & Continuous Improvement

![Feedback Components](https://via.placeholder.com/800x400?text=User+Feedback+Components)

### Inline Rating Component:

```
┌─────────────────────────────────────────────────────────────┐
│ STEP COMPLETE: MARKET RESEARCH                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│ 🎉 Great job completing this step!                          │
│                                                              │
│ How helpful was this step in your startup journey?           │
│                                                              │
│ ○ Not helpful   ○ Somewhat   ● Very helpful   ○ Essential   │
│                                                              │
│ Was anything missing or could be improved?                   │
│ ┌──────────────────────────────────────────────────┐        │
│ │                                                   │        │
│ │ Could use more B2B specific resources...          │        │
│ │                                                   │        │
│ └──────────────────────────────────────────────────┘        │
│                                                              │
│              [ Submit Feedback ]  [ Skip ]                   │
└─────────────────────────────────────────────────────────────┘
```

### Community Insight Panel:

```
┌─────────────────────────────────────────────────────────────┐
│ COMMUNITY INSIGHTS: CUSTOMER SEGMENTATION                    │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│ 👥 145 startups completed this step recently                │
│                                                              │
│ Top insights shared:                                         │
│                                                              │
│ • "Start with psychographics, not just demographics"         │
│   - Alex K., Healthcare SaaS founder                         │
│                                                              │
│ • "We realized our initial segment was too broad"            │
│   - Maria T., FinTech startup                               │
│                                                              │
│ • "Created persona boards that we reference daily"           │
│   - Jamal R., EdTech founder                                │
│                                                              │
│ Resources others found helpful:                              │
│                                                              │
│ • Customer Development Interviews (89% recommended)          │
│ • Jobs-To-Be-Done Framework (75% recommended)               │
│ • Segmentation Workshop Template (68% recommended)           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Visual Theme & Design Language

The Sprint 3 enhancements will follow this visual design approach:

1. **Color Palette:**
   - Primary: #3366FF (Blue) - For primary actions and highlighted elements 
   - Secondary: #FF6B2B (Orange) - For calls to action and important notifications
   - Success: #2CC389 (Green) - For completion indicators and positive feedback
   - Warning: #FFB800 (Amber) - For attention-requiring elements
   - Neutral: #F4F7FA to #2B3647 (Grayscale range) - For background and text

2. **Typography:**
   - Headings: Inter (Bold) - Clean, modern sans-serif for headings
   - Body: Inter (Regular) - Consistent family for readable content
   - Monospace: Roboto Mono - For code snippets and technical content

3. **Component Design:**
   - Card-based layout with subtle shadows
   - 8px grid system for consistent spacing
   - Rounded corners (8px radius) for containers
   - Micro-interactions and subtle animations for state changes
   - Consistent iconography style throughout
  
4. **Accessibility Considerations:**
   - WCAG 2.1 AA compliant color contrast
   - Keyboard navigable interface with visible focus states
   - Screen reader optimized components with proper ARIA labels
   - Responsive design that works across device sizes

================
File: docs/JOURNEY_UI_SPRINT3_PLAN.md
================
# Journey UI Sprint 3 Plan: Advanced Interactivity & Intelligence

## Overview

Following the successful redesign of the Journey Steps UI in Sprint 2, Sprint 3 will focus on adding advanced interactive features and intelligent assistance to further enhance user engagement and productivity. This sprint will build on the clean, intuitive foundation established in Sprint 2 by incorporating features that make the journey experience more dynamic and personalized.

## Sprint Goals

1. Enhance user guidance through intelligent recommendations
2. Improve interactivity with drag-and-drop capabilities and keyboard shortcuts
3. Add data visualization for progress tracking and insights
4. Implement AI-powered assistance for step completion
5. Integrate user feedback mechanisms

## Key Features & Components

### 1. Intelligent Step Recommendations

**Description:** Implement an AI-powered system that suggests the most relevant next steps based on the company's profile, progress, industry, and similar companies' journeys.

**Components:**
- RecommendationEngine service
- "Next Best Step" component
- Personalized pathway algorithm
- Step affinity visualization

**Technical Requirements:**
- Implement ML model for step relevance scoring
- Create recommendation API endpoints
- Design UI components for displaying recommendations
- Track recommendation engagement metrics

### 2. Enhanced Interaction Capabilities 

**Description:** Add drag-and-drop functionality for reordering steps, keyboard shortcuts for power users, and interactive filters.

**Components:**
- DraggableStepCard component
- KeyboardShortcutManager service
- Enhanced filtering and sorting controls
- Custom step sequence manager

**Technical Requirements:**
- Implement drag-and-drop using React DnD or similar
- Create keyboard shortcut system with customization options
- Update database schema to support custom step sequences
- Add undo/redo capability for sequence changes

### 3. Progress Analytics Dashboard

**Description:** Create visualizations that help users understand their progress through the journey, highlighting accomplishments and identifying bottlenecks.

**Components:**
- JourneyAnalyticsDashboard component
- ProgressChart visualization components
- TimeSpentAnalysis service
- CompletionRateComparison component

**Technical Requirements:**
- Implement data aggregation services for analytics
- Create reusable chart components using D3.js or Chart.js
- Design printable/exportable reports
- Add milestone celebration animations

### 4. AI-Powered Step Assistant

**Description:** Integrate contextual AI assistance that helps users complete steps more effectively by providing relevant resources, answering questions, and offering guidance.

**Components:**
- StepAssistant component
- ContextualResourceFinder service
- AIQueryHandler service
- InlineGuidance component

**Technical Requirements:**
- Create conversational UI for assistant interactions
- Implement context-aware resource recommendation algorithm
- Design expandable/collapsible assistant panel
- Build knowledge base integration

### 5. User Feedback & Continuous Improvement

**Description:** Implement systems for gathering, analyzing, and acting on user feedback about the journey experience.

**Components:**
- InlineRatingComponent
- FeedbackCollectionService
- StepImprovementSuggestionForm
- CommunityInsightPanel

**Technical Requirements:**
- Create feedback collection database schema
- Implement feedback aggregation and analysis service
- Design admin dashboard for reviewing feedback
- Add automatic improvement suggestion routing

## Implementation Plan

### Week 1-2: Foundation and Core Components
- Set up data structures for recommendations and custom sequences
- Implement drag-and-drop functionality for steps
- Create basic analytics service and data collection
- Design AI assistant conversation flow

### Week 3-4: Feature Development
- Complete recommendation engine implementation
- Build analytics dashboard and visualizations
- Integrate AI assistant with knowledge base
- Implement keyboard shortcuts and power user features

### Week 5-6: Refinement and Integration
- Add feedback collection components
- Implement milestone celebrations and gamification
- Finalize all UI/UX details
- Conduct thorough testing and optimization

## Success Metrics

1. **Engagement**: 30% increase in time spent in journey section
2. **Efficiency**: 25% reduction in time to complete steps
3. **Satisfaction**: Average feedback rating of 4.5/5 or higher
4. **Personalization**: 80% of users utilizing custom step sequences
5. **Assistance**: 50% of users engaging with AI assistant

## Dependencies

1. AI recommendation model training data
2. User permission system for data collection
3. Integration with knowledge base system
4. Analytics infrastructure enhancements

## Risks and Mitigation

| Risk | Mitigation |
|------|------------|
| Recommendation quality issues | Start with rule-based recommendations, gradually integrate ML |
| Performance issues with drag-drop on large journeys | Implement virtualization and pagination |
| Low user adoption of advanced features | Create interactive tutorials and tooltips |
| Privacy concerns with data collection | Clear opt-in process and transparent data usage |

## Future Considerations

- Mobile app integration with journey features
- VR/AR visualization of journey progress
- Integration with external tools via API
- Community features to compare progress with peers
- Gamification system with achievements and rewards

================
File: docs/JOURNEY_UI_SPRINT4_COMPLETION.md
================
# Journey UI/UX Sprint 4 Completion Report

## Overview

Sprint 4 focused on implementing a comprehensive UI/UX refresh for the journey map, steps, and tools section of The Wheel platform. The primary goal was to simplify the user experience while maintaining all functionality, making the journey section more intuitive and user-friendly.

## Sprint 4 Deliverables Status

| Component | Status | Notes |
|-----------|--------|-------|
| Interactive Journey Map | ✅ Complete | Core visualization with zoom/pan functionality implemented |
| Milestone Celebration Animations | ✅ Complete | Celebration effects with confetti for different achievement types |
| Feedback Collection System | ✅ Complete | Rating component and improvement suggestion forms |
| Supporting UI Components | ✅ Complete | Tooltip and other helper components |
| Documentation | ✅ Complete | Comprehensive implementation docs and examples |
| Integration Examples | ✅ Complete | Example implementations provided |

## Implementation Details

### Core Components Completed

1. **Interactive Journey Map (`InteractiveJourneyMap.tsx`)**
   - Zoomable, pannable visualization
   - Relationship visualization between steps
   - Color-coded status indicators
   - Highlight for current step

2. **Milestone Celebration Animations (`MilestoneCelebrationAnimation.tsx`)**
   - Visual feedback and celebration effects
   - Different animation styles for completion, achievements, and progress
   - Confetti effects and customizable messaging

3. **Feedback Collection System**
   - `InlineRatingComponent`: Quick star ratings with comments
   - `StepImprovementSuggestionForm`: Detailed improvement suggestions

4. **Documentation and Examples**
   - Comprehensive implementation documentation
   - Example integration patterns

## Pending Items for Final Sprint Completion

While all core development has been completed, the following items are typically part of a sprint's final phase and would need to be addressed before marking Sprint 4 as 100% complete:

### User Testing and Feedback Collection

- [ ] Conduct usability testing with representative users
- [ ] Collect and analyze feedback
- [ ] Document usability findings

### Performance Optimization

- [ ] Conduct performance testing under load
- [ ] Optimize rendering for larger journey maps
- [ ] Implement lazy loading for components as needed

### Accessibility Improvements

- [ ] Complete keyboard navigation testing
- [ ] Verify screen reader compatibility
- [ ] Ensure color contrast compliance
- [ ] Test focus management

### Final QA and Bug Fixes

- [ ] Complete cross-browser testing
- [ ] Run final regression tests
- [ ] Fix any identified bugs

## Recommendations for Sprint Closeout

To officially complete Sprint 4, we recommend the following steps:

1. Schedule user testing sessions to validate the new UI/UX
2. Address any critical issues identified in testing
3. Complete the accessibility review
4. Conduct a final team review of all components
5. Deploy to a staging environment for broader testing
6. Prepare a demo for stakeholders showcasing the improvements

## Conclusion

Sprint 4 development is substantially complete, with all core components implemented according to the requirements. The UI/UX refresh has successfully addressed the issues of clutter and user-unfriendliness in the journey section.

The implementation provides three distinct approaches that prioritize simplicity, discoverability, and engagement, making the journey section more intuitive while maintaining all functionality.

With the completion of the pending items outlined above, Sprint 4 can be officially marked as complete and ready for deployment to production.

================
File: docs/JOURNEY_UI_SPRINT4_PLAN.md
================
# Journey UI Sprint 4 Plan - User Feedback & Advanced Visualization

## Overview

Sprint 4 builds upon the successful implementation of the intelligent recommendations, analytics dashboard, and AI-powered assistance from Sprint 3. This sprint focuses on two main areas:

1. User Feedback Collection System
2. Advanced Journey Visualization Features

These enhancements will complete the user experience improvements for the journey map, making it more interactive, informative, and responsive to user needs.

## Timeline

- Sprint Duration: 2 weeks
- Start Date: May 5, 2025
- End Date: May 19, 2025

## User Feedback Collection System

### Components to Implement

#### 1. InlineRatingComponent
- **Purpose**: Allow users to rate steps, tools, and resources directly within the interface
- **Features**:
  - Star rating system (1-5 stars)
  - Optional comment field
  - Analytics tracking for ratings
  - User-specific rating history
- **Integration Points**:
  - Step details page
  - Tool recommendation cards
  - Resource links

#### 2. FeedbackCollectionService
- **Purpose**: Centralized service for storing, retrieving, and analyzing user feedback
- **Features**:
  - Storage of ratings, comments, and timestamps
  - Aggregation of feedback across users and companies
  - Feedback trends analysis
  - Integration with recommendation engine to improve suggestions
- **Technical Requirements**:
  - Database schema updates
  - RPC functions for feedback operations
  - Analytics integration

#### 3. StepImprovementSuggestionForm
- **Purpose**: Allow users to suggest improvements to steps, tools, and resources
- **Features**:
  - Structured suggestion form
  - Category selection
  - Impact description
  - Status tracking of suggestions
  - Voting on suggestions from other users
- **Integration Points**:
  - Step details page
  - Journey map overview
  - Admin panel for reviewing suggestions

### Database Changes

```sql
-- Feedback table
CREATE TABLE feedback (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users NOT NULL,
  company_id UUID REFERENCES companies,
  entity_type VARCHAR(50) NOT NULL, -- 'step', 'tool', 'resource', etc.
  entity_id UUID NOT NULL,
  rating INTEGER CHECK (rating BETWEEN 1 AND 5),
  comment TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Improvement suggestions table
CREATE TABLE improvement_suggestions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users NOT NULL,
  company_id UUID REFERENCES companies,
  entity_type VARCHAR(50) NOT NULL, -- 'step', 'tool', 'resource', etc.
  entity_id UUID NOT NULL,
  category VARCHAR(50) NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  impact_description TEXT,
  status VARCHAR(50) DEFAULT 'pending',
  votes INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Votes on suggestions
CREATE TABLE suggestion_votes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  suggestion_id UUID REFERENCES improvement_suggestions NOT NULL,
  user_id UUID REFERENCES auth.users NOT NULL,
  vote_type VARCHAR(10) NOT NULL, -- 'up' or 'down'
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(suggestion_id, user_id)
);
```

## Advanced Journey Visualization

### Components to Implement

#### 1. InteractiveJourneyMap
- **Purpose**: Provide a visually rich, interactive map of the company's journey
- **Features**:
  - Zoomable/pannable interface
  - Path visualization
  - Multi-level detail
  - Color coding for status and categories
  - Connection lines showing dependencies
- **Technical Requirements**:
  - SVG or Canvas-based rendering
  - React state management for interactions
  - Responsive layout

#### 2. MilestoneCelebrationAnimations
- **Purpose**: Celebrate user accomplishments with visual feedback
- **Features**:
  - Confetti animations for completed milestones
  - Achievement badges
  - Notification system for team celebrations
  - Progress milestones with custom animations
- **Technical Requirements**:
  - Animation libraries (framer-motion, lottie)
  - Achievement tracking system
  - Notification integration

#### 3. AdvancedProgressIndicators
- **Purpose**: Provide more detailed and contextual progress information
- **Features**:
  - Multi-dimensional progress bars
  - Predictive completion estimates
  - Comparative progress (vs. industry)
  - Micro-progress tracking within steps
- **Technical Requirements**:
  - Custom progress visualization components
  - Data aggregation for comparisons
  - Time estimation algorithms

### UI/UX Considerations

1. **Accessibility**
   - All animations must be optional
   - Color schemes must meet WCAG 2.1 AA standards
   - Keyboard navigation for all interactive elements

2. **Performance**
   - Lazy loading for animation assets
   - Component virtualization for large journey maps
   - Debounced event handlers for interactions

3. **Mobile Responsiveness**
   - Adaptable layouts for small screens
   - Touch-friendly interactions
   - Reduced animation complexity on low-power devices

## Integration with Previous Sprint Work

- The feedback system will integrate with the StepAssistant to improve AI recommendations
- User ratings will influence recommendation scoring in the recommendation engine
- Celebration animations will trigger based on analytics events tracked in Sprint 3
- Progress indicators will use data from the JourneyAnalyticsDashboard
- The InteractiveJourneyMap will build on the StepRelationshipMap visualization

## Metrics for Success

1. **User Engagement**
   - Increase in time spent on journey pages
   - Higher interaction rate with steps and tools
   - Reduced bounce rate from journey pages

2. **Feedback Collection**
   - Number of ratings submitted
   - Quality of improvement suggestions
   - Actionable insights generated from feedback

3. **Visualization Effectiveness**
   - Task completion rate improvement
   - Reduction in "lost" user sessions
   - Positive feedback on visualization clarity

## Technical Considerations

- Use virtualization for rendering large collections (suggestions, feedback items)
- Implement proper client-side caching to reduce API calls
- Ensure animations are performant across device types
- Add appropriate error boundaries around new components
- Implement analytics tracking for all user interactions

## Next Steps After Sprint 4

- Machine learning-based recommendations using collected feedback
- A/B testing of different visualization approaches
- Social features (team collaboration, sharing achievements)
- Integration with external productivity tools

================
File: docs/JOURNEY_UI_SPRINT5_PLAN.md
================
# Journey UI/UX Sprint 5 Planning Document

## Overview

Following the successful implementation of the UI/UX refresh in Sprint 4, Sprint 5 will focus on enhancing the user experience through advanced features, analytics, and personalization. This sprint builds upon the foundation established in Sprint 4 and aims to further improve user engagement and satisfaction.

## Sprint 5 Goals

1. Implement advanced analytics and insights for journey progress
2. Develop personalized recommendations based on user behavior
3. Create collaborative features for team journey management
4. Enhance mobile and tablet experiences
5. Implement accessibility improvements identified in Sprint 4

## Key Deliverables

### 1. Advanced Journey Analytics

| Feature | Description | Priority |
|---------|-------------|----------|
| Progress Dashboard | Interactive dashboard showing completion rates, time spent, and bottlenecks | High |
| Journey Insights | AI-generated insights about user progress and recommendations | Medium |
| Comparison Tools | Compare journey progress against benchmarks or similar companies | Medium |
| Export Capabilities | Export journey data and reports in various formats | Low |

#### Technical Components:
- `JourneyAnalyticsDashboard` component with filtering and visualization options
- Data aggregation services for performance optimization
- Chart and graph visualization library integration

### 2. Personalized Journey Experience

| Feature | Description | Priority |
|---------|-------------|----------|
| Personalized Step Recommendations | AI-powered recommendations based on user behavior and company profile | High |
| Custom Journey Paths | Allow users to customize their journey based on business needs | High |
| Smart Notifications | Context-aware notifications about journey progress | Medium |
| User Preferences | Remember and apply user viewing preferences | Medium |

#### Technical Components:
- Machine learning integration for recommendation engine
- User preference service and storage
- Custom notification system

### 3. Collaborative Journey Management

| Feature | Description | Priority |
|---------|-------------|----------|
| Team Assignments | Assign steps to team members with tracking | High |
| Collaborative Notes | Shared notes and comments on steps | High |
| Activity Feed | Real-time feed of journey activities and updates | Medium |
| Integration with Communication Tools | Slack/Teams integration for notifications | Low |

#### Technical Components:
- Real-time collaboration system using WebSockets
- Permission management for collaborative features
- Activity tracking and notification system

### 4. Mobile and Tablet Optimization

| Feature | Description | Priority |
|---------|-------------|----------|
| Responsive Journey Map | Optimize interactive map for touch devices | High |
| Touch-Friendly Controls | Redesigned controls for mobile interaction | High |
| Offline Capabilities | Basic offline functionality for viewing journey information | Medium |
| Native App Features | Utilize device capabilities (camera, notifications) | Low |

#### Technical Components:
- Touch event handling system
- Responsive design framework enhancements
- Service workers for offline capabilities

### 5. Accessibility Enhancements

| Feature | Description | Priority |
|---------|-------------|----------|
| Keyboard Navigation | Complete keyboard control for all journey features | High |
| Screen Reader Optimization | Enhanced ARIA attributes and screen reader testing | High |
| Color Contrast Improvements | Address any contrast issues identified in testing | Medium |
| Cognitive Accessibility | Simplify complex interactions for users with cognitive disabilities | Medium |

#### Technical Components:
- Keyboard navigation system
- ARIA attribute enhancement
- Accessibility testing framework

## Technical Architecture

### New Components

1. **Analytics and Insights**
   - `JourneyAnalyticsDashboard.tsx`
   - `ProgressVisualization.tsx`
   - `InsightCard.tsx`
   - `ComparisonTool.tsx`

2. **Personalization**
   - `PersonalizedRecommendations.tsx`
   - `CustomPathBuilder.tsx`
   - `SmartNotification.tsx`
   - `UserPreferencesPanel.tsx`

3. **Collaboration**
   - `TeamAssignmentPanel.tsx`
   - `CollaborativeNotes.tsx`
   - `ActivityFeed.tsx`
   - `IntegrationPanel.tsx`

4. **Services**
   - `journeyAnalytics.service.ts`
   - `personalizationEngine.service.ts`
   - `collaboration.service.ts`
   - `deviceOptimization.service.ts`

### Database Changes

1. **New Tables**
   - `journey_analytics`
   - `user_preferences`
   - `team_assignments`
   - `collaborative_notes`
   - `activity_logs`

2. **Schema Updates**
   - Add collaboration fields to `journey_steps`
   - Add personalization fields to `company_profiles`
   - Add analytics tracking fields to various tables

## Integration with Existing Components

The Sprint 5 features will build upon the components developed in Sprint 4:

1. The `InteractiveJourneyMap` will be enhanced with collaboration features and mobile optimization
2. The `MilestoneCelebrationAnimation` will integrate with the personalization engine
3. The feedback system will feed into the analytics dashboard
4. The notification system will leverage the UI design established in Sprint 4

## User Testing and Validation

1. **Pre-Development Testing**
   - Conduct user interviews and concept testing for new features
   - Create prototypes of key interactions for validation

2. **Mid-Sprint Testing**
   - Usability testing of partially implemented features
   - A/B testing of different personalization approaches

3. **End-of-Sprint Validation**
   - Comprehensive usability testing across devices
   - Performance and load testing of analytical features
   - Accessibility compliance testing

## Implementation Approach

The implementation will follow a phased approach similar to Sprint 4:

1. **Phase 1: Foundation (Week 1)**
   - Core services and database schema updates
   - Base components for each feature area

2. **Phase 2: Feature Development (Weeks 2-3)**
   - Implementation of high-priority features
   - Integration with existing components
   - Initial mobile optimization

3. **Phase 3: Refinement and Testing (Week 4)**
   - Completion of medium-priority features
   - User testing and feedback collection
   - Performance optimization
   - Accessibility improvements

## Risk Management

| Risk | Mitigation Strategy |
|------|---------------------|
| Performance impact of analytics features | Implement data aggregation and caching strategies |
| Complexity of personalization engine | Start with simple rule-based system, iterate toward ML-based approach |
| Mobile UI complexity | Begin with core experience optimization, add advanced features incrementally |
| Real-time collaboration challenges | Use established libraries, implement conflict resolution strategies |
| Accessibility edge cases | Partner with accessibility experts for testing and validation |

## Definition of Done

A feature will be considered complete when:

1. It passes all automated tests (unit, integration, e2e)
2. It has been reviewed by at least two team members
3. It meets accessibility standards (WCAG 2.1 AA)
4. It performs well on all target devices and browsers
5. It has been validated by user testing
6. It includes appropriate documentation

## Sprint 5 Timeline

| Week | Focus Areas |
|------|-------------|
| Week 1 | Database schema updates, core services, foundation components |
| Week 2 | Analytics dashboard, personalization engine, collaboration basics |
| Week 3 | Mobile optimization, feature completion, integration |
| Week 4 | Testing, refinement, accessibility improvements, documentation |

## Conclusion

Sprint 5 builds upon the successful UI/UX refresh of Sprint 4 by adding advanced features that enhance user engagement, provide valuable insights, and enable collaboration. The focus on analytics, personalization, and mobile optimization will further improve the user experience while maintaining the simplicity and intuitiveness established in the previous sprint.

By the end of Sprint 5, The Wheel platform will offer a more personalized, collaborative, and insightful journey experience that adapts to each company's unique needs while providing valuable data-driven guidance.

================
File: docs/JOURNEY_UI_UX_REFRESH_SUMMARY.md
================
# Journey Map & Tools UX Refresh Summary

## Overview

This document summarizes the UX improvements implemented for the journey map section, focusing on making it more intuitive and user-friendly while maintaining its full functionality.

## Implemented Components

### 1. Analytics Dashboard
We've implemented a comprehensive analytics dashboard that provides users with:
- Visual progress tracking across their journey
- Phase completion statistics
- Comparison with industry benchmarks
- Time estimation accuracy visualization

The dashboard is accessible through the "Timeline" view in the Journey Map page, offering a more intuitive way to understand progress and performance compared to the previous text-heavy approach.

### 2. Enhanced Step Interactions
We've improved the step interaction components:
- Added drag-and-drop functionality with visual feedback
- Implemented analytics tracking for better understanding of user behavior
- Added toast notifications for immediate feedback on actions
- Enhanced accessibility with keyboard navigation support

### 3. Recommendation System
The recommendation system has been enhanced with:
- More personalized recommendations based on company context
- Clear visual separation of different recommendation types (quick wins, high impact, etc.)
- Improved relationship visualization between steps

## Existing Issues Addressed

1. **Visual Complexity**: Replaced cluttered UI with clean, tab-based navigation and card-based components
2. **Information Overload**: Implemented progressive disclosure patterns to show relevant information at the right time
3. **Unclear Navigation**: Added clear visual indicators for current location and available actions
4. **Performance Issues**: Optimized rendering for large journey maps

## Future UX Enhancement Recommendations

Based on our implementation, here are three distinct options for further UX improvements:

### Option 1: Task-Oriented Interface

**Concept**: Reorganize the journey map around tasks rather than chronological steps.

**Implementation Details**:
- Group journey steps into task categories (e.g., "Legal Setup", "Marketing", "Finance")
- Add task completion tracking with visual progress indicators
- Create task dependencies visualization
- Implement task prioritization based on company goals

**Benefits**:
- Aligns journey with how users think about their business activities
- Makes it easier to delegate work to team members by category
- Provides clear focus on what matters most right now

**Example UI Components**:
- Task Category Cards with filterable views
- Team Assignment Module
- Priority Queue visualization

### Option 2: Adaptive Timeline Interface

**Concept**: Create a dynamic timeline that adjusts based on company stage and progress.

**Implementation Details**:
- Implement an AI-powered adaptive timeline that emphasizes relevant phases
- Add milestone celebrations and achievements
- Create "past/present/future" visualization modes
- Integrate predictive analytics to suggest timeline adjustments

**Benefits**:
- Provides contextual focus based on current company needs
- Celebrates progress to improve motivation
- Helps with realistic planning and expectation setting

**Example UI Components**:
- Interactive Timeline with zoom capabilities
- Milestone Achievement Cards
- Predictive Path Visualization
- Contextual Phase Focus

### Option 3: Guided Journey Experience

**Concept**: Transform the journey map into a guided experience with focused workflows.

**Implementation Details**:
- Create step-by-step wizards for completing journey phases
- Implement a digital assistant that provides contextual guidance
- Add learning resources directly integrated with each step
- Implement "quick win" paths for immediate value

**Benefits**:
- Reduces cognitive load by focusing on one step at a time
- Provides built-in education and guidance
- Creates a sense of accomplishment with frequent small wins

**Example UI Components**:
- Step Assistant Panel with AI-powered recommendations
- Contextual Resource Library
- Quick Win Paths
- Step-by-Step Completion Wizards

## Technical Implementation Notes

1. **Component Architecture**: We've organized components into logical groups (Analytics, StepRecommendations, etc.) for better maintainability.

2. **Data Model**: Enhanced the data model to support richer analytics and tracking capabilities.

3. **Performance Optimizations**: 
   - Used virtualization for rendering large lists
   - Implemented lazy loading for analytics data
   - Added proper memoization to prevent unnecessary renders

4. **Accessibility**: 
   - Ensured keyboard navigation throughout the journey map
   - Added appropriate ARIA labels
   - Implemented proper focus management

## Conclusion

The journey map UX has been significantly improved through a combination of visual enhancements, better organization, and more intuitive interaction patterns. The implemented changes address the core issues of complexity and usability while maintaining all the powerful functionality needed by users.

The recommendations provided offer three distinct paths forward for further enhancing the experience, each with its own focus and benefits. These options can be evaluated based on user feedback and business priorities to determine the next phase of UX improvements.

By continuing to refine and enhance the journey experience, we can create a more engaging, intuitive, and valuable tool for companies at every stage of their growth journey.

================
File: docs/JOURNEY_UX_REDESIGN_CONCEPTS.md
================
# Journey Map UX Redesign Concepts

## Introduction

The current journey map and its associated pages have been identified as being cluttered and not user-friendly. While powerful in functionality, the UI needs significant improvements to enhance usability and comprehension.

This document outlines three distinct approaches to redesigning the journey map section, focusing on making it simpler while maintaining its powerful functionality.

## Concept 1: Card-Based Modular Interface

![Card-Based Concept](https://placeholder.com/journey-card-concept.png)

### Overview
A modular card-based interface that breaks down the journey into visually distinct components that can be rearranged, collapsed, and expanded.

### Key Features

1. **Collapsible Cards**: Each step is represented as a card that can be expanded to show details or collapsed to save space.

2. **Drag-and-Drop Organization**: Users can rearrange steps through intuitive drag-and-drop functionality (already implemented).

3. **Visual Progress Indicators**: Clear visual indicators for completion status, with an overall progress bar for each phase.

4. **Tool Integration Sidebar**: Tools related to each step appear in a sidebar that slides in contextually, rather than cluttering the main view.

5. **Focus Mode**: Users can focus on a single step by maximizing its card, dimming everything else.

### Benefits

- Reduces visual complexity by compartmentalizing information
- Gives users control over what information is visible
- Provides clear visual hierarchy
- Enhances mobile responsiveness
- Better accommodates varying amounts of content per step

## Concept 2: Timeline-Inspired Journey Visualization

![Timeline Concept](https://placeholder.com/journey-timeline-concept.png)

### Overview
Reimagines the journey map as an interactive timeline with branching paths, drawing inspiration from project management tools like Gantt charts.

### Key Features

1. **Horizontal Timeline**: Primary steps appear along a horizontal timeline, with optional steps branching vertically.

2. **Dependency Visualization**: Shows relationships between steps, indicating when one step depends on completion of another.

3. **Zooming Capability**: Users can zoom in to see details or zoom out to see the big picture.

4. **Milestone Markers**: Important milestones are visually distinct from regular steps.

5. **Contextual Tools Panel**: Tools appear in a panel when hovering over or selecting a step.

6. **Parallel Paths**: Visualizes when multiple steps can be completed in parallel.

### Benefits

- Provides a clear visualization of the entire journey at once
- Shows relationships between steps
- Gives context about where the company is in the overall process
- Better communicates timeframes and dependencies
- Allows for more intuitive navigation between related steps

## Concept 3: Guided Wizard Experience

![Wizard Concept](https://placeholder.com/journey-wizard-concept.png)

### Overview
Transforms the journey map into a guided experience that focuses users on one step at a time, with clear direction on what to do next.

### Key Features

1. **Next Best Action**: Always prominently displays the recommended next step based on company progress.

2. **Step-by-Step Guidance**: Provides contextual help and resources for the current step.

3. **Minimal Interface**: Shows only what's needed for the current task, reducing cognitive load.

4. **Progressive Disclosure**: Information is revealed progressively as users advance.

5. **Quick Access Panel**: Provides an overview panel that can be opened to see progress and jump to other steps.

6. **Intuitive Transitions**: Smooth transitions between steps with visual cues about the relationship.

### Benefits

- Drastically reduces complexity by focusing on one thing at a time
- Particularly beneficial for new users who may be overwhelmed
- Provides clear guidance on what to do next
- Reduces decision fatigue
- Still allows advanced users to jump around via the overview panel

## Implementation Considerations

For all three concepts, we've already begun implementing key components:

1. **Drag-and-Drop System**: We've successfully integrated this feature, which will be a foundation for the card-based interface.

2. **DragDropProvider**: The application-wide provider we've implemented can be leveraged for all concepts.

3. **Component Architecture**: Our modular component approach allows for flexible implementation of any of these concepts.

## Recommendation

We recommend beginning with Concept 1 (Card-Based Modular Interface) as it:

1. Builds directly on our already-implemented drag-and-drop functionality
2. Provides a significant improvement in usability while requiring moderate development effort
3. Can be implemented incrementally, with immediate improvements visible after each sprint
4. Maintains compatibility with existing data structures

Once Concept 1 is implemented, we can evaluate whether to incorporate elements from Concepts 2 and 3 in future iterations.

================
File: docs/JOURNEY_UX_REFRESH_IMPLEMENTATION.md
================
# Journey Map UI/UX Refresh Implementation

This document outlines the implementation of the UI/UX refresh for the journey map, steps, and tools section of The Wheel platform. The refresh simplifies the user experience while maintaining all functionality, making the journey section more intuitive and user-friendly.

## Overview

The journey section's UI/UX has been completely reimagined with three distinct approaches that prioritize:

1. **Simplicity**: Reducing visual clutter and focusing on essential information
2. **Discoverability**: Making features more accessible and easier to find
3. **Engagement**: Creating a more interactive and visually appealing experience

## Implementation Components

The refresh includes several key components that work together to create a cohesive and intuitive user experience:

### 1. Interactive Journey Map

The `InteractiveJourneyMap` component provides a zoomable, pannable visualization of the company's journey, showing phases, steps, and their relationships. Users can interact with the map to navigate through their journey, zoom in to focus on specific areas, and click on steps to view details.

Key features:
- Zoom and pan controls
- Relationship visualization between steps
- Color-coded status indicators
- Highlight for the current step

Location: `src/components/visualization/InteractiveJourneyMap.tsx`

### 2. Milestone Celebration Animations

The `MilestoneCelebrationAnimation` component adds visual feedback and celebration effects when users complete steps or reach important milestones. This enhances engagement and provides positive reinforcement.

Key features:
- Custom animations for different achievement types (completion, achievement, progress)
- Confetti effects
- Customizable messaging
- Automatic or manual dismissal

Location: `src/components/visualization/MilestoneCelebrationAnimation.tsx`

### 3. Feedback Collection System

The feedback system allows users to rate steps and tools, and provide detailed improvement suggestions. This helps collect valuable user insights while also making users feel more engaged with the platform.

Components:
- `InlineRatingComponent`: For quick star ratings with optional comments
- `StepImprovementSuggestionForm`: For detailed improvement suggestions

Locations:
- `src/components/feedback/InlineRatingComponent.tsx`
- `src/components/feedback/StepImprovementSuggestionForm.tsx`

### 4. Enhanced Step Cards

Redesigned step cards that provide clear, concise information at a glance, with visual indicators for status, difficulty, and estimated time.

Components:
- `StepCard`: Base component for displaying step information
- `DraggableStepCard`: Enhanced version that supports drag-and-drop for reordering

Locations:
- `src/components/company/journey/StepCard/StepCard.tsx`
- `src/components/company/journey/StepCard/DraggableStepCard.tsx`

## UI/UX Design Concepts

### Concept 1: Card-Based Navigation

![Card-Based Navigation Concept](https://via.placeholder.com/800x400?text=Card-Based+Navigation+Concept)

**Implementation Details:**
- Steps are presented as cards in a horizontal scrolling container
- Cards show key information: title, status, difficulty, estimated time
- Cards use visual cues (colors, icons) to indicate status and relationships
- Clicking a card expands it to show more details and options

**Benefits:**
- Reduces visual clutter
- Provides clear focus on one step at a time
- Maintains context through visual positioning
- Supports both sequential and non-linear journeys

### Concept 2: Workflow-Oriented Interface

![Workflow-Oriented Interface Concept](https://via.placeholder.com/800x400?text=Workflow-Oriented+Interface+Concept)

**Implementation Details:**
- Journey is presented as a workflow with clearly defined phases
- Steps within each phase are shown as connected nodes
- Users can expand/collapse phases to focus on relevant sections
- Tool recommendations appear contextually based on current step

**Benefits:**
- Creates a clear sense of progress and direction
- Emphasizes relationships between steps
- Provides contextual tool recommendations
- Supports both overview and detailed views

### Concept 3: Dashboard Approach

![Dashboard Approach Concept](https://via.placeholder.com/800x400?text=Dashboard+Approach+Concept)

**Implementation Details:**
- Journey is visualized as an interactive dashboard
- Main view shows a visual map of all steps and phases
- Secondary panels show details, tools, and recommendations
- Dashboard adapts to show relevant information based on context

**Benefits:**
- Provides comprehensive overview and detailed information simultaneously
- Supports different working styles (visual vs. text-based)
- Scales well for complex journeys
- Enables quick navigation between related steps

## Key UX Improvements

### 1. Simplified Navigation

- **Before:** Complex, nested navigation requiring multiple clicks to access different sections
- **After:** Intuitive, visual navigation that provides clear pathways through the journey

### 2. Contextual Tool Recommendations

- **Before:** Tools presented in a separate section with limited connection to steps
- **After:** Tools recommended contextually based on the current step, with clear explanations of relevance

### 3. Visual Progress Tracking

- **Before:** Text-based progress indicators buried in the interface
- **After:** Visual progress tracking that shows completion status at a glance

### 4. Interactive Feedback

- **Before:** Limited feedback options hidden in menus
- **After:** Integrated feedback collection with ratings and suggestion forms

### 5. Celebration of Achievements

- **Before:** Milestone completion acknowledged with basic notifications
- **After:** Engaging celebrations with animations and positive reinforcement

## Implementation Approach

The implementation follows a phased approach:

1. **Phase 1: Core Components**
   - Development of key visualization and interaction components
   - Implementation of the feedback system

2. **Phase 2: Integration**
   - Integration of components into the existing journey system
   - Implementation of data flow between components

3. **Phase 3: Refinement**
   - User testing and feedback collection
   - Performance optimization
   - Accessibility improvements

## Technical Considerations

### Performance

- Virtualization for large journey maps
- Deferred loading of non-essential components
- Optimized rendering with React.memo and useCallback

### Accessibility

- Keyboard navigation support
- Screen reader compatibility
- Color contrast compliance
- Focus management

### Mobile Responsiveness

- Adaptive layouts for different screen sizes
- Touch-friendly interactions
- Simplified views for small screens

## Usage Examples

Example implementations can be found in:

1. `docs/examples/FeedbackSystemIntegration.tsx`
2. `docs/examples/AdvancedVisualizationExample.tsx`

These examples demonstrate how to integrate the various components into a cohesive user experience.

## Conclusion

The UI/UX refresh for the journey map, steps, and tools section significantly improves the user experience while maintaining all existing functionality. By focusing on simplicity, discoverability, and engagement, the new design makes the journey section more intuitive and user-friendly, helping users navigate their entrepreneurial journey more effectively.

The modular nature of the implementation allows for future enhancements and customizations while providing a solid foundation for the current needs of The Wheel platform.

================
File: docs/MULTI_TENANT_TERMINOLOGY_SYSTEM.md
================
# Multi-Tenant Terminology System

## Overview

The Multi-Tenant Terminology System provides a comprehensive, future-proof solution for customizing terminology across multiple organizational levels. This system allows for complete white-labeling capabilities, with terminology inheritance flowing from system defaults down through various organizational levels to individual users.

## Key Features

- **Hierarchical Terminology Inheritance**: Terminology flows from system defaults through partners, organizations, companies, teams, and finally to individual users
- **White Label Support**: Complete customization for partner-branded platforms
- **Multi-Language Support**: Built-in internationalization capabilities
- **Consistency Tools**: Validation to ensure terminology remains coherent
- **React Integration**: Seamless integration with React components through context providers and hooks

## Terminology Hierarchy

Terminology is defined and inherited through a hierarchy of levels, with each level able to override or extend terminology from higher levels:

1. **System Default**: Base terminology provided by The Wheel
2. **Partner Level**: Customizations for white-label partners
3. **Organization Level**: Settings for VCs, studios, or parent organizations
4. **Company Level**: Company-specific terminology
5. **Team Level**: Team-specific terminology
6. **User Level**: Individual user preferences

## Data Model

The system uses a structured data model to store terminology at different levels:

```sql
-- System-wide default terminology
CREATE TABLE terminology_defaults (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  description TEXT
);

-- Partner-level terminology (for white labeling)
CREATE TABLE partner_terminology (
  partner_id UUID REFERENCES partners(id),
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace', -- 'replace', 'merge', 'suggest'
  PRIMARY KEY (partner_id, key)
);

-- Organization-level terminology (for VCs, Studios, etc.)
CREATE TABLE organization_terminology (
  organization_id UUID REFERENCES organizations(id),
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace',
  PRIMARY KEY (organization_id, key)
);

-- Company-level terminology
CREATE TABLE company_terminology (
  company_id UUID REFERENCES companies(id),
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace',
  PRIMARY KEY (company_id, key)
);

-- Team-level terminology
CREATE TABLE team_terminology (
  team_id UUID REFERENCES teams(id),
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace',
  PRIMARY KEY (team_id, key)
);

-- User-level terminology preferences
CREATE TABLE user_terminology_preferences (
  user_id UUID REFERENCES users(id),
  key TEXT,
  value JSONB NOT NULL,
  PRIMARY KEY (user_id, key)
);

-- White label configuration
CREATE TABLE white_label_configuration (
  partner_id UUID REFERENCES partners(id) PRIMARY KEY,
  terminology_settings JSONB,
  branding_settings JSONB,
  domain_settings JSONB,
  feature_toggles JSONB
);
```

## Type System

The terminology system uses a comprehensive type system to ensure consistency:

```typescript
export enum TerminologyLevel {
  USER = 1,
  TEAM = 2,
  COMPANY = 3,
  ORGANIZATION = 4, // Parent org like a VC/Studio
  PARTNER = 5,      // White label partner
  SYSTEM = 6        // System defaults
}

export interface BaseTerms {
  singular: string;
  plural: string;
  verb?: string;
}

export interface ProgressTerms {
  notStarted: string;
  inProgress: string;
  completed: string;
  skipped: string;
  notNeeded?: string;
}

export interface EntityTerms extends BaseTerms {
  possessive?: string;
  articleIndefinite?: string; // "a" or "an"
  articleDefinite?: string;   // "the"
}

export interface JourneyTerms {
  mainUnit: EntityTerms;
  phaseUnit: EntityTerms;
  stepUnit: EntityTerms;
  progressTerms: ProgressTerms;
  pathUnit?: EntityTerms;
}

export interface ToolTerms {
  mainUnit: EntityTerms;
  evaluationTerms: EntityTerms;
  comparisonTerms: EntityTerms;
  categoryTerms?: EntityTerms;
}

export interface PathTerms {
  mainUnit: EntityTerms;
  progressTerms: {
    milestone: string;
    achievement: string;
    journey: string;
  };
}

export interface SystemWideTerms {
  application: {
    name: string;
    shortName?: string;
    tagline?: string;
  };
  navigation: {
    dashboard: string;
    settings: string;
    profile: string;
    help: string;
  };
  actions: {
    save: string;
    cancel: string;
    edit: string;
    delete: string;
    add: string;
  };
}

export interface TerminologyConfig {
  journeyTerms: JourneyTerms;
  toolTerms: ToolTerms;
  pathTerms: PathTerms;
  systemTerms: SystemWideTerms;
  _meta?: {
    version: string;
    baseLanguage: string;
    availableTranslations?: string[];
    lastUpdated?: string;
  };
  translations?: Record<string, Partial<TerminologyConfig>>;
}
```

## Default Terminology

The system includes sensible defaults that can be overridden:

```typescript
export const defaultTerminology: TerminologyConfig = {
  journeyTerms: {
    mainUnit: {
      singular: 'milestone',
      plural: 'milestones',
      verb: 'reach',
    },
    phaseUnit: {
      singular: 'stage',
      plural: 'stages',
    },
    stepUnit: {
      singular: 'task',
      plural: 'tasks',
      verb: 'complete',
    },
    progressTerms: {
      notStarted: 'not started',
      inProgress: 'in progress',
      completed: 'completed',
      skipped: 'skipped',
    },
  },
  toolTerms: {
    mainUnit: {
      singular: 'solution',
      plural: 'solutions',
      verb: 'implement',
    },
    evaluationTerms: {
      singular: 'assessment',
      plural: 'assessments',
      verb: 'evaluate',
    },
    comparisonTerms: {
      singular: 'comparison',
      plural: 'comparisons',
      verb: 'compare',
    },
  },
  pathTerms: {
    mainUnit: {
