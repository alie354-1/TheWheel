# Journey Dashboard AI Persistence & Caching Schema

## Overview

This document details the database schema and persistence strategy for AI-generated content in the Journey Dashboard. The system is designed to balance freshness of AI-generated insights with performance and cost considerations.

## Persistence Strategy Goals

1. **Optimize API Usage**: Minimize OpenAI API calls by caching and reusing content when appropriate
2. **Preserve Context**: Maintain context awareness across user sessions
3. **Manage Content Lifecycle**: Track recommendation states from generation to completion
4. **Support Iteration**: Enable refinement of AI-generated content over time
5. **Ensure Fallbacks**: Provide robust fallback mechanisms if AI generation fails

## Database Schema

### Core Tables

#### 1. `ai_generated_recommendations`

Stores step recommendations generated by AI for each company.

```sql
CREATE TABLE IF NOT EXISTS ai_generated_recommendations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  step_id UUID REFERENCES journey_steps(id) ON DELETE SET NULL,
  content JSONB NOT NULL, -- Full recommendation data including all fields
  context_hash TEXT NOT NULL, -- Hash of company state when generated
  status TEXT NOT NULL CHECK (status IN ('fresh', 'active', 'completed', 'stale')),
  generation_model TEXT NOT NULL, -- e.g., 'gpt-4-0613'
  generation_prompt_id TEXT, -- Reference to prompt used
  generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  last_presented_at TIMESTAMPTZ,
  times_presented INTEGER NOT NULL DEFAULT 0,
  user_feedback JSONB, -- Optional feedback on quality/relevance
  UNIQUE(company_id, step_id, context_hash)
);

CREATE INDEX ON ai_generated_recommendations(company_id, status);
CREATE INDEX ON ai_generated_recommendations(context_hash);
```

#### 2. `ai_generated_insights`

Stores peer insights generated by AI for companies.

```sql
CREATE TABLE IF NOT EXISTS ai_generated_insights (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  domain_id UUID REFERENCES journey_domains(id) ON DELETE SET NULL,
  step_id UUID REFERENCES journey_steps(id) ON DELETE SET NULL,
  content TEXT NOT NULL, -- The actual insight text
  author_profile JSONB NOT NULL, -- Author metadata (name, company, etc.)
  context_hash TEXT NOT NULL, -- Hash of company state when generated
  relevance_score FLOAT, -- How relevant this insight is (0.5-1.0)
  generation_model TEXT NOT NULL,
  generation_prompt_id TEXT,
  generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  last_presented_at TIMESTAMPTZ,
  times_presented INTEGER NOT NULL DEFAULT 0,
  UNIQUE(company_id, id) -- Each insight is unique
);

CREATE INDEX ON ai_generated_insights(company_id, domain_id);
CREATE INDEX ON ai_generated_insights(company_id, step_id);
CREATE INDEX ON ai_generated_insights(relevance_score);
```

#### 3. `ai_business_health_summaries`

Stores AI-generated business health analysis for companies.

```sql
CREATE TABLE IF NOT EXISTS ai_business_health_summaries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  content JSONB NOT NULL, -- Full health summary data
  context_hash TEXT NOT NULL,
  generation_model TEXT NOT NULL,
  generation_prompt_id TEXT,
  generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  last_presented_at TIMESTAMPTZ,
  times_presented INTEGER NOT NULL DEFAULT 0,
  UNIQUE(company_id, context_hash)
);

CREATE INDEX ON ai_business_health_summaries(company_id);
CREATE INDEX ON ai_business_health_summaries(generated_at);
```

### Supporting Tables

#### 4. `ai_context_snapshots`

Stores snapshots of company context for tracking changes and determining when to regenerate content.

```sql
CREATE TABLE IF NOT EXISTS ai_context_snapshots (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  context_hash TEXT NOT NULL,
  context_data JSONB NOT NULL, -- The actual context data used for generation
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(company_id, context_hash)
);

CREATE INDEX ON ai_context_snapshots(company_id, context_hash);
```

#### 5. `ai_generation_prompts`

Stores versioned prompts used for generation to track which prompt version produced which content.

```sql
CREATE TABLE IF NOT EXISTS ai_generation_prompts (
  id TEXT PRIMARY KEY, -- e.g., 'recommendation_v1', 'peer_insight_v2'
  prompt_type TEXT NOT NULL, -- 'recommendation', 'peer_insight', 'health_summary'
  prompt_template TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  active BOOLEAN NOT NULL DEFAULT true,
  version INTEGER NOT NULL,
  UNIQUE(prompt_type, version)
);
```

#### 6. `ai_generation_logs`

Tracks AI generation events for monitoring, debugging and optimization.

```sql
CREATE TABLE IF NOT EXISTS ai_generation_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  generation_type TEXT NOT NULL, -- 'recommendation', 'peer_insight', 'health_summary'
  prompt_id TEXT REFERENCES ai_generation_prompts(id),
  model_used TEXT NOT NULL,
  tokens_used INTEGER,
  generation_time_ms INTEGER,
  success BOOLEAN NOT NULL,
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX ON ai_generation_logs(company_id, created_at);
CREATE INDEX ON ai_generation_logs(generation_type, success);
```

## Content Lifecycle Management

### Recommendation Status Lifecycle

Recommendations move through these states:

1. **Fresh**: Newly generated, not yet seen by the user
2. **Active**: User has seen and possibly started working on this recommendation
3. **Completed**: User has completed this recommendation
4. **Stale**: Content is outdated based on company context changes

```sql
-- Function to update recommendation status
CREATE OR REPLACE FUNCTION update_recommendation_status(
  p_recommendation_id UUID,
  p_new_status TEXT
) RETURNS VOID AS $$
BEGIN
  UPDATE ai_generated_recommendations
  SET 
    status = p_new_status,
    last_presented_at = CASE WHEN p_new_status = 'active' THEN NOW() ELSE last_presented_at END,
    times_presented = CASE WHEN p_new_status = 'active' THEN times_presented + 1 ELSE times_presented END
  WHERE id = p_recommendation_id;
END;
$$ LANGUAGE plpgsql;
```

### Content Expiration Strategy

AI-generated content expires based on these criteria:

1. **Time-based**: Content older than a certain threshold (e.g., 14 days)
2. **Context-based**: Significant changes to company context
3. **Interaction-based**: User actions that invalidate previous recommendations

```sql
-- Function to check if content should be regenerated
CREATE OR REPLACE FUNCTION should_regenerate_content(
  p_company_id UUID,
  p_content_type TEXT,
  p_context_hash TEXT
) RETURNS BOOLEAN AS $$
DECLARE
  v_current_hash TEXT;
  v_last_generated TIMESTAMPTZ;
  v_regenerate BOOLEAN := false;
BEGIN
  -- Get current context hash for the company
  SELECT context_hash INTO v_current_hash
  FROM ai_context_snapshots
  WHERE company_id = p_company_id
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Check if context has changed significantly
  IF v_current_hash != p_context_hash THEN
    v_regenerate := true;
  END IF;
  
  -- Check time-based expiration
  IF p_content_type = 'recommendation' THEN
    SELECT MAX(generated_at) INTO v_last_generated
    FROM ai_generated_recommendations
    WHERE company_id = p_company_id AND status NOT IN ('stale');
    
    IF v_last_generated IS NULL OR v_last_generated < NOW() - INTERVAL '14 days' THEN
      v_regenerate := true;
    END IF;
  ELSIF p_content_type = 'insight' THEN
    SELECT MAX(generated_at) INTO v_last_generated
    FROM ai_generated_insights
    WHERE company_id = p_company_id;
    
    IF v_last_generated IS NULL OR v_last_generated < NOW() - INTERVAL '30 days' THEN
      v_regenerate := true;
    END IF;
  ELSIF p_content_type = 'health' THEN
    SELECT MAX(generated_at) INTO v_last_generated
    FROM ai_business_health_summaries
    WHERE company_id = p_company_id;
    
    IF v_last_generated IS NULL OR v_last_generated < NOW() - INTERVAL '7 days' THEN
      v_regenerate := true;
    END IF;
  END IF;
  
  RETURN v_regenerate;
END;
$$ LANGUAGE plpgsql;
```

## Context Hash Generation

The context hash is a critical component that determines when content should be regenerated. It's calculated from key aspects of company state:

```sql
-- Function to generate context hash for a company
CREATE OR REPLACE FUNCTION generate_company_context_hash(
  p_company_id UUID
) RETURNS TEXT AS $$
DECLARE
  v_completed_steps TEXT;
  v_in_progress_steps TEXT;
  v_domain_levels TEXT;
  v_last_activity TIMESTAMPTZ;
  v_context_data JSONB;
  v_hash TEXT;
BEGIN
  -- Get completed steps
  SELECT string_agg(step_id::text, ',') INTO v_completed_steps
  FROM company_journey_steps
  WHERE company_id = p_company_id AND status = 'completed'
  ORDER BY step_id;
  
  -- Get in-progress steps
  SELECT string_agg(step_id::text, ',') INTO v_in_progress_steps
  FROM company_journey_steps
  WHERE company_id = p_company_id AND status = 'in_progress'
  ORDER BY step_id;
  
  -- Get domain maturity levels
  SELECT string_agg(domain_id::text || ':' || maturity_level, ',') INTO v_domain_levels
  FROM company_domain_progress
  WHERE company_id = p_company_id
  ORDER BY domain_id;
  
  -- Get last activity timestamp
  SELECT MAX(last_activity_timestamp) INTO v_last_activity
  FROM step_activity
  WHERE company_id = p_company_id;
  
  -- Construct context data
  v_context_data := jsonb_build_object(
    'completed_steps', v_completed_steps,
    'in_progress_steps', v_in_progress_steps,
    'domain_levels', v_domain_levels,
    'last_activity', v_last_activity
  );
  
  -- Generate hash
  v_hash := encode(sha256(v_context_data::text::bytea), 'hex');
  
  -- Store context snapshot
  INSERT INTO ai_context_snapshots (company_id, context_hash, context_data)
  VALUES (p_company_id, v_hash, v_context_data)
  ON CONFLICT (company_id, context_hash) DO NOTHING;
  
  RETURN v_hash;
END;
$$ LANGUAGE plpgsql;
```

## Fallback Strategy

When AI generation fails or isn't available, the system falls back to previous content:

```sql
-- Function to get recommendations with fallback
CREATE OR REPLACE FUNCTION get_recommendations_with_fallback(
  p_company_id UUID,
  p_limit INTEGER DEFAULT 3
) RETURNS SETOF ai_generated_recommendations AS $$
DECLARE
  v_context_hash TEXT;
  v_found_count INTEGER;
BEGIN
  -- Get current context hash
  v_context_hash := generate_company_context_hash(p_company_id);
  
  -- Try to get recommendations for current context
  RETURN QUERY
  SELECT * FROM ai_generated_recommendations
  WHERE company_id = p_company_id
    AND context_hash = v_context_hash
    AND status IN ('fresh', 'active')
  ORDER BY generated_at DESC
  LIMIT p_limit;
  
  GET DIAGNOSTICS v_found_count = ROW_COUNT;
  
  -- If not enough found, fall back to any non-stale recommendations
  IF v_found_count < p_limit THEN
    RETURN QUERY
    SELECT * FROM ai_generated_recommendations
    WHERE company_id = p_company_id
      AND status IN ('fresh', 'active')
      AND id NOT IN (
        SELECT id FROM ai_generated_recommendations
        WHERE company_id = p_company_id
          AND context_hash = v_context_hash
          AND status IN ('fresh', 'active')
      )
    ORDER BY generated_at DESC
    LIMIT (p_limit - v_found_count);
  END IF;
END;
$$ LANGUAGE plpgsql;
```

## Performance Considerations

### Indexes

Key indexes are created to optimize query performance:

1. Company ID + Status: For quickly retrieving active recommendations
2. Context Hash: For checking if recommendations exist for current context
3. Relevance Score: For sorting peer insights by relevance
4. Generated At: For time-based expiration checks

### Batched Operations

For better performance with large datasets:

```sql
-- Mark stale recommendations in batch
CREATE OR REPLACE FUNCTION mark_stale_recommendations_batch(
  p_batch_size INTEGER DEFAULT 1000
) RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER := 0;
BEGIN
  WITH updated AS (
    UPDATE ai_generated_recommendations
    SET status = 'stale'
    WHERE id IN (
      SELECT r.id
      FROM ai_generated_recommendations r
      JOIN ai_context_snapshots s ON r.company_id = s.company_id
      WHERE r.status IN ('fresh', 'active')
        AND r.context_hash != s.context_hash
        AND s.created_at > r.generated_at
      ORDER BY r.generated_at ASC
      LIMIT p_batch_size
    )
    RETURNING id
  )
  SELECT COUNT(*) INTO v_count FROM updated;
  
  RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

## Migration and Maintenance

### Initial Setup

```sql
-- Create initial tables and functions
CREATE OR REPLACE FUNCTION setup_ai_persistence_schema() RETURNS VOID AS $$
BEGIN
  -- Create tables
  -- [Table creation SQL from above]
  
  -- Create functions
  -- [Function creation SQL from above]
  
  -- Create initial prompt templates
  INSERT INTO ai_generation_prompts (id, prompt_type, prompt_template, version)
  VALUES 
    ('recommendation_v1', 'recommendation', '...template here...', 1),
    ('peer_insight_v1', 'peer_insight', '...template here...', 1),
    ('health_summary_v1', 'health_summary', '...template here...', 1);
END;
$$ LANGUAGE plpgsql;
```

### Maintenance Jobs

```sql
-- Daily maintenance job
CREATE OR REPLACE FUNCTION ai_daily_maintenance() RETURNS VOID AS $$
DECLARE
  v_batch_count INTEGER;
  v_total_count INTEGER := 0;
BEGIN
  -- Mark stale recommendations in batches
  LOOP
    v_batch_count := mark_stale_recommendations_batch(1000);
    v_total_count := v_total_count + v_batch_count;
    EXIT WHEN v_batch_count = 0;
  END LOOP;
  
  -- Clean up old context snapshots
  DELETE FROM ai_context_snapshots
  WHERE created_at < NOW() - INTERVAL '90 days';
  
  -- Clean up old generation logs
  DELETE FROM ai_generation_logs
  WHERE created_at < NOW() - INTERVAL '90 days';
  
  -- Log the maintenance run
  INSERT INTO system_logs (component, message)
  VALUES ('ai_maintenance', format('Marked %s recommendations as stale', v_total_count));
END;
$$ LANGUAGE plpgsql;
```

## Usage Tracking & Analytics

### Usage Statistics

```sql
-- Get AI generation usage statistics
CREATE OR REPLACE FUNCTION get_ai_usage_stats(
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ
) RETURNS TABLE(
  day DATE,
  generation_type TEXT,
  generations_count INTEGER,
  tokens_used INTEGER,
  avg_generation_time_ms NUMERIC,
  success_rate NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    DATE(created_at) AS day,
    generation_type,
    COUNT(*) AS generations_count,
    SUM(tokens_used) AS tokens_used,
    AVG(generation_time_ms)::NUMERIC AS avg_generation_time_ms,
    (SUM(CASE WHEN success THEN 1 ELSE 0 END)::NUMERIC / COUNT(*)::NUMERIC * 100)::NUMERIC AS success_rate
  FROM ai_generation_logs
  WHERE created_at BETWEEN p_start_date AND p_end_date
  GROUP BY DATE(created_at), generation_type
  ORDER BY DATE(created_at), generation_type;
END;
$$ LANGUAGE plpgsql;
```

### Effectiveness Tracking

```sql
-- Track recommendation effectiveness
CREATE TABLE IF NOT EXISTS ai_recommendation_effectiveness (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  recommendation_id UUID REFERENCES ai_generated_recommendations(id) ON DELETE CASCADE,
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  was_started BOOLEAN,
  was_completed BOOLEAN,
  time_to_start INTERVAL,
  time_to_complete INTERVAL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Function to update effectiveness when step is started
CREATE OR REPLACE FUNCTION track_recommendation_start(
  p_recommendation_id UUID
) RETURNS VOID AS $$
DECLARE
  v_company_id UUID;
  v_generated_at TIMESTAMPTZ;
BEGIN
  -- Get recommendation details
  SELECT company_id, generated_at INTO v_company_id, v_generated_at
  FROM ai_generated_recommendations
  WHERE id = p_recommendation_id;
  
  -- Update or insert effectiveness record
  INSERT INTO ai_recommendation_effectiveness (
    recommendation_id, company_id, was_started, time_to_start
  )
  VALUES (
    p_recommendation_id, v_company_id, true, NOW() - v_generated_at
  )
  ON CONFLICT (recommendation_id) DO UPDATE
  SET 
    was_started = true,
    time_to_start = NOW() - v_generated_at;
    
  -- Update recommendation status
  PERFORM update_recommendation_status(p_recommendation_id, 'active');
END;
$$ LANGUAGE plpgsql;
