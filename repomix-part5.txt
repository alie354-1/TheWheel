            console.log('Extracted JSON object pattern');
          }
        }
      }
      
      if (extractedJson) {
        // Clean up the extracted JSON to handle common formatting issues
        const cleanedJson = extractedJson
          .replace(/\"/g, '"')  // Handle escaped quotes
          .replace(/\n/g, ' ')    // Remove newlines
          .replace(/,\s*}/g, '}') // Remove trailing commas in objects
          .replace(/,\s*\]/g, ']'); // Remove trailing commas in arrays
        
        try {
          // Method 3: Try JSON5 for more lenient parsing
          const parsedData = JSON5.parse(cleanedJson);
          console.log('Successfully parsed using JSON5');
          return Array.isArray(parsedData) ? parsedData : [parsedData];
        } catch (json5ParseError) {
          console.warn('JSON5 parsing failed:', json5ParseError.message);
          
          // If JSON5 fails, fall back to the original method
          try {
            const parsedData = JSON.parse(cleanedJson);
            console.log('Successfully parsed cleaned JSON using standard JSON.parse');
            return Array.isArray(parsedData) ? parsedData : [parsedData];
          } catch (cleanedJsonError) {
            console.warn('Cleaned JSON parsing failed:', cleanedJsonError.message);
          }
        }
      }
      
      // Method 4: Last resort - create mock suggestions
      console.warn('All JSON parsing methods failed. Using mock data as fallback.');
      return this.createMockSuggestions(response);
      
    } catch (error) {
      console.error('Error parsing suggestions response:', error);
      // Provide mock data as a fallback
      return this.createMockSuggestions(response);
    }
  }
      } catch (e) {
        console.log('Standard JSON parsing failed:', e.message);
      }
      
      // Strategy 2: Try JSON5 which is more lenient
      try {
        const result = JSON5.parse(responseContent);
        if (Array.isArray(result) && result.length > 0) {
          console.log('Successfully parsed using JSON5.parse');
          return result.map(item => this.validateAndCleanSuggestion(item, originalIdea));
        }
      } catch (e) {
        console.log('JSON5 parsing failed:', e.message);
      }
      
      // Strategy 3: Try to extract JSON array using regex and then parse
      try {
        const jsonArrayMatch = responseContent.match(/\[([\s\S]*?)\]/);
        if (jsonArrayMatch && jsonArrayMatch[0]) {
          const extractedJson = jsonArrayMatch[0];
          try {
            const result = JSON.parse(extractedJson);
            if (Array.isArray(result) && result.length > 0) {
              console.log('Successfully parsed JSON array extracted with regex');
              return result.map(item => this.validateAndCleanSuggestion(item, originalIdea));
            }
          } catch (e) {
            // Try with JSON5 if standard JSON fails
            try {
              const result = JSON5.parse(extractedJson);
              if (Array.isArray(result) && result.length > 0) {
                console.log('Successfully parsed JSON array with JSON5 after regex extraction');
                return result.map(item => this.validateAndCleanSuggestion(item, originalIdea));
              }
            } catch (e2) {
              console.log('JSON5 parsing of extracted array failed:', e2.message);
            }
          }
        }
      } catch (e) {
        console.log('Regex extraction failed:', e.message);
      }
      
      // Strategy 4: Try to extract and parse individual JSON objects
      try {
        const objectRegex = /\{([\s\S]*?)\}(?=\s*,|\s*\]|\s*$)/g;
        const matches = Array.from(responseContent.matchAll(objectRegex));
        
        if (matches && matches.length > 0) {
          const parsedObjects = [];
          
          for (const match of matches) {
            try {
              // Add curly braces back
              const objStr = '{' + match[1] + '}';
              // Fix common JSON issues
              const fixedStr = objStr
                .replace(/,\s*\}/g, '}') // Remove trailing commas
                .replace(/([\w]+):/g, '"$1":') // Quote unquoted keys
                .replace(/:\s*'([^']*?)'/g, ':"$1"'); // Replace single quotes with double quotes
              
              const obj = JSON.parse(fixedStr);
              parsedObjects.push(obj);
            } catch (err) {
              // Skip objects that can't be parsed
              console.log('Failed to parse individual object');
            }
          }
          
          if (parsedObjects.length > 0) {
            console.log('Successfully parsed individual objects:', parsedObjects.length);
            return parsedObjects.map(item => this.validateAndCleanSuggestion(item, originalIdea));
          }
        }
      } catch (e) {
        console.log('Individual object parsing failed:', e.message);
      }
      
      // If all parsing strategies fail, return mock suggestions
      console.warn('All JSON parsing strategies failed, using mock suggestions');
      return this.generateMockSuggestions(originalIdea, 3);
    } catch (error) {
      console.error('Error in parseSuggestionsResponse:', error);
      return this.generateMockSuggestions(originalIdea, 3);
    }
  }

  /**
   * Parse the AI response into a merged suggestion
   */
  private parseMergedSuggestion(responseContent: string, originalSuggestions: Suggestion[]): Suggestion {
    try {
      // Log the response for debugging
      console.log('Processing merged suggestion response length:', responseContent.length);

      // Try all the same JSON parsing strategies as in parseSuggestionsResponse
      let mergedSuggestion = null;

      // Try standard JSON parsing
      try {
        const result = JSON.parse(responseContent);
        if (result && typeof result === 'object' && !Array.isArray(result)) {
          mergedSuggestion = result;
        }
      } catch (e) {
        // Try JSON5 which is more lenient
        try {
          const result = JSON5.parse(responseContent);
          if (result && typeof result === 'object' && !Array.isArray(result)) {
            mergedSuggestion = result;
          }
        } catch (e2) {
          // Try to extract object using regex
          try {
            const jsonObjectMatch = responseContent.match(/\{([\s\S]*?)\}/);
            if (jsonObjectMatch && jsonObjectMatch[0]) {
              const extractedJson = jsonObjectMatch[0];
              try {
                mergedSuggestion = JSON.parse(extractedJson);
              } catch (e3) {
                // Try with JSON5
                try {
                  mergedSuggestion = JSON5.parse(extractedJson);
                } catch (e4) {
                  // All parsing attempts failed
                }
              }
            }
          } catch (e3) {
            // Regex extraction failed
          }
        }
      }

      if (mergedSuggestion) {
        console.log('Successfully parsed merged suggestion');

        // Validate and ensure the title indicates it's a merged concept
        const validatedSuggestion = this.validateAndCleanSuggestion(mergedSuggestion, null);

        // Make sure the title indicates it's a merged concept
        if (!validatedSuggestion.title.includes('(Merged Concept)')) {
          validatedSuggestion.title += ' (Merged Concept)';
        }

        return validatedSuggestion;
      }

      // If no JSON object found or parsing failed, fall back to basic merge
      console.warn('Failed to parse AI response as JSON object, using basic merge');
      return this.createBasicMergedSuggestion(originalSuggestions);
    } catch (error) {
      console.error('Error parsing AI merge response:', error);
      return this.createBasicMergedSuggestion(originalSuggestions);
    }
  }

  /**
   * Parse the AI response into a regenerated suggestion
   */
  private parseRegeneratedSuggestion(responseContent: string, originalSuggestion: Suggestion): Suggestion {
    try {
      // Try to extract and parse a single JSON object using same strategies as parseMergedSuggestion
      let regeneratedSuggestion = null;

      // Try standard JSON parsing
      try {
        const result = JSON.parse(responseContent);
        if (result && typeof result === 'object' && !Array.isArray(result)) {
          regeneratedSuggestion = result;
        }
      } catch (e) {
        // Try JSON5 which is more lenient
        try {
          const result = JSON5.parse(responseContent);
          if (result && typeof result === 'object' && !Array.isArray(result)) {
            regeneratedSuggestion = result;
          }
        } catch (e2) {
          // Try to extract object using regex
          try {
            const jsonObjectMatch = responseContent.match(/\{([\s\S]*?)\}/);
            if (jsonObjectMatch && jsonObjectMatch[0]) {
              const extractedJson = jsonObjectMatch[0];
              try {
                regeneratedSuggestion = JSON.parse(extractedJson);
              } catch (e3) {
                // Try with JSON5
                try {
                  regeneratedSuggestion = JSON5.parse(extractedJson);
                } catch (e4) {
                  // All parsing attempts failed
                }
              }
            }
          } catch (e3) {
            // Regex extraction failed
          }
        }
      }

      if (regeneratedSuggestion) {
        console.log('Successfully parsed regenerated suggestion');
        // Validate and clean up the suggestion
        return this.validateAndCleanSuggestion(regeneratedSuggestion, null);
      }

      // If no JSON object found or parsing failed, return a modified version of the original
      console.warn('Failed to parse AI regeneration response as JSON object, using modified original');
      return {
        ...originalSuggestion,
        title: `${originalSuggestion.title} (Regenerated)`,
        description: `Improved version of: ${originalSuggestion.description}`
      };
    } catch (error) {
      console.error('Error parsing AI regeneration response:', error);
      return {
        ...originalSuggestion,
        title: `${originalSuggestion.title} (Regenerated)`,
        description: `Improved version of: ${originalSuggestion.description}`
      };
    }
  }

  /**
   * Validate and ensure all required fields are present in a suggestion
   */
  private validateAndCleanSuggestion(suggestion: any, originalIdea: IdeaPlaygroundIdea | null): Suggestion {
    // Default values from original idea if available
    const defaultTitle = originalIdea ? `Variation of ${originalIdea.title}` : 'New Business Idea';
    const defaultDescription = originalIdea?.description || 'No description provided';
    const defaultProblemStatement = originalIdea?.problem_statement || 'Problem statement not specified';
    const defaultSolutionConcept = originalIdea?.solution_concept || 'Solution not specified';

    // Ensure all required fields exist
    return {
      title: suggestion.title || defaultTitle,
      description: suggestion.description || defaultDescription,
      problem_statement: suggestion.problem_statement || defaultProblemStatement,
      solution_concept: suggestion.solution_concept || defaultSolutionConcept,
      target_audience: suggestion.target_audience || 'General market',
      unique_value: suggestion.unique_value || 'Unique value proposition not specified',
      business_model: suggestion.business_model || 'Business model not specified',
      marketing_strategy: suggestion.marketing_strategy || 'Marketing strategy not specified',
      revenue_model: suggestion.revenue_model || 'Revenue model not specified',
      go_to_market: suggestion.go_to_market || 'Go-to-market strategy not specified',
      market_size: suggestion.market_size || 'Market size not estimated',
      competition: Array.isArray(suggestion.competition) ? suggestion.competition : ['Not specified'],
      revenue_streams: Array.isArray(suggestion.revenue_streams) ? suggestion.revenue_streams : ['Not specified'],
      cost_structure: Array.isArray(suggestion.cost_structure) ? suggestion.cost_structure : ['Not specified'],
      key_metrics: Array.isArray(suggestion.key_metrics) ? suggestion.key_metrics : ['Not specified'],
      strengths: Array.isArray(suggestion.strengths) ? suggestion.strengths : ['Not specified'],
      weaknesses: Array.isArray(suggestion.weaknesses) ? suggestion.weaknesses : ['Not specified'],
      opportunities: Array.isArray(suggestion.opportunities) ? suggestion.opportunities : ['Not specified'],
      threats: Array.isArray(suggestion.threats) ? suggestion.threats : ['Not specified']
    };
  }

  /**
   * Create a basic merged suggestion from multiple suggestions
   */
  private createBasicMergedSuggestion(suggestions: Suggestion[]): Suggestion {
    if (suggestions.length === 0) {
      throw new Error('No suggestions to merge');
    }

    const baseSuggestion = suggestions[0];
    const allTitles = suggestions.map(s => s.title.replace(/ \(Merged Concept\)$/, ''));

    // Create a title that references the merged concepts
    const mergedTitle = allTitles.length <= 2
      ? `${allTitles.join(' + ')} (Merged Concept)`
      : `${allTitles[0]} + ${allTitles.length - 1} More (Merged Concept)`;

    // Combine all unique elements from arrays
    const combineUnique = (field: keyof Suggestion) => {
      const allItems = suggestions.flatMap(s => {
        const value = s[field];
        return Array.isArray(value) ? value : [];
      });
      return [...new Set(allItems)].slice(0, 5); // Limit to 5 items
    };

    return {
      title: mergedTitle,
      description: `A merged concept combining the best elements of ${allTitles.join(', ')}.`,
      problem_statement: baseSuggestion.problem_statement,
      solution_concept: `Combined approach that integrates: ${suggestions.map(s => s.solution_concept).join('; ')}`,
      target_audience: baseSuggestion.target_audience,
      unique_value: `Multi-faceted value proposition: ${suggestions.map(s => s.unique_value).join('; ')}`,
      business_model: baseSuggestion.business_model,
      marketing_strategy: baseSuggestion.marketing_strategy,
      revenue_model: baseSuggestion.revenue_model,
      go_to_market: baseSuggestion.go_to_market,
      market_size: baseSuggestion.market_size,
      competition: combineUnique('competition'),
      revenue_streams: combineUnique('revenue_streams'),
      cost_structure: combineUnique('cost_structure'),
      key_metrics: combineUnique('key_metrics'),
      strengths: combineUnique('strengths'),
      weaknesses: combineUnique('weaknesses'),
      opportunities: combineUnique('opportunities'),
      threats: combineUnique('threats')
    };
  }

  /**
   * Generate mock suggestions based on an original idea (fallback method)
   */
  private generateMockSuggestions(idea: IdeaPlaygroundIdea, count: number): Suggestion[] {
    const mockSuggestions: Suggestion[] = [];

    const variants = [
      { suffix: 'Premium Edition', audience: 'Enterprise customers', model: 'Subscription' },
      { suffix: 'Lite Version', audience: 'Individual users', model: 'Freemium' },
      { suffix: 'Pro Edition', audience: 'Professional users', model: 'One-time purchase' },
      { suffix: 'Community Edition', audience: 'Communities and non-profits', model: 'Open source with paid support' },
      { suffix: 'Enterprise Solution', audience: 'Large corporations', model: 'Annual licensing' }
    ];

    // Generate the requested number of suggestions
    for (let i = 0; i < Math.min(count, variants.length); i++) {
      const variant = variants[i];

      mockSuggestions.push({
        title: `${idea.title} - ${variant.suffix}`,
        description: `A ${variant.suffix.toLowerCase()} of ${idea.title} targeting ${variant.audience.toLowerCase()}.`,
        problem_statement: idea.problem_statement || 'Problem statement not provided',
        solution_concept: idea.solution_concept || 'Solution concept not provided',
        target_audience: variant.audience,
        unique_value: `Specialized features for ${variant.audience.toLowerCase()}`,
        business_model: `${variant.model} model`,
        marketing_strategy: 'Digital marketing and industry partnerships',
        revenue_model: variant.model,
        go_to_market: 'Targeted launch to early adopters',
        market_size: 'Market size will depend on specific segment targeting',
        competition: ['Competitor A', 'Competitor B', 'Competitor C'],
        revenue_streams: ['Primary Revenue', 'Secondary Revenue', 'Tertiary Revenue'],
        cost_structure: ['Development', 'Marketing', 'Operations', 'Customer Support'],
        key_metrics: ['User Acquisition', 'Retention Rate', 'Revenue Per User', 'Customer Lifetime Value'],
        strengths: ['Market fit', 'Unique positioning'],
        weaknesses: ['Resource requirements', 'Market education needs'],
        opportunities: ['Growing market', 'Underserved segment'],
        threats: ['Established competitors', 'Regulatory changes']
      });
    }

    return mockSuggestions;
  }
}

// Export a singleton instance
export const ideaPathway1AIService = new IdeaPathway1AIService();

================
File: src/lib/services/idea-pathway1-ai.service.ts.backup2
================
import JSON5 from 'json5';
import JSON5 from 'json5';
import { generalLLMService } from './general-llm.service';
import { IdeaPlaygroundIdea } from '../types/idea-playground.types';
import { Suggestion } from '../../components/idea-playground/pathway1/SuggestionCard';

/**
 * Service to handle AI operations specifically for Pathway 1 of the Idea Playground
 */
export class IdeaPathway1AIService {
  /**
   * Generate multiple company suggestions based on an initial idea
   * @param idea The original idea from IdeaCaptureScreen
   * @param userId The user ID for logging and context
   * @param count Number of suggestions to generate (default: 5)
   * @returns Array of suggestion objects
   */
  async generateCompanySuggestions(
    idea: IdeaPlaygroundIdea,
    userId: string,
    count: number = 5
  ): Promise<Suggestion[]> {
    try {
      // Create a detailed prompt for the AI
      const prompt = this.createSuggestionPrompt(idea, count);

      console.log('Generating company suggestions for idea:', idea.title);

      // Call the general LLM service with the prompt
      const response = await generalLLMService.query(prompt, {
        userId: userId || 'anonymous',
        useCompanyModel: !!idea.used_company_context,
        useExistingModels: true,
        context: 'idea_generation'
      });

      if (!response || !response.content) {
        console.error('Empty response from AI service');
        throw new Error('Empty response from AI service');
      }

      console.log('Received AI response, length:', response.content.length);

      // Parse the AI response into suggestion objects
      const suggestions = this.parseSuggestionsResponse(response.content, idea);

      // Log successful generation
      console.log(`Successfully generated ${suggestions.length} real suggestions`);

      return suggestions;
    } catch (error) {
      console.error('Error generating company suggestions:', error);
      // Return mock suggestions as fallback
      const mockSuggestions = this.generateMockSuggestions(idea, count);
      console.warn('Using mock suggestions due to error:', error);
      return mockSuggestions;
    }
  }

  /**
   * Generate a merged suggestion from multiple selected suggestions
   * @param suggestions Array of selected suggestions to merge
   * @param userId The user ID for logging and context
   * @returns A new merged suggestion
   */
  async mergeSuggestions(
    suggestions: Suggestion[],
    userId: string
  ): Promise<Suggestion> {
    try {
      if (suggestions.length < 2) {
        throw new Error('Need at least 2 suggestions to merge');
      }

      // Create a prompt for merging suggestions
      const prompt = this.createMergePrompt(suggestions);

      // Call the general LLM service with the prompt
      const response = await generalLLMService.query(prompt, {
        userId: userId || 'anonymous',
        useCompanyModel: false,
        useExistingModels: true,
        context: 'idea_merging'
      });

      // Parse the AI response into a merged suggestion
      return this.parseMergedSuggestion(response.content, suggestions);
    } catch (error) {
      console.error('Error merging suggestions:', error);
      // Return a basic merged suggestion as fallback
      return this.createBasicMergedSuggestion(suggestions);
    }
  }

  /**
   * Regenerate a specific suggestion
   * @param originalSuggestion The suggestion to regenerate
   * @param idea The original idea
   * @param userId The user ID for logging and context
   * @returns A new regenerated suggestion
   */
  async regenerateSuggestion(
    originalSuggestion: Suggestion,
    idea: IdeaPlaygroundIdea,
    userId: string
  ): Promise<Suggestion> {
    try {
      // Create a prompt for regenerating the suggestion
      const prompt = this.createRegenerationPrompt(originalSuggestion, idea);

      // Call the general LLM service with the prompt
      const response = await generalLLMService.query(prompt, {
        userId: userId || 'anonymous',
        useCompanyModel: !!idea.used_company_context,
        useExistingModels: true,
        context: 'idea_regeneration'
      });

      // Parse the AI response into a suggestion
      return this.parseRegeneratedSuggestion(response.content, originalSuggestion);
    } catch (error) {
      console.error('Error regenerating suggestion:', error);
      // Return a modified version of the original as fallback
      return {
        ...originalSuggestion,
        title: `${originalSuggestion.title} (Regenerated)`,
        description: `Improved version of: ${originalSuggestion.description}`
      };
    }
  }

  /**
   * Create a prompt for generating company suggestions
   */
  private createSuggestionPrompt(idea: IdeaPlaygroundIdea, count: number): string {
    const userContext = idea.used_company_context
      ? `This idea is part of an existing business. Consider how it might fit within
         an established company's operations and strategy.`
      : '';

    return `
      You are a creative business strategist and startup advisor with extensive knowledge of
      markets, business models, and innovation strategies.

      ORIGINAL IDEA:
      Title: ${idea.title};
      Description: ${idea.description};
      Solution Concept: ${idea.solution_concept || 'Not specified'};
      ${userContext};

      TASK:
      Generate ${count} distinct and innovative variations of the original idea. Each variation should
      have a unique angle or approach while still solving the core problem or addressing the core opportunity.

      For each variation, please provide:
      1. Title: A catchy, clear title
      2. Description: A concise description of the idea variation (1-2 sentences)
      3. Problem Statement: What problem does this solve?
      4. Solution Concept: How does this solution work?
      5. Target Audience: Who would use/buy this?
      6. Unique Value: What makes this variation special?
      7. Business Model: How would this make money?
      8. Marketing Strategy: How would you promote this?
      9. Revenue Model: Specific revenue streams
      10. Go-to-Market Strategy: Initial launch approach
      11. Market Size: Rough estimate of the addressable market
      12. Competition: List of 2-4 potential competitors
      13. Revenue Streams: 3-5 potential revenue sources
      14. Cost Structure: 3-5 major cost categories
      15. Key Metrics: 3-5 important KPIs to track

      SWOT ANALYSIS FOR EACH:
      - Strengths: 2-3 key strengths
      - Weaknesses: 2-3 key weaknesses
      - Opportunities: 2-3 market opportunities
      - Threats: 2-3 potential risks or threats

      FORMAT:
      Return the results in a valid JSON array format that I can parse directly. Each object should have all the above fields.

      IMPORTANT GUIDELINES:
      - Make each variation truly distinct, not just minor tweaks
      - Be realistic but creative
      - Consider different business models for each
      - Target different audience segments where appropriate
      - Each variation should have a clear revenue model
    `;
  }

  /**
   * Create a prompt for merging multiple suggestions
   */
  private createMergePrompt(suggestions: Suggestion[]): string {
    // Extract titles for a more concise prompt summary
    const suggestionTitles = suggestions.map((s, i) => `${i+1}. ${s.title}`).join('\n');

    // Create detailed JSON for each suggestion
    const suggestionsJson = JSON.stringify(suggestions, null, 2);

    return `
      You are a creative business strategist and startup advisor tasked with merging multiple business ideas.

      TASK:
      Create a single, cohesive business idea that combines the best elements from these suggestions:
      ${suggestionTitles};

      Detailed information about each suggestion:
      ${suggestionsJson};

      Create a new merged business idea that:
      1. Takes the best elements from each suggestion
      2. Resolves any contradictions between the suggestions
      3. Creates something that's more than the sum of its parts
      4. Is coherent and practical

      FORMAT:
      Return a single merged suggestion in valid JSON format with the same fields as the input suggestions.

      Title the merged suggestion with "(Merged Concept)" at the end, e.g. "AI-Powered Health Platform (Merged Concept)".

      IMPORTANT:
      - The merged concept should be innovative yet realistic
      - Ensure all fields are filled out completely
      - Maintain the most compelling value propositions from the original concepts
      - Address the strongest target audience identified across concepts
    `;
  }

  /**
   * Create a prompt for regenerating a specific suggestion
   */
  private createRegenerationPrompt(suggestion: Suggestion, idea: IdeaPlaygroundIdea): string {
    const suggestionJson = JSON.stringify(suggestion, null, 2);

    return `
      You are a creative business strategist and startup advisor with extensive knowledge of
      markets, business models, and innovation strategies.

      ORIGINAL IDEA INPUT:
      Title: ${idea.title};
      Description: ${idea.description};
      Solution Concept: ${idea.solution_concept || 'Not specified'};

      CURRENT SUGGESTION TO IMPROVE:
      ${suggestionJson};

      TASK:
      Generate an improved version of this business idea. Keep the core concept but make it more:
      - Innovative
      - Marketable
      - Financially viable
      - Competitive

      Enhance all aspects of the idea, especially:
      - Value proposition
      - Business model
      - Target audience
      - Go-to-market strategy

      FORMAT:
      Return the improved suggestion in a valid JSON format with all the same fields as the input suggestion.

      IMPORTANT:
      - Make meaningful improvements, not superficial changes
      - Keep the fundamental concept intact while enhancing it
      - Ensure all fields are filled out completely
      - Be realistic but ambitious
    `;
  }

  /**
   * Parse AI-generated suggestions with multiple fallback strategies to handle JSON formatting issues
   */
  
  /**
   * Parse the AI response to extract suggestion objects.
   * This function uses multiple fallback mechanisms to handle malformed JSON.
   * @param response The text response from the AI
   * @returns Array of business suggestion objects
   */
  private parseSuggestionsResponse(response: string): Suggestion[] {
    try {
      console.log('Parsing AI response:', response.substring(0, 200) + '...');
      
      // Method 1: Try standard JSON.parse first
      try {
        const parsedData = JSON.parse(response);
        console.log('Successfully parsed response using standard JSON.parse');
        return Array.isArray(parsedData) ? parsedData : [parsedData];
      } catch (error: any) {
        console.warn('Standard JSON.parse failed:', error.message);
        
        // Method 2: Try JSON5 for more lenient parsing
        try {
          const parsedData = JSON5.parse(response);
          console.log('Successfully parsed using JSON5');
          return Array.isArray(parsedData) ? parsedData : [parsedData];
        } catch (error: any) {
          console.warn('JSON5 parsing failed:', error.message);
          
          // Method 3: Try to extract JSON from code blocks if present
          const jsonCodeBlockMatch = response.match(/```(?:json)?\n([\s\S]*?)\n```/);
          if (jsonCodeBlockMatch && jsonCodeBlockMatch[1]) {
            try {
              const extractedJson = jsonCodeBlockMatch[1];
              console.log('Attempting to parse JSON extracted from code block');
              const parsedData = JSON.parse(extractedJson);
              return Array.isArray(parsedData) ? parsedData : [parsedData];
            } catch (error: any) {
              console.warn('Code block JSON parsing failed:', error.message);
            }
          }
        }
      }
      
      // If all parsing attempts fail, log error and return empty array
      // The calling method will handle this by providing mock data
      console.error('All JSON parsing methods failed');
      return [];
    } catch (error) {
      console.error('Error in parseSuggestionsResponse:', error);
      return [];
    }
  } catch (error) {
        console.warn('Standard JSON.parse failed:', (error as Error).message);
      }
      
      // Method 2: Try to extract JSON using regex patterns
      console.log('Attempting to extract JSON using regex patterns...');
      let extractedJson = '';
      
      // Try to find JSON within code blocks
      const jsonCodeBlockMatch = response.match(/```(?:json)?\n([\s\S]*?)\n```/);
      if (jsonCodeBlockMatch) {
        extractedJson = jsonCodeBlockMatch[1];
        console.log('Extracted JSON from code block');
      } 
      // Try to extract JSON array pattern
      else {
        const jsonArrayMatch = response.match(/\[\s*{[\s\S]*?}\s*\]/);
        if (jsonArrayMatch) {
          extractedJson = jsonArrayMatch[0];
          console.log('Extracted JSON array pattern');
        }
        // Try to extract any JSON object
        else {
          const jsonObjectMatch = response.match(/{[\s\S]*?}/);
          if (jsonObjectMatch) {
            extractedJson = jsonObjectMatch[0];
            console.log('Extracted JSON object pattern');
          }
        }
      }
      
      if (extractedJson) {
        // Clean up the extracted JSON to handle common formatting issues
        const cleanedJson = extractedJson
          .replace(/\"/g, '"')  // Handle escaped quotes
          .replace(/\n/g, ' ')    // Remove newlines
          .replace(/,\s*}/g, '}') // Remove trailing commas in objects
          .replace(/,\s*\]/g, ']'); // Remove trailing commas in arrays
        
        try {
          // Method 3: Try JSON5 for more lenient parsing
          const parsedData = JSON5.parse(cleanedJson);
          console.log('Successfully parsed using JSON5');
          return Array.isArray(parsedData) ? parsedData : [parsedData];
        } catch (error) {
          console.warn('JSON5 parsing failed:', (error as Error).message);
          
          // If JSON5 fails, fall back to the original method
          try {
            const parsedData = JSON.parse(cleanedJson);
            console.log('Successfully parsed cleaned JSON using standard JSON.parse');
            return Array.isArray(parsedData) ? parsedData : [parsedData];
          } catch (error) {
            console.warn('Cleaned JSON parsing failed:', (error as Error).message);
          }
        }
      }
      
      // If all parsing attempts failed, return empty array (existing error handling will kick in)
      console.warn('All JSON parsing methods failed. Using fallback error handling.');
      return [];
      
    } catch (error) {
      console.error('Error parsing suggestions response:', error);
      return [];
    }
  } catch (standardParseError) {
        console.warn('Standard JSON.parse failed:', standardParseError.message);
      }
      
      // Method 2: Try to extract JSON using regex patterns
      console.log('Attempting to extract JSON using regex patterns...');
      let extractedJson = '';
      
      // Try to find JSON within code blocks
      const jsonCodeBlockMatch = response.match(/```(?:json)?\n([\s\S]*?)\n```/);
      if (jsonCodeBlockMatch) {
        extractedJson = jsonCodeBlockMatch[1];
        console.log('Extracted JSON from code block');
      } 
      // Try to extract JSON array pattern
      else {
        const jsonArrayMatch = response.match(/\[\s*{[\s\S]*?}\s*\]/);
        if (jsonArrayMatch) {
          extractedJson = jsonArrayMatch[0];
          console.log('Extracted JSON array pattern');
        }
        // Try to extract any JSON object
        else {
          const jsonObjectMatch = response.match(/{[\s\S]*?}/);
          if (jsonObjectMatch) {
            extractedJson = jsonObjectMatch[0];
            console.log('Extracted JSON object pattern');
          }
        }
      }
      
      if (extractedJson) {
        // Clean up the extracted JSON to handle common formatting issues
        const cleanedJson = extractedJson
          .replace(/\"/g, '"')  // Handle escaped quotes
          .replace(/\n/g, ' ')    // Remove newlines
          .replace(/,\s*}/g, '}') // Remove trailing commas in objects
          .replace(/,\s*\]/g, ']'); // Remove trailing commas in arrays
        
        try {
          // Method 3: Try JSON5 for more lenient parsing
          const parsedData = JSON5.parse(cleanedJson);
          console.log('Successfully parsed using JSON5');
          return Array.isArray(parsedData) ? parsedData : [parsedData];
        } catch (json5ParseError) {
          console.warn('JSON5 parsing failed:', json5ParseError.message);
          
          // If JSON5 fails, fall back to the original method
          try {
            const parsedData = JSON.parse(cleanedJson);
            console.log('Successfully parsed cleaned JSON using standard JSON.parse');
            return Array.isArray(parsedData) ? parsedData : [parsedData];
          } catch (cleanedJsonError) {
            console.warn('Cleaned JSON parsing failed:', cleanedJsonError.message);
          }
        }
      }
      
      // Method 4: Last resort - create mock suggestions
      console.warn('All JSON parsing methods failed. Using mock data as fallback.');
      return this.createMockSuggestions(response);
      
    } catch (error) {
      console.error('Error parsing suggestions response:', error);
      // Provide mock data as a fallback
      return this.createMockSuggestions(response);
    }
  }
      } catch (e) {
        console.log('Standard JSON parsing failed:', e.message);
      }
      
      // Strategy 2: Try JSON5 which is more lenient
      try {
        const result = JSON5.parse(responseContent);
        if (Array.isArray(result) && result.length > 0) {
          console.log('Successfully parsed using JSON5.parse');
          return result.map(item => this.validateAndCleanSuggestion(item, originalIdea));
        }
      } catch (e) {
        console.log('JSON5 parsing failed:', e.message);
      }
      
      // Strategy 3: Try to extract JSON array using regex and then parse
      try {
        const jsonArrayMatch = responseContent.match(/\[([\s\S]*?)\]/);
        if (jsonArrayMatch && jsonArrayMatch[0]) {
          const extractedJson = jsonArrayMatch[0];
          try {
            const result = JSON.parse(extractedJson);
            if (Array.isArray(result) && result.length > 0) {
              console.log('Successfully parsed JSON array extracted with regex');
              return result.map(item => this.validateAndCleanSuggestion(item, originalIdea));
            }
          } catch (e) {
            // Try with JSON5 if standard JSON fails
            try {
              const result = JSON5.parse(extractedJson);
              if (Array.isArray(result) && result.length > 0) {
                console.log('Successfully parsed JSON array with JSON5 after regex extraction');
                return result.map(item => this.validateAndCleanSuggestion(item, originalIdea));
              }
            } catch (e2) {
              console.log('JSON5 parsing of extracted array failed:', e2.message);
            }
          }
        }
      } catch (e) {
        console.log('Regex extraction failed:', e.message);
      }
      
      // Strategy 4: Try to extract and parse individual JSON objects
      try {
        const objectRegex = /\{([\s\S]*?)\}(?=\s*,|\s*\]|\s*$)/g;
        const matches = Array.from(responseContent.matchAll(objectRegex));
        
        if (matches && matches.length > 0) {
          const parsedObjects = [];
          
          for (const match of matches) {
            try {
              // Add curly braces back
              const objStr = '{' + match[1] + '}';
              // Fix common JSON issues
              const fixedStr = objStr
                .replace(/,\s*\}/g, '}') // Remove trailing commas
                .replace(/([\w]+):/g, '"$1":') // Quote unquoted keys
                .replace(/:\s*'([^']*?)'/g, ':"$1"'); // Replace single quotes with double quotes
              
              const obj = JSON.parse(fixedStr);
              parsedObjects.push(obj);
            } catch (err) {
              // Skip objects that can't be parsed
              console.log('Failed to parse individual object');
            }
          }
          
          if (parsedObjects.length > 0) {
            console.log('Successfully parsed individual objects:', parsedObjects.length);
            return parsedObjects.map(item => this.validateAndCleanSuggestion(item, originalIdea));
          }
        }
      } catch (e) {
        console.log('Individual object parsing failed:', e.message);
      }
      
      // If all parsing strategies fail, return mock suggestions
      console.warn('All JSON parsing strategies failed, using mock suggestions');
      return this.generateMockSuggestions(originalIdea, 3);
    } catch (error) {
      console.error('Error in parseSuggestionsResponse:', error);
      return this.generateMockSuggestions(originalIdea, 3);
    }
  }

  /**
   * Parse the AI response into a merged suggestion
   */
  private parseMergedSuggestion(responseContent: string, originalSuggestions: Suggestion[]): Suggestion {
    try {
      // Log the response for debugging
      console.log('Processing merged suggestion response length:', responseContent.length);

      // Try all the same JSON parsing strategies as in parseSuggestionsResponse
      let mergedSuggestion = null;

      // Try standard JSON parsing
      try {
        const result = JSON.parse(responseContent);
        if (result && typeof result === 'object' && !Array.isArray(result)) {
          mergedSuggestion = result;
        }
      } catch (e) {
        // Try JSON5 which is more lenient
        try {
          const result = JSON5.parse(responseContent);
          if (result && typeof result === 'object' && !Array.isArray(result)) {
            mergedSuggestion = result;
          }
        } catch (e2) {
          // Try to extract object using regex
          try {
            const jsonObjectMatch = responseContent.match(/\{([\s\S]*?)\}/);
            if (jsonObjectMatch && jsonObjectMatch[0]) {
              const extractedJson = jsonObjectMatch[0];
              try {
                mergedSuggestion = JSON.parse(extractedJson);
              } catch (e3) {
                // Try with JSON5
                try {
                  mergedSuggestion = JSON5.parse(extractedJson);
                } catch (e4) {
                  // All parsing attempts failed
                }
              }
            }
          } catch (e3) {
            // Regex extraction failed
          }
        }
      }

      if (mergedSuggestion) {
        console.log('Successfully parsed merged suggestion');

        // Validate and ensure the title indicates it's a merged concept
        const validatedSuggestion = this.validateAndCleanSuggestion(mergedSuggestion, null);

        // Make sure the title indicates it's a merged concept
        if (!validatedSuggestion.title.includes('(Merged Concept)')) {
          validatedSuggestion.title += ' (Merged Concept)';
        }

        return validatedSuggestion;
      }

      // If no JSON object found or parsing failed, fall back to basic merge
      console.warn('Failed to parse AI response as JSON object, using basic merge');
      return this.createBasicMergedSuggestion(originalSuggestions);
    } catch (error) {
      console.error('Error parsing AI merge response:', error);
      return this.createBasicMergedSuggestion(originalSuggestions);
    }
  }

  /**
   * Parse the AI response into a regenerated suggestion
   */
  private parseRegeneratedSuggestion(responseContent: string, originalSuggestion: Suggestion): Suggestion {
    try {
      // Try to extract and parse a single JSON object using same strategies as parseMergedSuggestion
      let regeneratedSuggestion = null;

      // Try standard JSON parsing
      try {
        const result = JSON.parse(responseContent);
        if (result && typeof result === 'object' && !Array.isArray(result)) {
          regeneratedSuggestion = result;
        }
      } catch (e) {
        // Try JSON5 which is more lenient
        try {
          const result = JSON5.parse(responseContent);
          if (result && typeof result === 'object' && !Array.isArray(result)) {
            regeneratedSuggestion = result;
          }
        } catch (e2) {
          // Try to extract object using regex
          try {
            const jsonObjectMatch = responseContent.match(/\{([\s\S]*?)\}/);
            if (jsonObjectMatch && jsonObjectMatch[0]) {
              const extractedJson = jsonObjectMatch[0];
              try {
                regeneratedSuggestion = JSON.parse(extractedJson);
              } catch (e3) {
                // Try with JSON5
                try {
                  regeneratedSuggestion = JSON5.parse(extractedJson);
                } catch (e4) {
                  // All parsing attempts failed
                }
              }
            }
          } catch (e3) {
            // Regex extraction failed
          }
        }
      }

      if (regeneratedSuggestion) {
        console.log('Successfully parsed regenerated suggestion');
        // Validate and clean up the suggestion
        return this.validateAndCleanSuggestion(regeneratedSuggestion, null);
      }

      // If no JSON object found or parsing failed, return a modified version of the original
      console.warn('Failed to parse AI regeneration response as JSON object, using modified original');
      return {
        ...originalSuggestion,
        title: `${originalSuggestion.title} (Regenerated)`,
        description: `Improved version of: ${originalSuggestion.description}`
      };
    } catch (error) {
      console.error('Error parsing AI regeneration response:', error);
      return {
        ...originalSuggestion,
        title: `${originalSuggestion.title} (Regenerated)`,
        description: `Improved version of: ${originalSuggestion.description}`
      };
    }
  }

  /**
   * Validate and ensure all required fields are present in a suggestion
   */
  private validateAndCleanSuggestion(suggestion: any, originalIdea: IdeaPlaygroundIdea | null): Suggestion {
    // Default values from original idea if available
    const defaultTitle = originalIdea ? `Variation of ${originalIdea.title}` : 'New Business Idea';
    const defaultDescription = originalIdea?.description || 'No description provided';
    const defaultProblemStatement = originalIdea?.problem_statement || 'Problem statement not specified';
    const defaultSolutionConcept = originalIdea?.solution_concept || 'Solution not specified';

    // Ensure all required fields exist
    return {
      title: suggestion.title || defaultTitle,
      description: suggestion.description || defaultDescription,
      problem_statement: suggestion.problem_statement || defaultProblemStatement,
      solution_concept: suggestion.solution_concept || defaultSolutionConcept,
      target_audience: suggestion.target_audience || 'General market',
      unique_value: suggestion.unique_value || 'Unique value proposition not specified',
      business_model: suggestion.business_model || 'Business model not specified',
      marketing_strategy: suggestion.marketing_strategy || 'Marketing strategy not specified',
      revenue_model: suggestion.revenue_model || 'Revenue model not specified',
      go_to_market: suggestion.go_to_market || 'Go-to-market strategy not specified',
      market_size: suggestion.market_size || 'Market size not estimated',
      competition: Array.isArray(suggestion.competition) ? suggestion.competition : ['Not specified'],
      revenue_streams: Array.isArray(suggestion.revenue_streams) ? suggestion.revenue_streams : ['Not specified'],
      cost_structure: Array.isArray(suggestion.cost_structure) ? suggestion.cost_structure : ['Not specified'],
      key_metrics: Array.isArray(suggestion.key_metrics) ? suggestion.key_metrics : ['Not specified'],
      strengths: Array.isArray(suggestion.strengths) ? suggestion.strengths : ['Not specified'],
      weaknesses: Array.isArray(suggestion.weaknesses) ? suggestion.weaknesses : ['Not specified'],
      opportunities: Array.isArray(suggestion.opportunities) ? suggestion.opportunities : ['Not specified'],
      threats: Array.isArray(suggestion.threats) ? suggestion.threats : ['Not specified']
    };
  }

  /**
   * Create a basic merged suggestion from multiple suggestions
   */
  private createBasicMergedSuggestion(suggestions: Suggestion[]): Suggestion {
    if (suggestions.length === 0) {
      throw new Error('No suggestions to merge');
    }

    const baseSuggestion = suggestions[0];
    const allTitles = suggestions.map(s => s.title.replace(/ \(Merged Concept\)$/, ''));

    // Create a title that references the merged concepts
    const mergedTitle = allTitles.length <= 2
      ? `${allTitles.join(' + ')} (Merged Concept)`
      : `${allTitles[0]} + ${allTitles.length - 1} More (Merged Concept)`;

    // Combine all unique elements from arrays
    const combineUnique = (field: keyof Suggestion) => {
      const allItems = suggestions.flatMap(s => {
        const value = s[field];
        return Array.isArray(value) ? value : [];
      });
      return [...new Set(allItems)].slice(0, 5); // Limit to 5 items
    };

    return {
      title: mergedTitle,
      description: `A merged concept combining the best elements of ${allTitles.join(', ')}.`,
      problem_statement: baseSuggestion.problem_statement,
      solution_concept: `Combined approach that integrates: ${suggestions.map(s => s.solution_concept).join('; ')}`,
      target_audience: baseSuggestion.target_audience,
      unique_value: `Multi-faceted value proposition: ${suggestions.map(s => s.unique_value).join('; ')}`,
      business_model: baseSuggestion.business_model,
      marketing_strategy: baseSuggestion.marketing_strategy,
      revenue_model: baseSuggestion.revenue_model,
      go_to_market: baseSuggestion.go_to_market,
      market_size: baseSuggestion.market_size,
      competition: combineUnique('competition'),
      revenue_streams: combineUnique('revenue_streams'),
      cost_structure: combineUnique('cost_structure'),
      key_metrics: combineUnique('key_metrics'),
      strengths: combineUnique('strengths'),
      weaknesses: combineUnique('weaknesses'),
      opportunities: combineUnique('opportunities'),
      threats: combineUnique('threats')
    };
  }

  /**
   * Generate mock suggestions based on an original idea (fallback method)
   */
  private generateMockSuggestions(idea: IdeaPlaygroundIdea, count: number): Suggestion[] {
    const mockSuggestions: Suggestion[] = [];

    const variants = [
      { suffix: 'Premium Edition', audience: 'Enterprise customers', model: 'Subscription' },
      { suffix: 'Lite Version', audience: 'Individual users', model: 'Freemium' },
      { suffix: 'Pro Edition', audience: 'Professional users', model: 'One-time purchase' },
      { suffix: 'Community Edition', audience: 'Communities and non-profits', model: 'Open source with paid support' },
      { suffix: 'Enterprise Solution', audience: 'Large corporations', model: 'Annual licensing' }
    ];

    // Generate the requested number of suggestions
    for (let i = 0; i < Math.min(count, variants.length); i++) {
      const variant = variants[i];

      mockSuggestions.push({
        title: `${idea.title} - ${variant.suffix}`,
        description: `A ${variant.suffix.toLowerCase()} of ${idea.title} targeting ${variant.audience.toLowerCase()}.`,
        problem_statement: idea.problem_statement || 'Problem statement not provided',
        solution_concept: idea.solution_concept || 'Solution concept not provided',
        target_audience: variant.audience,
        unique_value: `Specialized features for ${variant.audience.toLowerCase()}`,
        business_model: `${variant.model} model`,
        marketing_strategy: 'Digital marketing and industry partnerships',
        revenue_model: variant.model,
        go_to_market: 'Targeted launch to early adopters',
        market_size: 'Market size will depend on specific segment targeting',
        competition: ['Competitor A', 'Competitor B', 'Competitor C'],
        revenue_streams: ['Primary Revenue', 'Secondary Revenue', 'Tertiary Revenue'],
        cost_structure: ['Development', 'Marketing', 'Operations', 'Customer Support'],
        key_metrics: ['User Acquisition', 'Retention Rate', 'Revenue Per User', 'Customer Lifetime Value'],
        strengths: ['Market fit', 'Unique positioning'],
        weaknesses: ['Resource requirements', 'Market education needs'],
        opportunities: ['Growing market', 'Underserved segment'],
        threats: ['Established competitors', 'Regulatory changes']
      });
    }

    return mockSuggestions;
  }
}

// Export a singleton instance
export const ideaPathway1AIService = new IdeaPathway1AIService();

================
File: src/lib/services/idea-playground-pathway.service.ts
================
import { IdeaPlaygroundIdea } from '../types/idea-playground.types';
import {
  IdeaVariation,
  MergedIdea,
  IdeaVariationParams,
  IdeaMergeParams
} from '../types/idea-pathway.types';
import { supabase } from '../supabase';
import { generalLLMService } from './general-llm.service';
import { ideaPlaygroundService } from './idea-playground.service';
class IdeaPlaygroundPathwayService
----
async generateIdeaVariations(userId: string, params: IdeaVariationParams): Promise<IdeaVariation[]>
async updateVariationSelection(variationId: string, isSelected: boolean): Promise<boolean>
async mergeSelectedVariations(userId: string, params: IdeaMergeParams): Promise<MergedIdea[]>
async getMergedIdeasForCanvas(canvasId: string): Promise<MergedIdea[]>
async saveVariationAsIdea(userId: string, canvasId: string, variation: IdeaVariation): Promise<IdeaPlaygroundIdea>
async saveMergedIdeaAsIdea(userId: string, canvasId: string, mergedIdea: MergedIdea): Promise<IdeaPlaygroundIdea>
async updateIdeaStatus(ideaId: string, status: string): Promise<boolean>

================
File: src/lib/services/idea-playground-service-extension.ts
================
import { supabase } from '../supabase';
import { IdeaPlaygroundIdea } from '../types/idea-playground.types';
import { IdeaVariation, MergedIdea, IdeaVariationParams, IdeaMergeParams } from '../types/idea-pathway.types';
import { generalLLMService } from './general-llm.service';
async function generateIdeaVariations(userId: string, params: IdeaVariationParams): Promise<IdeaVariation[]>
async function updateVariationSelection(variationId: string, isSelected: boolean): Promise<boolean>
async function mergeSelectedVariations(userId: string, params: IdeaMergeParams): Promise<MergedIdea[]>
async function getMergedIdeasForCanvas(canvasId: string): Promise<MergedIdea[]>
async function saveVariationAsIdea(userId: string, canvasId: string, variation: IdeaVariation): Promise<IdeaPlaygroundIdea>
async function saveMergedIdeaAsIdea(userId: string, canvasId: string, mergedIdea: MergedIdea): Promise<IdeaPlaygroundIdea>
async function updateIdeaStatus(ideaId: string, status: string): Promise<boolean>

================
File: src/lib/services/idea-playground.service.extended.ts
================
import { supabase } from '../supabase';
import { generalLLMService } from './general-llm.service';
import {
  IdeaPlaygroundCanvas,
  IdeaPlaygroundIdea,
  IdeaPlaygroundComponent,
  IdeaPlaygroundFeedback,
  IdeaGenerationParams,
  IdeaRefinementParams,
  CompanyRelevance
} from '../types/idea-playground.types';
import {
  IdeaVariation,
  MergedIdea,
  IdeaVariationParams,
  IdeaMergeParams
} from '../types/idea-pathway.types';
----
export class IdeaPlaygroundService
----
constructor()
async createCanvas(userId: string, name: string, description?: string, companyId?: string): Promise<IdeaPlaygroundCanvas | null>
async getCanvasesForUser(userId: string, includeArchived: boolean = false): Promise<IdeaPlaygroundCanvas[]>
async getCanvases(userId: string, includeArchived: boolean = false): Promise<IdeaPlaygroundCanvas[]>
async getCanvas(canvasId: string): Promise<IdeaPlaygroundCanvas | null>
async updateCanvas(canvasId: string, updates: Partial<IdeaPlaygroundCanvas>): Promise<boolean>
async archiveCanvas(canvasId: string): Promise<boolean>
async generateIdeas(
    userId: string,
    canvasId: string,
    params: IdeaGenerationParams
): Promise<IdeaPlaygroundIdea[]>
----
// Try to extract JSON using multiple patterns
----
// Try to extract JSON from code blocks
----
// Try to extract JSON array pattern
----
// Try to extract any JSON object
----
.replace(/\\"/g, '"')  // Handle escaped quotes
.replace(/\n/g, ' ')   // Remove newlines
.replace(/,\s*}/g, '}') // Remove trailing commas in objects
.replace(/,\s*]/g, ']'); // Remove trailing commas in arrays
----
// Ensure the response is an array
----
// Generate company relevance if using company context
----
// Generate company relevance if using company context
----
implementation_timeline: Math.floor(Math.random() * 24) + 1 // 1-24 months
----
// Save the idea to the database
----
// Save components if provided
----
private createFallbackIdeas(content: string, canvasId: string): IdeaPlaygroundIdea[]
async getIdeasForCanvas(canvasId: string, includeArchived: boolean = false): Promise<IdeaPlaygroundIdea[]>
async getIdea(ideaId: string): Promise<IdeaPlaygroundIdea | null>
async updateIdea(ideaId: string, updates: Partial<IdeaPlaygroundIdea>): Promise<boolean>
async archiveIdea(ideaId: string): Promise<boolean>
async duplicateIdea(ideaId: string, newTitle?: string): Promise<IdeaPlaygroundIdea | null>
async moveIdeaToCanvas(ideaId: string, targetCanvasId: string): Promise<boolean>
async createComponent(ideaId: string, componentType: string, content: string): Promise<IdeaPlaygroundComponent | null>
async getComponentsForIdea(ideaId: string, componentType?: string): Promise<IdeaPlaygroundComponent[]>
async updateComponent(componentId: string, updates: Partial<IdeaPlaygroundComponent>): Promise<boolean>
async createFeedback(ideaId: string, feedback: Partial<IdeaPlaygroundFeedback>): Promise<IdeaPlaygroundFeedback | null>
async getFeedbackForIdea(ideaId: string): Promise<IdeaPlaygroundFeedback[]>
async refineIdea(
    userId: string,
    params: IdeaRefinementParams
): Promise<IdeaPlaygroundIdea | null>
----
// Try to extract JSON using multiple patterns
----
// Try to extract JSON from code blocks
----
// Try to extract JSON object pattern
----
.replace(/\\"/g, '"')  // Handle escaped quotes
.replace(/\n/g, ' ')   // Remove newlines
.replace(/,\s*}/g, '}'); // Remove trailing commas in objects
----
// Create a new version of the idea
----
private async createFallbackRefinedIdea(originalIdea: IdeaPlaygroundIdea, content: string): Promise<IdeaPlaygroundIdea | null>

================
File: src/lib/services/idea-playground.service.facade.ts
================
import {
  IdeaPlaygroundIdea,
  CanvasType,
  IdeaStatus,
  BusinessModelCanvas,
  ValuePropositionCanvas
} from '../types/idea-playground.types';
import { IdeaGenerationResult, RefinementResult } from '../types/idea-generation.types';
import { IdeaManagementService } from './idea-playground/idea-management.service';
import { RefinementService } from './idea-playground/refinement.service';
import { LLMOrchestrator } from './idea-playground/llm/orchestrator';
export interface IdeaGenerationParams {
  theme?: string;
  industry?: string;
  userContext?: string;
  constraints?: string[];
  userId: string;
}
export class IdeaPlaygroundFacade
----
constructor()
async getIdea(ideaId: string): Promise<IdeaPlaygroundIdea>
async getUserIdeas(userId: string): Promise<IdeaPlaygroundIdea[]>
async updateIdea(idea: IdeaPlaygroundIdea): Promise<IdeaPlaygroundIdea>
async deleteIdea(ideaId: string): Promise<void>
async setProtectionLevel(ideaId: string, level: string, userId: string): Promise<void>
async generateIdea(params: IdeaGenerationParams): Promise<IdeaPlaygroundIdea>
async refineIdea(
    idea: IdeaPlaygroundIdea,
    feedback: string,
    userId: string
): Promise<IdeaPlaygroundIdea>
async saveFeedback(ideaId: string, feedback: string, userId: string): Promise<void>
async getFeedbackHistory(ideaId: string): Promise<any[]>
async getRefinementHistory(ideaId: string): Promise<IdeaPlaygroundIdea[]>
async initialize(): Promise<void>
getLLMOrchestrator(): LLMOrchestrator

================
File: src/lib/services/idea-playground.service.ts
================
import { supabase } from '../supabase';
export enum IdeaStatus {
  DRAFT = 'draft',
  ACTIVE = 'active',
  ARCHIVED = 'archived',
  DELETED = 'deleted'
}
export interface IdeaPlaygroundIdea {
  id: string;
  title: string;
  description: string;
  problem_statement: string;
  solution_concept: string;
  target_audience: string;
  unique_value: string;
  business_model: string;
  status: IdeaStatus;
  createdAt: string;
  updatedAt: string;
  tags: string[];
  isFavorite: boolean;
  userId?: string;
  teamId?: string;
  canvasId?: string;
}
export interface IdeaPlaygroundCanvas {
  id: string;
  name: string;
  type: 'business-model' | 'value-proposition';
  ideaId: string;
  createdAt: string;
  elements: Record<string, any>;
}
export interface IdeaGenerationParams {
  problem_area?: string;
  industry?: string;
  count?: number;
  maxResults?: number;
  useCompanyContext?: boolean;
}
----
async getCanvases(userId: string)
async createCanvas(userId: string, name: string, description: string)
----
// Return a mock canvas object
----
// Idea operations
async getIdeasForCanvas(canvasId: string)
----
// Return example ideas
----
async getCanvasesForUser(userId: string)
async generateIdeas(userId: string, canvasId: string, params: IdeaGenerationParams)
async updateIdea(ideaId: string, updatedIdea: Partial<IdeaPlaygroundIdea>)
async updateIdeaStatus(ideaId: string, status: string)
async saveVariationAsIdea(userId: string, canvasId: string, variation: any)
async saveMergedIdeaAsIdea(userId: string, canvasId: string, mergedIdea: any)
// Idea refinement
async refineIdea(ideaId: string, feedback: string)
----
// In a real implementation, this would call OpenAI
----
// Return a mock refined idea
----
async generateVariations(ideaId: string, count: number = 3)
async applyRefinement(ideaId: string, refinement: any)
async saveIdea(userId: string, ideaId: string)
async unsaveIdea(userId: string, ideaId: string)
async toggleSaveIdea(userId: string, idea: any)

================
File: src/lib/services/journey-unified.service.ts
================
import { supabase } from '../supabase';
import {
  JourneyPhase,
  JourneyStep,
  CompanyJourneyStep,
  Tool,
  CompanyStepTool,
  CompanyStepProgressUpdate,
  JourneyStepComplete,
  PhaseWithProgress
} from '../types/journey-unified.types';
interface ToolComparisonResult {
  tool_id: string;
  name: string;
  description?: string;
  pros: string[];
  cons: string[];
  rating_avg?: number;
  usage_count?: number;
  comparison_data: {
    [key: string]: any;
  };
}
interface PhaseCompletionStats {
  phase_id: string;
  phase_name: string;
  total_steps: number;
  completed_steps: number;
  in_progress_steps: number;
  not_started_steps: number;
  skipped_steps: number;
  completion_percentage: number;
}
interface JourneyTimelineEvent {
  id: string;
  company_id: string;
  step_id: string;
  step_name: string;
  phase_id: string;
  phase_name: string;
  event_type: 'status_change' | 'tool_selection' | 'note_added';
  event_data: any;
  created_at: string;
  user_id?: string;
  user_name?: string;
}
export class JourneyUnifiedService
----
static async getPhases(): Promise<JourneyPhase[]>
static async getPhaseById(phaseId: string): Promise<JourneyPhase | null>
static async getSteps(options?:
static async getStepById(stepId: string): Promise<JourneyStep | null>
static async getCompanyProgress(companyId: string): Promise<CompanyJourneyStep[]>
static async getStepProgress(companyId: string, stepId: string): Promise<CompanyJourneyStep | null>
static async updateStepProgress(
    companyId: string,
    stepId: string,
    updates: CompanyStepProgressUpdate
): Promise<CompanyJourneyStep>
static async getToolsForStep(stepId: string): Promise<Tool[]>
static async getCompanyToolEvaluations(companyId: string, stepId: string): Promise<CompanyStepTool[]>
static async updateToolEvaluation(
    companyId: string,
    stepId: string,
    toolId: string,
    updates: {
      rating?: number;
      notes?: string;
      is_selected?: boolean;
      is_custom?: boolean;
    }
): Promise<CompanyStepTool>
static async getRecommendedTools(stepId: string, limit: number = 5): Promise<Tool[]>
static async getPersonalizedRecommendedTools(
    companyId: string,
    stepId: string,
    limit: number = 5
): Promise<Tool[]>
static async compareTool(toolIds: string[]): Promise<ToolComparisonResult[]>
static async compareTools(toolIds: string[]): Promise<ToolComparisonResult[]>
static async getStepComplete(stepId: string, companyId?: string): Promise<JourneyStepComplete>
/**
   * Add a custom tool for a specific company
   * Optionally associate with a step and set as selected
   */
static async addCustomTool(
    companyId: string,
    toolData: {
      name: string;
      description?: string;
      url?: string;
      type?: string;
      category?: string;
      is_premium?: boolean;
    },
    stepId?: string,
    isSelected?: boolean
): Promise<string>
----
// First create the tool
----
// ANALYTICS
/**
   * Get phase completion statistics for a company
   */
static async getPhaseCompletionStats(companyId: string): Promise<PhaseCompletionStats[]>
static async getJourneyTimelineEvents(
    companyId: string,
    limit: number = 20
): Promise<JourneyTimelineEvent[]>

================
File: src/lib/services/journeyAnalytics.service.ts
================
import { supabase } from '@/lib/supabase';
import { User } from '@supabase/supabase-js';
export type MetricType =
  | 'time_spent'
  | 'view_count'
  | 'completion_rate'
  | 'difficulty_rating'
  | 'user_rating'
  | 'feedback_count';
export type EntityType = 'challenge' | 'phase' | 'journey';
export interface AnalyticsMetric {
  value: number;
  unit?: string;
  metadata?: Record<string, any>;
}
export interface JourneyAnalytics {
  companyId: string;
  userId?: string;
  entityType: EntityType;
  entityId: string;
  metricType: MetricType;
  metricValue: AnalyticsMetric;
}
export interface AnalyticsFilter {
  startDate?: Date;
  endDate?: Date;
  entityType?: EntityType;
  entityId?: string;
  metricTypes?: MetricType[];
  userId?: string;
}
export interface AggregationOptions {
  period?: 'day' | 'week' | 'month' | 'quarter' | 'year' | 'all';
  key?: string;
  type?: string;
}
export interface ProgressStats {
  totalSteps: number;
  completedSteps: number;
  inProgressSteps: number;
  notStartedSteps: number;
  blockedSteps: number;
  completionPercentage: number;
  phases: Array<{
    phaseId: string;
    phaseName: string;
    totalSteps: number;
    completedSteps: number;
    completionPercentage: number;
  }>;
}
export interface TeamAssignmentStats {
  totalAssignments: number;
  pendingAssignments: number;
  inProgressAssignments: number;
  completedAssignments: number;
  blockedAssignments: number;
  users: Array<{
    userId: string;
    userName: string;
    totalAssignments: number;
    completedAssignments: number;
    completionPercentage: number;
  }>;
}
export class JourneyAnalyticsService
----
static async trackMetric(analytics: JourneyAnalytics): Promise<void>
static async trackTimeSpent(
    companyId: string,
    entityType: EntityType,
    entityId: string,
    timeInSeconds: number,
    userId?: string
): Promise<void>
static async trackView(
    companyId: string,
    entityType: EntityType,
    entityId: string,
    userId?: string
): Promise<void>
static async trackRating(
    companyId: string,
    entityType: EntityType,
    entityId: string,
    rating: number,
    userId?: string
): Promise<void>
static async getAnalytics(
    companyId: string,
    filter: AnalyticsFilter = {}
): Promise<JourneyAnalytics[]>
static async getAggregation(
    companyId: string,
    options: AggregationOptions = {},
    filter: AnalyticsFilter = {}
): Promise<any>
static async getProgressStats(
    companyId: string,
    journeyId?: string,
    startDate?: Date,
    endDate?: Date
): Promise<ProgressStats>
static async getTeamAssignmentStats(
    companyId: string,
    userId?: string
): Promise<TeamAssignmentStats>
static async getComparisonAnalytics(companyId: string): Promise<any>

================
File: src/lib/services/journeyBoard.service.ts
================
import { supabase } from "../supabase";
export async function getCompanyJourneyBoard(companyId: string)
export async function updateCompanyStep(companyId: string, stepId: string, updates: Partial<{
  status: string;
  order_index: number;
  notes: string;
  can_be_parallel: boolean;
  archived: boolean;
}>)
export async function addCompanyCustomStep(companyId: string, phaseId: string, name: string, description?: string)
export async function updateCompanyCustomStep(stepId: string, updates: Partial<
export async function deleteCompanyCustomStep(stepId: string)
export async function getCompanyJourneyAIRecommendations(companyId: string)
export async function askCompanyJourneyAIQuestion(companyId: string, stepId: string, question: string)

================
File: src/lib/services/journeyChallenges.service.ts
================
import { JourneyChallenge, challenge_status, CompanyChallengeProgress } from '../types/journey-challenges.types';
import { supabase } from '../supabase';
export class JourneyChallengesService
----
static async getPhases()
static async getChallenges(phaseId?: string)
static async getChallenge(challengeId: string): Promise<JourneyChallenge>
static async getCompanyProgress(companyId: string): Promise<Record<string, CompanyChallengeProgress>>
static async updateChallengeStatus(
    companyId: string,
    challengeId: string,
    status: challenge_status,
    notes?: string
)
static async getChallengeTools(challengeId: string)
static async createChallenge(challenge: Partial<JourneyChallenge>): Promise<JourneyChallenge>
static async updateChallenge(challengeId: string, updates: Partial<JourneyChallenge>): Promise<JourneyChallenge>
static async getCompanyProgressSummary(companyId: string)

================
File: src/lib/services/journeyContent.service.ts
================
import { supabase } from '../supabase';
interface TransformedRowData {
  csv_phase_order?: number;
  csv_step_order?: number;
  csv_phase_name?: string;
  name?: string;
  description?: string;
  guidance?: string;
  order_index?: number;
  order?: number;
  estimated_duration?: string;
  required?: boolean;
  is_company_formation_step?: boolean;
  ask_wheel_enabled?: boolean;
  ask_expert_enabled?: boolean;
  use_tool_enabled?: boolean;
  diy_enabled?: boolean;
  need_to_do?: boolean;
  need_explanation?: string;
  dedicated_tool?: boolean;
  tool_explanation?: string;
  steps_without_tool?: string;
  effort_difficulty?: string;
  staff_freelancers?: string;
  key_considerations?: string;
  bootstrap_mindset?: string;
  founder_skills?: string;
  url?: string;
  category?: string;
  subcategory?: string;
  pros?: string;
  cons?: string;
  customer_stage?: string;
  founded?: string;
  last_funding_round?: string;
  comp_svc_pkg?: string;
  ease_of_use?: string;
  affordability?: string;
  customer_support?: string;
  speed_of_setup?: string;
  customization?: string;
  range_of_services?: string;
  integration?: string;
  pro_assistance?: string;
  reputation?: string;
  reasoning_comp_svc_pkg?: string;
  reasoning_ease_of_use?: string;
  reasoning_affordability?: string;
  reasoning_customer_support?: string;
  reasoning_speed_of_setup?: string;
  reasoning_customization?: string;
  reasoning_range_of_services?: string;
  reasoning_integration?: string;
  reasoning_pro_assistance?: string;
  reasoning_reputation?: string;
  logo_url?: string;
  type?: string;
  ranking?: number;
  is_premium?: boolean;
  [key: string]: any;
}
----
async getPhases()
async upsertPhase(phase:
----
// This case should ideally be caught earlier, but throw here for safety
----
async updatePhase(phaseId: string, updates: Record<string, any>)
async deletePhase(phaseId: string)
async getSteps(phaseId: string)
async upsertStep(phaseId: string, step:
----
// This case should ideally be caught earlier, but throw here for safety
----
async updateStep(stepId: string, updates: Record<string, any>)
async deleteStep(stepId: string)
async getTools(stepId: string)
async upsertToolForStep(stepId: string, tool:
----
// This case should ideally be caught earlier, but throw here for safety
----
// Ensure URL is at least an empty string if not provided, as it might be NOT NULL in DB
----
async updateTool(toolId: string, updates: Record<string, any>)
async deleteTool(toolId: string)
async importWithMapping(
    sheetType: 'phase_step' | 'tool' | 'mixed' | 'unknown',
    transformedRows: TransformedRowData[],
    onProgress?: (progress: number) => void
): Promise<void>
----
const updateProgress = () =>
----
// 1. Upsert Phase if not already processed
----
name: phaseName, // Already checked non-empty
----
// 2. Upsert Step
----
name: stepName, // Already checked non-empty
----
// --- Process Tools (if applicable) ---
----
async exportToExcel()
async linkTaskToStep(taskId: string, stepId: string)
async unlinkTaskFromStep(taskId: string, stepId: string)

================
File: src/lib/services/journeySteps.service.ts
================
import { supabase } from "../supabase";
import {
  JourneyStep,
  EnhancedJourneyStep,
  JourneyPhase,
  CompanyStepProgress,
  StepFilterOptions,
  step_status,
  EnhancedStepResponse,
  PersonalizedToolRecommendation,
  mapChallengeToStep
} from '../types/journey-steps.types';
export async function getEnhancedSteps()
export async function getStepsByPhase(phaseId: string)
export async function getEnhancedStep(stepId: string)
export async function getFilteredSteps(
  companyId: string,
  options?: StepFilterOptions
)
export async function getCompanyStepProgress(companyId: string)
export async function updateStepProgress(
  companyId: string,
  stepId: string,
  status: step_status,
  notes?: string
)
export async function createCustomStep(
  companyId: string,
  phaseId: string,
  name: string,
  description: string,
  difficultyLevel: number,
  estimatedTimeMin: number,
  estimatedTimeMax: number,
  keyOutcomes: string[] = []
)
export async function updateStep(
  stepId: string,
  updates: Partial<JourneyStep>
)
export async function getJourneyPhases()
export async function getPersonalizedToolRecommendations(
  companyId: string,
  stepId: string
)
export async function markStepAsSkipped(
  companyId: string,
  stepId: string,
  reason?: string
)
export async function calculateOverallProgress(companyId: string)
export async function calculatePhaseProgress(
  companyId: string,
  phaseId: string
)
export async function getNextRecommendedStep(companyId: string)
export async function getChallengeById(challengeId: string)
export async function getChallenges(companyId: string, options?: StepFilterOptions)
export async function updateStepOrder(
  companyId: string,
  steps: Array<{id: string, order_index: number}>
)

================
File: src/lib/services/localStorage-cleaner.ts
================
export const cleanLocalStorage = (forceClear = false) =>

================
File: src/lib/services/logging.service.enhanced.ts
================
import { v4 as uuidv4 } from 'uuid';
import {
  LogEvent,
  UserActionEvent,
  AIInteractionEvent,
  LoggingSession,
  ClientInfo
} from '../types/logging.types';
class EnhancedLoggingService
----
constructor()
async initialize(): Promise<void>
async startSession(
    userId?: string,
    companyId?: string
): Promise<string>
async endSession(): Promise<void>
private getSessionDuration(): number | null
private collectClientInfo(): ClientInfo
setUserContext(
    userId: string | null,
    companyId?: string | null
): void
async logEvent(event: Omit<LogEvent, 'id' | 'created_at'>): Promise<string | null>
private storeLogLocally(event: LogEvent): void
private logSystemEventLocally(
    category: string,
    source: string,
    action: string,
    data: any = {}
): string
private getRequiredConsentType(eventType: string): string | null
async logUserAction(action: string, component?: string, data: any =
async logAIInteraction(action: string, data: any, metadata: any =
async logPageView(pagePath: string, pageTitle: string, referrer?: string, metadata: any =
async logNavigation(fromPath: string, toPath: string, navigationMethod: any, metadata: any =
async logError(error: Error | string, component?: string, context: any =
async logAPIRequest(endpoint: string, method: string, requestData?: any, responseData?: any, statusCode?: number, duration?: number): Promise<string | null>
async logSystemEvent(category: string, source: string, action: string, data: any =
async logFeatureUsage(featureName: string, action: string, data: any =
async logPerformance(metricName: string, value: number, unit?: string, context: any =
async logAuth(action: string, userId?: string, method?: string, success?: boolean, reason?: string): Promise<string | null>
setEnabled(enabled: boolean): void
isLoggingEnabled(): boolean
getSessionId(): string | null
isUsingLocalLogging(): boolean
getLocalLogs(): LogEvent[]
async getUserLogs(userId: string, startDate: string, endDate: string, eventTypes?: string[]): Promise<LogEvent[]>
async getSessionLogs(sessionId: string): Promise<LogEvent[]>
async applyRetentionPolicies(): Promise<void>

================
File: src/lib/services/logging.service.ts
================
export interface LoggingService {
  logEvent: (eventType: string | any, data?: any) => Promise<void>;
  startSession: (userId?: string, companyId?: string) => Promise<string>;
  endSession: (sessionId?: string) => Promise<void>;
  logError: (error: Error, context?: any) => Promise<void>;
  logNavigation: (path: string, referrer?: string) => Promise<void>;
  logInteraction: (elementId: string, action: string, data?: any) => Promise<void>;
  logPerformance: (metric: string, value: number, context?: any) => Promise<void>;
  getSessionId: () => string | null;
  logSystemEvent: (category: string, source: string, action: string, data?: any) => Promise<void>;
  logUserAction: (action: string, component: string, data?: any, metadata?: any) => Promise<string>;
  logAIInteraction: (action: string, data?: any, metadata?: any) => Promise<string>;
}
class DisabledLoggingService implements LoggingService
----
constructor()
async logEvent(eventType: string | any, data: any =
async startSession(userId?: string, companyId?: string): Promise<string>
async endSession(sessionId?: string): Promise<void>
async logError(error: Error, context: any =
async logNavigation(path: string, referrer: string = 'unknown'): Promise<void>
async logInteraction(elementId: string, action: string, data: any =
async logPerformance(metric: string, value: number, context: any =
getSessionId(): string | null
async logSystemEvent(category: string, source: string, action: string, data: any =
async logUserAction(action: string, component: string, data: any =
async logAIInteraction(action: string, data: any =

================
File: src/lib/services/mock-auth.service.ts
================
import { User } from '@supabase/supabase-js';
import { mockProfileService } from './mock-profile.service';
export class MockAuthService
----
constructor()
async signIn(): Promise<
async signOut(): Promise<
async getSession()
async getUser()
async refreshSession()
onAuthStateChange(callback: (event: string, session: any) => void)

================
File: src/lib/services/mock-general-llm.service.ts
================
import { GeneralLLMService, QueryContext } from './general-llm.service';
export class MockGeneralLLMService implements GeneralLLMService
----
constructor()
async query(input: string, context: QueryContext): Promise<any>

================
File: src/lib/services/mock-idea-playground.service.ts
================
import {
  IdeaPlaygroundCanvas,
  IdeaPlaygroundIdea,
  IdeaPlaygroundComponent,
  IdeaPlaygroundTag,
  IdeaPlaygroundFeedback,
  IdeaGenerationParams,
  IdeaRefinementParams,
  CompanyRelevance
} from '../types/idea-playground.types';
import { generalLLMService } from './general-llm.service';
export class MockIdeaPlaygroundService
----
constructor()
async createCanvas(userId: string, name: string, description?: string, companyId?: string): Promise<IdeaPlaygroundCanvas | null>
----
async generateIdeas(
    userId: string,
    canvasId: string,
    params: IdeaGenerationParams
): Promise<IdeaPlaygroundIdea[]>
----
// Try to extract JSON using multiple patterns
----
// Try to extract JSON from code blocks
----
// Try to extract JSON array pattern
----
// Try to extract any JSON object
----
.replace(/\\"/g, '"')  // Handle escaped quotes
.replace(/\n/g, ' ')   // Remove newlines
.replace(/,\s*}/g, '}') // Remove trailing commas in objects
.replace(/,\s*]/g, ']'); // Remove trailing commas in arrays
----
// Ensure the response is an array
----
// Generate company relevance if using company context
----
// Generate company relevance if using company context
----
// Create a new idea
----
// Save the idea
----
// Save components if provided
----
private createFallbackIdeas(content: string, canvasId: string): IdeaPlaygroundIdea[]
----
async createComponent(ideaId: string, componentType: string, content: string): Promise<IdeaPlaygroundComponent | null>
private createIdeaRefinementPrompt(originalIdea: IdeaPlaygroundIdea, params: IdeaRefinementParams): string
// Helper methods
private createIdeaGenerationPrompt(params: IdeaGenerationParams, useCompanyContext: boolean): string
private async generateCompanyRelevance(idea: any): Promise<CompanyRelevance>

================
File: src/lib/services/mock-profile.service.ts
================
import { ExtendedUserProfile } from '../types/extended-profile.types';
export class MockProfileService
----
constructor()
async getProfile(userId: string): Promise<ExtendedUserProfile | null>
async updateProfile(userId: string, updates: Partial<ExtendedUserProfile>): Promise<ExtendedUserProfile | null>

================
File: src/lib/services/model-abstraction.service.ts
================
import openai from '../openai-client';
import { supabase } from '../supabase';
export interface ModelAbstractionService {
  generateAbstraction: (companyIds: string[]) => Promise<any>;
  getAbstractionForCompanies: (companyIds: string[]) => Promise<any>;
}
export class OpenAIModelAbstractionService implements ModelAbstractionService
----
async generateAbstraction(companyIds: string[]): Promise<any>
async getAbstractionForCompanies(companyIds: string[]): Promise<any>
private extractKeyInsights(companyData: any): any
private countByProperty(array: any[], property: string): Record<string, number>

================
File: src/lib/services/model-manager.service.ts
================
import { supabase } from '../supabase';
import { companyModelService, CompanyModelService } from './company-model.service';
import { modelAbstractionService, ModelAbstractionService } from './model-abstraction.service';
import { generalLLMService, GeneralLLMService } from './general-llm.service';
export interface ModelManagerStats {
  companyModelsCount: number;
  abstractionsCount: number;
  lastUpdated: string | null;
  isOperational: boolean;
  totalQueries: number;
  avgQueryTime: number;
  queriesToday: number;
}
export class ModelManager
----
constructor()
async trainCompanyModel(companyId: string): Promise<
async generateAbstraction(companyIds: string[]): Promise<
async query(input: string, context: {
    userId: string;
    companyId?: string;
    useExistingModels?: boolean;
}): Promise<
async getCompanyModelStatus(companyId: string): Promise<
async checkSystemStatus(): Promise<ModelManagerStats>
async getTrainingLogs(limit: number = 10): Promise<any[]>
async getQueryLogs(limit: number = 10): Promise<any[]>

================
File: src/lib/services/model-training.service.ts
================
export interface ModelTrainingService {
  extractFeatures: (eventType: string, options?: any) => Promise<void>;
  recordFeedback: (feedback: any) => Promise<void>;
  trainModel: (modelId: string, options?: any) => Promise<void>;
  evaluateModel: (modelId: string, testData?: any) => Promise<any>;
}
class DisabledModelTrainingService implements ModelTrainingService
----
constructor()
async extractFeatures(eventType: string, options: any =
async recordFeedback(feedback: any): Promise<void>
async trainModel(modelId: string, options: any =
async evaluateModel(modelId: string, testData: any =

================
File: src/lib/services/multi-persona-profile.service.ts
================
import { supabase } from '../supabase';
import {
  CoreIdentity,
  Persona,
  UserProfile,
  SystemMetadata,
  OnboardingState
} from '../types/multi-persona-profile.types';
export class MultiPersonaProfileService
----
async getProfile(userId: string): Promise<UserProfile | null>
async getPersonas(userId: string): Promise<Persona[]>
async getActivePersona(userId: string): Promise<Persona | null>
async getPersonaById(personaId: string): Promise<Persona | null>
async createPersona(userId: string, personaData: Partial<Persona>): Promise<Persona | null>
async updatePersona(personaId: string, updates: Partial<Persona>): Promise<Persona | null>
async deletePersona(personaId: string): Promise<boolean>
async setActivePersona(userId: string, personaId: string): Promise<boolean>
async evaluateContextRules(
    userId: string,
    context: string,
    contextValue: string
): Promise<string | null>
async addContextRule(
    userId: string,
    personaId: string,
    context: string,
    condition: string,
    priority: number = 0
): Promise<boolean>
async getOnboardingState(userId: string, personaId: string): Promise<OnboardingState | null>
async updateOnboardingState(
    userId: string,
    personaId: string,
    updates: Partial<OnboardingState>
): Promise<OnboardingState | null>
async isOnboardingComplete(userId: string, personaId: string): Promise<boolean>
async checkOnboardingNeeded(userId: string): Promise<
private async createDefaultProfile(userId: string): Promise<UserProfile | null>
private async createDefaultPersona(userId: string): Promise<Persona | null>
private async createOnboardingState(userId: string, personaId: string): Promise<OnboardingState | null>
private async recordPersonaSwitch(
    userId: string,
    toPersonaId: string,
    trigger: 'manual' | 'auto' | 'rule',
    context?: string
): Promise<void>
private getDefaultPersonaData(type: string): Partial<Persona>
private getDefaultSystemMetadata(): SystemMetadata
----
enum RoleCategory {
  FOUNDER = 'FOUNDER',
  COMPANY_MEMBER = 'COMPANY_MEMBER',
  SERVICE_PROVIDER = 'SERVICE_PROVIDER',
  INVESTOR = 'INVESTOR',
  ADVISOR = 'ADVISOR',
  COMMUNITY_MEMBER = 'COMMUNITY_MEMBER',
  CUSTOM = 'CUSTOM'
}

================
File: src/lib/services/onboarding.service.ts
================
import { supabase } from '../supabase';
export enum UserRole {
  FOUNDER = 'FOUNDER',
  COMPANY_MEMBER = 'COMPANY_MEMBER',
  SERVICE_PROVIDER = 'SERVICE_PROVIDER'
}
export enum CompanyStage {
  IDEA_STAGE = 'IDEA_STAGE',
  SOLID_IDEA = 'SOLID_IDEA',
  FORMED_COMPANY = 'FORMED_COMPANY'
}
export enum IndustryCategory {
  TECHNOLOGY = 'TECHNOLOGY',
  HEALTHCARE = 'HEALTHCARE',
  FINANCE = 'FINANCE',
  EDUCATION = 'EDUCATION',
  RETAIL = 'RETAIL',
  MANUFACTURING = 'MANUFACTURING',
  ENTERTAINMENT = 'ENTERTAINMENT',
  OTHER = 'OTHER'
}
export enum UserSkillLevel {
  BEGINNER = 'BEGINNER',
  INTERMEDIATE = 'INTERMEDIATE',
  EXPERT = 'EXPERT'
}
export interface OnboardingData {
  userRole?: UserRole;
  companyStage?: CompanyStage;
  industryCategory?: IndustryCategory;
  skillLevel?: UserSkillLevel;
  goals?: string[];
  preferredTheme?: 'light' | 'dark' | 'system';
  notificationPreferences?: Record<string, boolean>;
}
interface FeatureInfo {
  title: string;
  description: string;
  path: string;
  priority: number;
}
interface SetupProgress {
  current_step: string;
  form_data: OnboardingData;
  completed_steps: string[];
  last_updated: string;
}
class OnboardingService
----
async getRecommendedFeatures(userId: string): Promise<string[]>
getFeatureInfo(featureId: string): FeatureInfo
async saveOnboardingData(userId: string, stepData: Record<string, any>): Promise<void>
async updateCurrentStep(userId: string, step: string): Promise<void>
async skipOnboarding(userId: string): Promise<void>
async getPersonalizedWelcome(userId: string): Promise<string>

================
File: src/lib/services/privacy.service.ts
================
import { useAuthStore } from '../store';
export interface PrivacyService {
  getUserConsent: (userId: string) => Promise<any>;
  updateUserConsent: (userId: string, settings: any) => Promise<void>;
  logEvent: (eventData: any) => Promise<void>;
}
class DisabledPrivacyService implements PrivacyService
----
constructor()
async getUserConsent(userId: string): Promise<any>
async updateUserConsent(userId: string, settings: any): Promise<void>
async logEvent(eventData: any): Promise<void>

================
File: src/lib/services/profile.service.ts
================
import { supabase } from '../supabase';
import { User } from '../types/profile.types';
export class ProfileService
----
constructor()
async getProfile(userId: string): Promise<User | null>
async updateProfile(userId: string, updates: Partial<User>): Promise<User | null>
async getCompanyProfiles(companyId: string): Promise<User[]>

================
File: src/lib/services/recommendation.service.ts
================
import { supabase } from '@/lib/supabase';
import type {
  StepRecommendation,
  RecommendationScore,
  StepRelationship,
  EnhancedJourneyStep
} from '@/lib/types/journey-steps.types';
interface StepAssistantResource {
  title: string;
  description: string;
  url: string;
  type: 'video' | 'document' | 'article' | 'tool';
}
interface StepAssistantSuggestion {
  text: string;
  priority: number;
}
interface StepAssistantData {
  suggestions: StepAssistantSuggestion[];
  resources: StepAssistantResource[];
}
interface StepAssistantResponse {
  answer: string;
  confidence: number;
  sources?: string[];
}
interface EventData {
  [key: string]: any;
}
export class RecommendationService
----
public static async getRecommendations(
    companyId: string,
    limit: number = 5,
    context?: {
      selectedPhases?: string[],
      focusAreas?: string[],
      timeConstraint?: number
    }
): Promise<StepRecommendation[]>
public static async getStepRelationships(
    stepId: string,
    depth: number = 1
): Promise<StepRelationship[]>
public static async getOptimizedPath(
    companyId: string,
    timeConstraint?: number,
    maxSteps: number = 10
): Promise<StepRecommendation[]>
public static async getJourneyAnalytics(companyId: string): Promise<any>
public static async getStepAssistantData(
    stepId: string,
    companyId: string
): Promise<StepAssistantData>
public static async askStepAssistant(
    stepId: string,
    question: string,
    companyId: string
): Promise<StepAssistantResponse>
private static async trackAssistantEvent(
    stepId: string,
    companyId: string,
    eventType: 'view' | 'question' | 'suggestion_click' | 'resource_click',
    data: EventData
): Promise<void>
private static async generateSuggestedQuestions(
    step: any,
    company: any
): Promise<StepAssistantSuggestion[]>
private static generateAnswer(
    question: string,
    step: any,
    knowledgeBase: any[]
): string
private static mapResourceType(type: string): 'video' | 'document' | 'article' | 'tool'
private static async trackRecommendationEvent(
    companyId: string,
    eventType: 'request' | 'success' | 'error',
    data: EventData
): Promise<void>
private static async trackRelationshipEvent(
    stepId: string,
    eventType: 'request' | 'success' | 'error',
    data: EventData
): Promise<void>
private static async scoreSteps(
    steps: any[],
    companyProgress: any[],
    companyData: any,
    context?: any
): Promise<RecommendationScore[]>
private static orderStepsOptimally(steps: RecommendationScore[]): RecommendationScore[]
----
const prerequisitesMet = (step: any, orderedStepIds: string[]): boolean =>
----
private static calculatePrerequisiteScore(
    step: any,
    completedStepIds: string[]
): number
private static findIndustryRelevance(
    stepId: string,
    industryPopularity: any[]
): number
private static findSequenceRelevance(
    stepId: string,
    commonSequences: any[]
): number
private static calculateStageRelevance(
    step: any,
    companyStage: string
): number
private static calculateModelRelevance(
    step: any,
    businessModel: string
): number
private static calculatePatternRelevance(
    stepId: string,
    similarCompanyPatterns: any[]
): number
private static calculateFocusRelevance(
    step: any,
    companyFocusAreas: string[],
    contextFocusAreas: string[]
): number
private static calculateTimeRelevance(
    step: any,
    timeConstraintDays: number
): number

================
File: src/lib/services/settings.ts
================
/**
   * Default model to use for AI operations
   */

================
File: src/lib/services/standup-ai.service.ts
================
import { GeneralLLMService, QueryContext } from './general-llm.service';
import { CompanyModelService } from './company-model.service';
import { conversationMemoryService, StandupMemory } from './conversation-memory.service';
import { v4 as uuidv4 } from 'uuid';
import { ideaMemoryService } from './idea-memory.service';
import { featureFlagsService } from './feature-flags.service';
import { useAuthStore } from '../store';
export interface StandupEntry {
  accomplished: string;
  working_on: string;
  blockers: string;
  goals: string;
  answers?: Record<string, string> | null;
}
export interface StandupFeedback {
  content: string;
  follow_up_questions?: string[];
}
export interface StandupSummary {
  content: string;
  strengths: string[];
  areas_for_improvement: string[];
  opportunities: string[];
  risks: string[];
  strategic_recommendations: string[];
}
export interface SectionConversation {
  messages: Array<{role: 'user' | 'assistant', content: string}>;
}
export interface StandupTask {
  id?: string;
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  status?: 'pending' | 'in_progress' | 'completed';
  estimated_hours: number;
  task_type: string;
  implementation_tips: string[];
  potential_challenges: string[];
  success_metrics: string[];
  resources: {
    title: string;
    url: string;
    type: string;
    description: string;
  }[];
  learning_resources: {
    title: string;
    url: string;
    type: string;
    platform: string;
    description: string;
  }[];
  tools: {
    name: string;
    url: string;
    category: string;
    description: string;
  }[];
}
export class StandupAIService
----
constructor(
private getSectionConversation(
    currentEntry: StandupEntry,
    section: 'accomplished' | 'working_on' | 'blockers' | 'goals'
): SectionConversation
private trackQuestion(userId: string, question: string): void
private hasAskedQuestion(userId: string, question: string): boolean
private calculateSimilarity(str1: string, str2: string): number
private checkAndResetLLMService(): void
async generateSectionFeedback(
    section: 'accomplished' | 'working_on' | 'blockers' | 'goals',
    currentInput: string,
    currentEntry: StandupEntry,
    context: QueryContext
): Promise<StandupFeedback>
----
// Parse the response
----
// Add assistant response to conversation history
----
// For the new format, remove the questions from the end of the content
// This prevents the same question from appearing twice
----
// Clean up any trailing punctuation
----
// Fallback to a generic response
----
// Fallback to a generic response
----
async generateStandupSummary(entry: StandupEntry, context: QueryContext): Promise<StandupSummary>
----
// Check LLM service feature flags without resetting
----
// Check if enhanced idea generation is enabled but don't wait on it
----
// Get standup memory for context
----
// Get response using all three sources
----
// Parse the JSON response
----
// Try to extract JSON if it exists
----
// Fallback if JSON parsing fails
----
// Fallback
----
// Fallback
----
async generateTasks(entry: StandupEntry, userId: string, context: QueryContext): Promise<StandupTask[]>
----
// Check LLM service feature flags without resetting
----
// Check if enhanced idea generation is enabled but don't wait on it
----
// Get standup memory for context
----
// Get response using all three sources
----
// Parse the JSON response
----
// Try to extract JSON if it exists
----
// Ensure the response is an array
----
// Map and validate each task
----
id: uuidv4(), // Generate a unique ID for each task
----
status: 'pending' as const, // Set default status
----
// Fallback if JSON parsing fails
----
// Fallback if JSON extraction fails
----
// Fallback
----
// Fallback
----
// Helper method to get fallback tasks
private getFallbackTasks(): StandupTask[]
private createSectionPrompt(
    section: 'accomplished' | 'working_on' | 'blockers' | 'goals',
    currentInput: string,
    currentEntry: StandupEntry,
    standupMemory?: StandupMemory
): string
----
// Determine startup stage - if no entries or memory, assume idea stage
----
// Section-specific prompting with more context and personality
----
// Add context from previous standups if available
----
// Add relevant context based on the section
----
private createSummaryPrompt(entry: StandupEntry, standupMemory?: StandupMemory): string
----
const previousStandup = standupMemory.recentStandups[1]; // Get the second most recent standup
----
private createTasksPrompt(entry: StandupEntry, standupMemory?: StandupMemory): string
----
// Determine startup stage
----
// Add context from previous standups if available
----
private extractFollowUpQuestions(content: string): string[]
----
// If no labeled questions found, look for questions at the end of the content
// Split content into sentences
----
// Check the last 1-2 sentences for questions
----
private validatePriority(priority: string): 'low' | 'medium' | 'high'
----
import { generalLLMService } from './general-llm.service';
import { companyModelService } from './company-model.service';

================
File: src/lib/services/task.service.ts
================
import { supabase } from '../supabase';
import { Task } from '../types/task.types';
import { v4 as uuidv4 } from 'uuid';
export interface TaskService {
  getTasks: (options: { category?: string; standupId?: string }) => Promise<Task[]>;
  createTask: (task: Partial<Task>) => Promise<Task>;
  updateTask: (taskId: string, updates: Partial<Task>) => Promise<void>;
  deleteTask: (taskId: string) => Promise<void>;
}
class SupabaseTaskService implements TaskService
----
async getTasks(
async createTask(task: Partial<Task>): Promise<Task>
async updateTask(taskId: string, updates: Partial<Task>): Promise<void>
async deleteTask(taskId: string): Promise<void>

================
File: src/lib/services/terminology.service.ts
================
import { supabase } from '../supabase';
import {
  TerminologyEntityType,
  TerminologyValue,
  TerminologyMap,
  ResolvedTerminologyMap,
  TerminologyOverrideBehavior,
  TerminologySettings
} from '../types/terminology.types';
import {
  deepGet,
  applyTerminologyOverride,
  createDefaultTerminology,
  predefinedTerminologySets,
  flattenTerminology,
  unflattenTerminology
} from '../utils/terminology-utils';
----
export class TerminologyService
----
private static getTableNameForEntityType(entityType: TerminologyEntityType): string
private static getIdColumnForEntityType(entityType: TerminologyEntityType): string
static async deleteTerminologyForCategory(
    entityType: TerminologyEntityType,
    entityId: string,
    category: string
): Promise<boolean>
static async saveTerminology(
    entityType: TerminologyEntityType,
    entityId: string,
    records: Array<{
      key: string,
      value: TerminologyValue,
      override_behavior?: TerminologyOverrideBehavior
    }>
): Promise<boolean>
static async getDefaultTerminology(): Promise<ResolvedTerminologyMap>
static async resolveTerminology(
    entityType: TerminologyEntityType,
    entityId: string,
    options: { keys?: string[], ignoreCache?: boolean } = {}
): Promise<ResolvedTerminologyMap>
private static async getTerminologySettings(
    entityType: TerminologyEntityType,
    entityId: string
): Promise<TerminologySettings>
private static async fetchInheritedTerminology(
    entityType: TerminologyEntityType,
    entityId: string,
    baseTerminology: ResolvedTerminologyMap,
    settings: TerminologySettings
): Promise<ResolvedTerminologyMap>
private static async getUserInheritancePath(
    userId: string
): Promise<Array<
private static async getTeamInheritancePath(
    teamId: string
): Promise<Array<
private static async getCompanyInheritancePath(
    companyId: string
): Promise<Array<
private static async getOrganizationInheritancePath(
    orgId: string
): Promise<Array<
private static async getEntityTerminology(
    entityType: TerminologyEntityType,
    entityId: string
): Promise<TerminologyMap>
private static mergeTerminology(
    base: ResolvedTerminologyMap,
    override: any
): ResolvedTerminologyMap
static clearCache(entityType?: TerminologyEntityType, entityId?: string): void
static async applyPredefinedTerminology(
    entityType: TerminologyEntityType,
    entityId: string,
    templateKey: string
): Promise<boolean>

================
File: src/lib/services/toolSelection.service.ts
================
import { supabase } from "../supabase";
import { ScorecardCriterion } from "../../components/company/journey/ToolSelector/ScorecardBuilder";
import { PersonalizedToolRecommendation } from "../types/journey-steps.types";
export async function getStepTools(stepId: string)
export async function getPersonalizedToolRecommendations(companyId: string, stepId: string)
export async function getCompanyCustomTools(companyId: string, stepId: string)
export async function addCompanyCustomTool(
  companyId: string,
  stepId: string,
  tool: { name: string; url: string; description?: string; logo_url?: string }
)
export async function saveScorecardDefinition(
  companyId: string,
  toolId: string,
  stepId: string,
  criteria: ScorecardCriterion[],
  userId: string,
  name: string
)
export async function getScorecardDefinitions(companyId: string, stepId: string)
export async function saveToolEvaluation(
  scorecardId: string,
  toolId: string,
  userId: string,
  responses: Record<string, any>,
  notes: string
)
export async function getToolEvaluations(toolId: string, stepId: string)
export async function uploadToolDocument(
  companyId: string,
  toolId: string,
  userId: string,
  fileUrl: string,
  fileType?: string,
  description?: string
)
export async function getToolDocuments(toolId: string)
export async function selectCompanyToolForStep(
  companyId: string,
  stepId: string,
  toolId: string
)
export async function getAllCompanySelectedTools(companyId: string)
export async function getSimilarCompaniesUsingTool(
  companyId: string,
  toolId: string,
  limit: number = 5
)
export async function compareToolUsageStatistics(toolIds: string[])

================
File: src/lib/services/toolSubmission.service.ts
================
async submitToolSubmission({
    submittedBy,
    companyId,
    name,
    url,
    description,
    category,
    subcategory,
    tags,
    journeyStepId
  }: {
    submittedBy: string;
    companyId: string;
    name: string;
    url?: string;
    description?: string;
    category?: string;
    subcategory?: string;
    tags?: string[];
    journeyStepId?: string;
})
async enrichToolSubmission(toolSubmissionId: string)
async promoteToolSubmission(toolSubmissionId: string, promotedBy: string)
async rejectToolSubmission(toolSubmissionId: string, rejectedBy: string, reason: string)
async listPendingToolSubmissions()

================
File: src/lib/services/unified-idea.service.ts
================
import { supabase } from '../supabase';
import { v4 as uuidv4 } from 'uuid';
import { generalLLMService } from './general-llm.service';
import {
  IdeaWorkspace,
  UnifiedIdea,
  IdeaAnalysis,
  IdeaComparison,
  IdeaComparisonResult,
  IdeaMerge,
  IdeaGenerationParams,
  IdeaContext
} from '../types/unified-idea.types';
export class UnifiedIdeaService
----
constructor()
async createWorkspace(
    userId: string,
    title: string = 'New Workspace',
    description: string = ''
): Promise<IdeaWorkspace | null>
async getWorkspaces(userId: string): Promise<IdeaWorkspace[]>
async getWorkspace(workspaceId: string): Promise<IdeaWorkspace | null>
async updateWorkspace(
    workspaceId: string,
    updates: Partial<IdeaWorkspace>
): Promise<boolean>
async deleteWorkspace(workspaceId: string): Promise<boolean>
async generateIdeas(
    workspaceId: string,
    userId: string,
    params: IdeaGenerationParams
): Promise<UnifiedIdea[]>
private generateMockIdeas(params: IdeaGenerationParams): any[]
async getIdeas(workspaceId: string): Promise<UnifiedIdea[]>
async getIdea(ideaId: string): Promise<UnifiedIdea | null>
async updateIdea(
    ideaId: string,
    updates: Partial<UnifiedIdea>
): Promise<boolean>
private createIdeaAnalysisPrompt(idea: UnifiedIdea): string
private createIdeaComparisonPrompt(ideas: UnifiedIdea[]): string
private createIdeaMergePrompt(ideas: UnifiedIdea[]): string

================
File: src/lib/types/ai.types.ts
================
export interface AIResponse {
  feedback: {
    strengths: string[];
    areas_for_improvement: string[];
    opportunities: string[];
    risks: string[];
    strategic_recommendations: string[];
  };
  follow_up_questions: string[];
  tasks: AITask[];
}
export interface AITask {
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  estimated_hours: number;
  task_type: string;
  implementation_tips: string[];
  potential_challenges: string[];
  success_metrics: string[];
  resources: AIResource[];
  learning_resources: AILearningResource[];
  tools: AITool[];
}
export interface AIResource {
  title: string;
  url: string;
  type: string;
  description: string;
  source_type: 'ai';
}
export interface AILearningResource {
  title: string;
  url: string;
  type: string;
  platform: string;
  description: string;
  source_type: 'ai';
}
export interface AITool {
  name: string;
  url: string;
  category: string;
  description: string;
  source_type: 'ai';
}

================
File: src/lib/types/enhanced-profile.types.ts
================
export type UserRoleType = 'founder' | 'company_member' | 'service_provider';
export type CompanyStageType = 'idea_stage' | 'solid_idea' | 'existing_company';
export interface SetupProgressType {
  current_step?: string;
  completed_steps?: string[];
  form_data?: Record<string, any>;
  skipped?: boolean;
  skipped_at?: string;
}
export interface EnhancedProfileType {
  id?: number;
  user_id: string;
  primary_role?: UserRoleType;
  additional_roles?: UserRoleType[];
  company_stage?: CompanyStageType;
  industry?: string;
  skill_level?: string;
  goals?: string[];
  preferred_theme?: string;
  notification_preferences?: Record<string, boolean>;
  service_categories?: string[];
  expertise?: string[];
  onboarding_completed?: boolean;
  onboarding_completed_at?: string;
  setup_progress?: SetupProgressType;
  created_at?: string;
  updated_at?: string;
}
export interface CompanyInvitationType {
  id: number;
  company_id: string;
  code: string;
  email?: string;
  role?: string;
  status: 'active' | 'used' | 'expired';
  created_at: string;
  expires_at?: string;
  used_by?: string;
  used_at?: string;
}
export interface CompanyMembershipType {
  id: number;
  company_id: string;
  user_id: string;
  role: string;
  joined_at: string;
  companies?: {
    id: string;
    name: string;
    logo_url?: string;
    industry?: string;
    size?: string;
    stage?: string;
  };
}

================
File: src/lib/types/extended-profile.types.ts
================
import { UserProfile } from './profile.types';
export interface ExtendedUserProfile extends UserProfile {
  company_id?: string;
  company_name?: string;
  company_role?: string;
  company_logo_url?: string;
  company_description?: string;
  company_industry?: string;
  company_size?: string;
  company_stage?: string;
  company_website?: string;
  company_founded_date?: string;
  company_location?: string;
  company_mission?: string;
  company_vision?: string;
  company_values?: string[];
  company_products?: string[];
  company_services?: string[];
  company_target_market?: string;
  company_competitors?: string[];
  company_funding_status?: string;
  company_funding_amount?: number;
  company_funding_rounds?: number;
  company_investors?: string[];
  company_team_size?: number;
  company_team_members?: {
    id: string;
    name: string;
    role: string;
    avatar_url?: string;
  }[];
  company_metrics?: Record<string, any>;
  company_goals?: {
    id: string;
    title: string;
    description?: string;
    status: 'not_started' | 'in_progress' | 'completed';
    due_date?: string;
  }[];
  company_settings?: Record<string, any>;
}

================
File: src/lib/types/idea-exploration.types.ts
================
export interface IdeaExplorationSession {
  id: string;
  user_id: string;
  created_at: string;
  updated_at: string;
  status: 'active' | 'completed' | 'archived';
  context: string;
}
export interface IdeaGenerationParams {
  topic?: string;
  industry?: string;
  audience?: string;
  problem?: string;
  constraints?: string[];
  count?: number;
  context?: string;
  target_audience?: string;
  problem_area?: string;
  technology?: string;
  business_model_preference?: string;
  market_size_preference?: string;
  innovation_level?: string;
  resource_constraints?: string[];
  title?: string;
}
export interface IdeaMerge {
  id: string;
  session_id: string;
  source_idea_ids: string[];
  result_idea_id: string;
  created_at: string;
  user_id: string;
}
export interface IdeaComparison {
  id: string;
  session_id: string;
  idea_ids: string[];
  result: IdeaComparisonResult;
  created_at: string;
  user_id: string;
}
export interface ExplorationIdea {
  id: string;
  title: string;
  description: string;
  problem_statement: string;
  solution_concept: string;
  target_audience: string;
  unique_value: string;
  business_model: string;
  marketing_strategy: string;
  revenue_model: string;
  go_to_market: string;
  market_size: string;
  created_at: string;
  updated_at: string;
  user_id?: string;
  session_id?: string;
  version: number;
  is_merged: boolean;
  parent_ideas: string[];
  competition: string[];
  revenue_streams: string[];
  cost_structure: string[];
  key_metrics: string[];
  analysis?: IdeaAnalysis | null;
}
export interface IdeaAnalysis {
  strengths: string[];
  weaknesses: string[];
  opportunities: string[];
  threats: string[];
  suggestions: string[];
  market_insights: string[];
  validation_tips: string[];
  created_at?: string;
}
export interface IdeaComparisonResult {
  merger_potential: number;
  common_strengths: string[];
  common_weaknesses: string[];
  unique_strengths: Record<string, string[]>;
  unique_weaknesses: Record<string, string[]>;
  complementary_aspects: string[];
  conflicting_aspects: string[];
  merger_suggestions: string[];
  created_at?: string;
}
export interface IdeaFilter {
  searchTerm?: string;
  sortBy?: 'created_at' | 'updated_at' | 'title';
  sortDirection?: 'asc' | 'desc';
  showMerged?: boolean;
  showAnalyzed?: boolean;
}
export interface IdeaExplorationContext {
  userId: string;
  context: string;
  sessionId?: string;
}

================
File: src/lib/types/idea-generation.types.ts
================
export interface IdeaGenerationResult {
  title: string;
  description: string;
  problem_statement: string;
  solution_concept: string;
  target_audience: string[];
  unique_value: string;
  business_model: string;
  tags?: string[];
}
export interface RefinementResult extends IdeaGenerationResult {
  feedback: string;
  refinement_timestamp: string;
}

================
File: src/lib/types/idea-pathway.types.ts
================
import { IdeaPlaygroundIdea } from './idea-playground.types';
export enum IdeaPathwayStep {
  INITIAL_IDEA = 'initial_idea',
  VARIATIONS = 'variations',
  SELECTION = 'selection',
  MERGE = 'merge',
  FINAL_SELECTION = 'final_selection'
}
export interface IdeaVariation {
  id: string;
  parent_idea_id: string;
  title: string;
  description?: string;
  problem_statement?: string;
  solution_concept?: string;
  target_audience?: string;
  unique_value?: string;
  business_model?: string;
  marketing_strategy?: string;
  revenue_model?: string;
  go_to_market?: string;
  market_size?: string;
  strengths: string[];
  weaknesses: string[];
  opportunities: string[];
  threats: string[];
  is_selected: boolean;
  is_merged: boolean;
  created_at: string;
  updated_at: string;
}
export interface MergedIdea {
  id: string;
  canvas_id: string;
  title: string;
  description?: string;
  problem_statement?: string;
  solution_concept?: string;
  target_audience?: string;
  unique_value?: string;
  business_model?: string;
  marketing_strategy?: string;
  revenue_model?: string;
  go_to_market?: string;
  market_size?: string;
  strengths: string[];
  weaknesses: string[];
  opportunities: string[];
  threats: string[];
  is_selected: boolean;
  created_at: string;
  updated_at: string;
  source_variations?: string[];
}
export interface IdeaVariationParams {
  idea_id: string;
  count?: number;
  focus_areas?: string[];
  variation_strategy?: 'distinct' | 'iterative' | 'disruptive';
}
export interface IdeaMergeParams {
  variation_ids: string[];
  canvas_id: string;
  count?: number;
  merge_strategy?: 'combine_strengths' | 'address_weaknesses' | 'hybrid';
}
export interface IdeaPathwayState {
  currentStep: IdeaPathwayStep;
  selectedIdea: IdeaPlaygroundIdea | null;
  variations: IdeaVariation[];
  selectedVariations: string[];
  mergedIdeas: MergedIdea[];
  selectedMergedIdea: string | null;
  isLoading: boolean;
}

================
File: src/lib/types/idea-playground.types.ts
================
import { IdeaGenerationResult, RefinementResult } from './idea-generation.types';
export enum IdeaStatus {
  DRAFT = 'draft',
  IN_PROGRESS = 'in_progress',
  REFINED = 'refined',
  VALIDATED = 'validated',
  IMPLEMENTED = 'implemented',
  ARCHIVED = 'archived'
}
export enum ProtectionLevel {
  PUBLIC = 'public',
  PRIVATE = 'private',
  CONFIDENTIAL = 'confidential'
}
export enum CanvasType {
  STANDARD = 'standard',
  BUSINESS_MODEL = 'business-model',
  PROBLEM_SOLUTION = 'problem-solution',
  CUSTOMER_JOURNEY = 'customer-journey',
  VALUE_PROPOSITION = 'value-proposition'
}
export enum IdeaType {
  NEW_COMPANY = 'new_company',
  NEW_PRODUCT = 'new_product',
  NEW_FEATURE = 'new_feature',
  IMPROVEMENT = 'improvement'
}
export interface IdeaPlaygroundIdea {
  id: string;
  title: string;
  description: string;
  problem_statement: string;
  solution_concept: string;
  target_audience: string[];
  unique_value: string;
  business_model: string;
  canvas_data?: Record<string, any>;
  canvas_type?: string;
  user_id: string;
  created_at: string;
  updated_at: string;
  parent_idea_id?: string;
  refinement_feedback?: string;
  protection_level: string;
  status?: string;
  is_saved?: boolean;
  used_company_context?: boolean;
  idea_type?: string;
  company_id?: string;
  last_edited?: string;
}
export interface Company {
  id: string;
  name: string;
  slug?: string;
  description?: string;
  logo_url?: string;
  website?: string;
  industry?: string;
  size?: string;
  stage?: string;
  founded_date?: string;
  is_formed?: boolean;
  created_at: string;
  updated_at: string;
  metadata?: Record<string, any>;
}
export interface BusinessModelCanvas {
  id: string;
  ideaId: string;
  keyPartners: string[];
  keyActivities: string[];
  keyResources: string[];
  valuePropositions: string[];
  customerRelationships: string[];
  channels: string[];
  customerSegments: string[];
  costStructure: string[];
  revenueStreams: string[];
  createdAt: string;
  updatedAt: string;
}
export interface ValuePropositionCanvas {
  id: string;
  ideaId: string;
  customerJobs: string[];
  customerPains: string[];
  customerGains: string[];
  products: string[];
  painRelievers: string[];
  gainCreators: string[];
  createdAt: string;
  updatedAt: string;
}
export interface CompanyMember {
  id: string;
  company_id: string;
  user_id: string;
  title?: string;
  joined_at: string;
  invited_by?: string;
}

================
File: src/lib/types/journey-challenges.types.ts
================
export type difficulty_level = 1 | 2 | 3 | 4 | 5;
export type challenge_status = 'not_started' | 'in_progress' | 'completed' | 'skipped';
export interface JourneyChallenge {
  id: string;
  name: string;
  description?: string;
  phase_id: string;
  difficulty_level: difficulty_level;
  estimated_time_min: number;
  estimated_time_max: number;
  key_outcomes?: string[];
  order_index: number;
  created_at: string;
  updated_at: string;
}
export interface CompanyChallengeProgress {
  id: string;
  company_id: string;
  challenge_id: string;
  status: challenge_status;
  notes?: string;
  created_at: string;
  updated_at: string;
}
export interface JourneyPhase {
  id: string;
  name: string;
  description?: string;
  order_index: number;
  color?: string;
  created_at: string;
  updated_at: string;
}
export interface ChallengeToolRecommendation {
  id: string;
  challenge_id: string;
  tool_id: string;
  relevance_score: number;
  notes?: string;
  created_at: string;
  updated_at: string;
  tool?: Tool;
}
export interface Tool {
  id: string;
  name: string;
  description?: string;
  url?: string;
  pricing_type?: 'free' | 'freemium' | 'paid' | 'subscription' | 'one-time';
  pricing_details?: string;
  category?: string;
  tags?: string[];
  created_at: string;
  updated_at: string;
}

================
File: src/lib/types/journey-steps.types.ts
================
export type step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped';
export type difficulty_level = 1 | 2 | 3 | 4 | 5;
export interface JourneyStep {
  id: string;
  name: string;
  description?: string;
  phase_id: string;
  difficulty_level: difficulty_level;
  estimated_time_min: number;
  estimated_time_max: number;
  key_outcomes?: string[];
  prerequisite_steps?: string[];
  order_index: number;
  created_at: string;
  updated_at: string;
  is_custom?: boolean;
}
export interface EnhancedJourneyStep extends JourneyStep {
  phase_name?: string;
  phase_color?: string;
  status?: step_status;
  completion_percentage?: number;
  tools?: ToolReference[];
  team_members?: TeamMemberReference[];
}
export interface CompanyStepProgress {
  id: string;
  company_id: string;
  step_id: string;
  status: step_status;
  notes?: string;
  completed_at?: string;
  created_at: string;
  updated_at: string;
}
export interface JourneyPhase {
  id: string;
  name: string;
  description?: string;
  order_index: number;
  color?: string;
  created_at: string;
  updated_at: string;
}
export interface ToolReference {
  id: string;
  name: string;
  description?: string;
  url?: string;
  logo_url?: string;
}
export interface TeamMemberReference {
  id: string;
  name: string;
  avatar_url?: string;
  role?: string;
}
export interface StepFilterOptions {
  phase_id?: string;
  status?: step_status;
  difficulty_min?: number;
  difficulty_max?: number;
  search_term?: string;
  only_custom?: boolean;
}
export interface EnhancedStepResponse {
  id: string;
  name: string;
  description?: string;
  phase_id: string;
  phase_name?: string;
  difficulty_level: difficulty_level;
  estimated_time_min: number;
  estimated_time_max: number;
  key_outcomes?: string[];
  tools?: ToolReference[];
  status?: step_status;
}
export interface PersonalizedToolRecommendation {
  id: string;
  name: string;
  description?: string;
  url?: string;
  logo_url?: string;
  relevance_score: number;
}
export const calculateStepCompletion = (step: EnhancedJourneyStep): number =>
export const mapChallengeToStep = (challenge: any): EnhancedJourneyStep =>
export const mapStepToChallenge = (step: EnhancedJourneyStep): any =>
export interface StepRecommendation {
  id: string;
  name: string;
  description?: string;
  difficulty_level: difficulty_level;
  estimated_time_min: number;
  estimated_time_max: number;
  phase_id: string;
  phase_name?: string;
  relevance_score: number;
  reasoning: string[];
}
export interface RecommendationScore extends EnhancedJourneyStep {
  score: number;
  reasoning: string[];
}
export interface StepRelationship {
  source_id: string;
  source_name?: string;
  target_id: string;
  target_name?: string;
  relationship_type: 'prerequisite' | 'dependent' | 'related';
}

================
File: src/lib/types/journey-unified.types.ts
================
export type step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped';
export type StepStatus = step_status;
export type difficulty_level = 1 | 2 | 3 | 4 | 5;
export interface Tool {
  id: string;
  name: string;
  description?: string;
  url?: string;
  logo_url?: string;
  type: string;
  category?: string;
  pricing_model?: string;
  is_premium: boolean;
  created_at?: string;
  updated_at?: string;
}
export interface StepFilterParams {
  phaseId?: string;
  status?: step_status | step_status[];
  includeCustom?: boolean;
  difficulty?: difficulty_level | difficulty_level[];
  search?: string;
  searchTerm?: string;
  limit?: number;
  estimatedTimeMax?: number;
  orderBy?: 'order_index' | 'name' | 'created_at' | 'difficulty_level';
  orderDirection?: 'asc' | 'desc';
}
export interface ToolFilterParams {
  stepId?: string;
  type?: string;
  category?: string;
  search?: string;
  searchTerm?: string;
  isPremium?: boolean;
  minRelevanceScore?: number;
  limit?: number;
  orderBy?: string;
  orderDirection?: 'asc' | 'desc';
}
export interface CompanyStepProgressUpdate {
  status?: step_status;
  notes?: string;
  completion_percentage?: number;
  custom_difficulty?: number;
  custom_time_estimate?: number;
}
export interface CompanyToolEvaluationUpdate {
  notes?: string;
  rating?: number;
  is_selected?: boolean;
}
export interface JourneyPhase {
  id: string;
  name: string;
  description?: string;
  order_index: number;
  color?: string;
  created_at: string;
  updated_at: string;
}
export interface JourneyStep {
  id: string;
  name: string;
  description?: string;
  phase_id: string;
  difficulty_level: difficulty_level;
  estimated_time_min: number;
  estimated_time_max: number;
  key_outcomes?: string[];
  prerequisite_steps?: string[];
  order_index: number;
  created_at: string;
  updated_at: string;
  is_custom?: boolean;
}
export interface CompanyJourneyStep {
  id: string;
  company_id: string;
  step_id: string;
  status: step_status;
  notes?: string;
  custom_difficulty?: number;
  custom_time_estimate?: number;
  completion_percentage?: number;
  order_index: number;
  created_at: string;
  updated_at: string;
  completed_at?: string;
}
export interface StepTool {
  id: string;
  step_id: string;
  tool_id: string;
  relevance_score: number;
  created_at: string;
}
export interface CompanyStepTool {
  id: string;
  company_id: string;
  step_id: string;
  tool_id: string;
  is_custom: boolean;
  rating?: number;
  notes?: string;
  is_selected: boolean;
  selected_at?: string;
  created_at: string;
  updated_at: string;
}
export interface CompanyJourneyStepWithDetails extends JourneyStep {
  phase_name?: string;
  phase_color?: string;
  company_progress?: {
    status: step_status;
    notes?: string;
    completion_percentage?: number;
    completed_at?: string;
  };
  recommended_tools?: Array<{
    id: string;
    name: string;
    description?: string;
    relevance_score: number;
  }>;
}
export interface JourneyStepWithPhase extends JourneyStep {
  phase_name: string;
  phase_color?: string;
}
export interface JourneyStepComplete extends JourneyStepWithPhase {
  tools?: Tool[];
  prerequisites?: JourneyStep[];
  prerequisite_step_details?: JourneyStep[];
  company_progress?: CompanyJourneyStep;
  progress?: CompanyJourneyStep;
  phase?: JourneyPhase;
  selected_tool?: Tool;
}
export interface PhaseWithProgress extends JourneyPhase {
  steps_count: number;
  completed_steps: number;
  in_progress_steps: number;
  completion_percentage: number;
}
export type JourneyChallenge = JourneyStep;
export type CompanyChallengeProgress = CompanyJourneyStep;

================
File: src/lib/types/journey.types.ts
================
export type journey_step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped';
export interface JourneyPhase {
  id: string;
  name: string;
  description?: string;
  order_index: number;
  icon?: string;
  color?: string;
  created_at?: string;
  updated_at?: string;
}
export interface JourneyStep {
  id: string;
  phase_id: string;
  name: string;
  description?: string;
  guidance?: string;
  order_index: number;
  estimated_duration?: string;
  required: boolean;
  is_company_formation_step: boolean;
  ask_wheel_enabled: boolean;
  ask_expert_enabled: boolean;
  use_tool_enabled: boolean;
  diy_enabled: boolean;
  created_at?: string;
  updated_at?: string;
}
export interface JourneyStepOption {
  id: string;
  step_id: string;
  name: string;
  description?: string;
  order_index: number;
  created_at?: string;
  updated_at?: string;
}
export interface JourneyStepTool {
  id: string;
  step_id: string;
  name: string;
  description?: string;
  url: string;
  logo_url?: string;
  type: string;
  category?: string;
  ranking: number;
  is_premium: boolean;
  created_at?: string;
  updated_at?: string;
}
export interface CompanyProgress {
  id: string;
  company_id: string;
  step_id: string;
  status: journey_step_status;
  notes?: string;
  completed_at?: string;
  created_at?: string;
  updated_at?: string;
}
export interface CompanyFocusArea {
  id: string;
  company_id: string;
  step_id: string;
  created_at?: string;
}
export interface JourneyStepFeedback {
  id: string;
  step_id: string;
  user_id: string;
  rating?: number;
  comment?: string;
  created_at?: string;
}
export interface CompanyCustomTool {
  id: string;
  company_id: string;
  step_id: string;
  name: string;
  url: string;
  description?: string;
  functionality?: string;
  ai_generated_description?: string;
  created_at?: string;
  updated_at?: string;
}

================
File: src/lib/types/logging.types.ts
================
export interface LogEvent {
  id?: string;
  user_id?: string;
  company_id?: string;
  event_type: string;
  event_source: string;
  component?: string;
  action: string;
  data: any;
  metadata?: any;
  data_classification?: 'non_personal' | 'pseudonymized' | 'personal' | 'sensitive';
  retention_policy?: 'transient' | 'short_term' | 'medium_term' | 'long_term';
  session_id?: string;
  client_info?: ClientInfo;
  created_at?: string;
}
export interface UserActionEvent extends Omit<LogEvent, 'event_type' | 'event_source'> {
  action: string;
  data: any;
  metadata?: any;
}
export interface AIInteractionEvent extends Omit<LogEvent, 'event_type' | 'event_source'> {
  action: string;
  data: {
    model?: string;
    prompt?: string;
    response?: string;
    tokens?: number;
    [key: string]: any;
  };
  metadata?: any;
}
export interface ConsentSettings {
  id?: string;
  user_id: string;
  essential: boolean;
  analytics: boolean;
  product_improvement: boolean;
  ai_training: boolean;
  cross_company_insights: boolean;
  personalization: boolean;
  last_updated: string;
  verified: boolean;
  consent_history?: any[];
}
export interface PrivacyRequest {
  id: string;
  user_id: string;
  request_type: 'export' | 'deletion' | 'correction' | 'restriction';
  status: 'pending' | 'processing' | 'completed' | 'rejected';
  request_details?: any;
  submitted_at: string;
  completed_at?: string;
  notes?: string;
  handler_id?: string;
}
export interface ClassificationRule {
  id?: string;
  data_type: string;
  pattern: string;
  classification: 'non_personal' | 'pseudonymized' | 'personal' | 'sensitive';
  retention_policy: 'transient' | 'short_term' | 'medium_term' | 'long_term';
  description?: string;
  priority?: number;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
}
export interface RetentionPolicy {
  policy: string;
  retention_days: number;
  description: string;
  anonymization_action: 'delete' | 'pseudonymize' | 'anonymize';
  created_at?: string;
  last_updated?: string;
}
export interface LoggingSession {
  session_id: string;
  user_id?: string;
  device_info?: ClientInfo;
  start_time: string;
  end_time?: string;
  is_active: boolean;
}
export interface ExtractedFeature {
  id: string;
  feature_set: string;
  feature_name: string;
  feature_value: any;
  source_logs: string[];
  is_anonymized: boolean;
  created_at: string;
}
export interface ModelRegistryEntry {
  id: string;
  model_name: string;
  model_type: string;
  model_version: string;
  model_description?: string | null;
  training_date: string;
  metrics?: any | null;
  hyperparameters?: any | null;
  feature_sets?: string[] | null;
  is_active: boolean;
}
export interface ModelFeedback {
  id: string;
  model_id: string;
  user_id?: string | null;
  prediction_input: any;
  prediction_output: any;
  feedback_type: 'positive' | 'negative' | 'correction' | 'suggestion' | 'automatic' | 'neutral';
  feedback_value: any;
  created_at: string;
}
export interface ClientInfo {
  userAgent?: string;
  language?: string;
  viewport?: {
    width: number;
    height: number;
  };
  referrer?: string;
  screenSize?: {
    width: number;
    height: number;
  };
  deviceType?: string;
  operatingSystem?: string;
  browser?: string;
  timestamp: string;
}

================
File: src/lib/types/multi-persona-profile.types.ts
================
export interface CoreIdentity {
  id: string;
  email: string;
  secondary_emails?: string[];
  full_name: string | null;
  display_name?: string;
  avatar_url?: string | null;
  bio?: string;
  pronouns?: string;
  verified: boolean;
  account_created_at: string;
  last_active_at?: string;
  locale?: string;
  timezone?: string;
  accessibility_needs?: string[];
  account_status: 'active' | 'inactive' | 'suspended' | 'deleted';
}
export interface ProfessionalIdentity {
  title?: string;
  industry?: string;
  secondary_industries?: string[];
  role_category?: RoleCategory;
  role_subcategory?: string;
  skills?: Skill[];
  expertise_areas?: string[];
  experience_level?: ExperienceLevel;
  certifications?: Certification[];
  education?: Education[];
  work_history?: WorkExperience[];
  founding_history?: FoundingExperience[];
  mentorship_status?: 'seeking' | 'offering' | 'both' | 'none';
  collaboration_interests?: string[];
  investment_interests?: InvestmentInterest[];
  service_offerings?: ServiceOffering[];
}
export enum RoleCategory {
  FOUNDER = 'FOUNDER',
  COMPANY_MEMBER = 'COMPANY_MEMBER',
  SERVICE_PROVIDER = 'SERVICE_PROVIDER',
  INVESTOR = 'INVESTOR',
  ADVISOR = 'ADVISOR',
  COMMUNITY_MEMBER = 'COMMUNITY_MEMBER',
  CUSTOM = 'CUSTOM'
}
export enum ExperienceLevel {
  BEGINNER = 'BEGINNER',
  INTERMEDIATE = 'INTERMEDIATE',
  ADVANCED = 'ADVANCED',
  EXPERT = 'EXPERT'
}
export interface Skill {
  name: string;
  proficiency: ExperienceLevel;
  years_experience?: number;
  last_used?: string;
}
export interface Certification {
  name: string;
  issuer: string;
  date_earned: string;
  expiration_date?: string;
  verification_url?: string;
}
export interface Education {
  institution: string;
  degree: string;
  field_of_study: string;
  start_date: string;
  end_date?: string;
  achievements?: string[];
}
export interface WorkExperience {
  company: string;
  title: string;
  description?: string;
  start_date: string;
  end_date?: string;
  is_current: boolean;
  achievements?: string[];
  references?: Reference[];
}
export interface Reference {
  name: string;
  title?: string;
  company?: string;
  contact?: string;
  relationship: string;
}
export interface FoundingExperience {
  company_name: string;
  industry: string;
  role: string;
  start_date: string;
  end_date?: string;
  current_status: 'operating' | 'acquired' | 'merged' | 'closed';
  funding_raised?: number;
  exit_valuation?: number;
  team_size?: number;
  description?: string;
}
export interface InvestmentInterest {
  stage: string[];
  amount_range: {
    min?: number;
    max?: number;
  };
  industries: string[];
  thesis?: string;
}
export interface ServiceOffering {
  category: string;
  description: string;
  expertise_level: ExperienceLevel;
  rate_type: 'hourly' | 'project' | 'retainer';
  availability: 'part_time' | 'full_time' | 'contract';
}
export interface NetworkIdentity {
  connections?: Connection[];
  connection_groups?: Group[];
  followers_count?: number;
  following_count?: number;
  blocked_users?: string[];
  social_links?: SocialLink[];
  public_visibility?: Visibility;
  contact_preferences?: ContactPreferences;
  endorsements?: Endorsement[];
  testimonials?: Testimonial[];
  community_roles?: string[];
  contributions?: Contribution[];
  reputation_score?: number;
  karma_points?: number;
  badges?: Badge[];
}
export interface Connection {
  user_id: string;
  relationship: 'colleague' | 'mentor' | 'mentee' | 'investor' | 'partner' | 'other';
  connected_at: string;
  notes?: string;
}
export interface Group {
  name: string;
  members: string[];
  description?: string;
}
export interface SocialLink {
  platform: string;
  url: string;
  username?: string;
  verified: boolean;
}
export interface Visibility {
  profile_discoverable: boolean;
  show_email: boolean;
  show_skills: boolean;
  show_experience: boolean;
  show_education: boolean;
  show_investments: boolean;
  show_services: boolean;
  show_connections: boolean;
}
export interface ContactPreferences {
  allow_direct_messages: boolean;
  allow_connection_requests: boolean;
  allow_meeting_requests: boolean;
  preferred_contact_method?: 'email' | 'platform' | 'phone';
  response_time_expectation?: string;
}
export interface Endorsement {
  skill: string;
  endorsed_by: string;
  endorsed_at: string;
  strength?: ExperienceLevel;
}
export interface Testimonial {
  content: string;
  author_id: string;
  created_at: string;
  relationship: string;
  is_public: boolean;
}
export interface Contribution {
  type: 'article' | 'event' | 'resource' | 'comment' | 'question' | 'answer';
  id: string;
  created_at: string;
  engagement_metrics?: {
    views?: number;
    likes?: number;
    comments?: number;
    shares?: number;
  };
}
export interface Badge {
  id: string;
  name: string;
  description: string;
  icon_url: string;
  awarded_at: string;
  category: 'achievement' | 'participation' | 'expertise' | 'special';
}
export interface CompanyAffiliations {
  primary_company_id?: string;
  primary_company_role?: string;
  primary_company_title?: string;
  primary_company_join_date?: string;
  companies?: CompanyAssociation[];
  past_companies?: CompanyAssociation[];
  reports_to?: string;
  direct_reports?: string[];
  team_id?: string;
  department?: string;
  employee_id?: string;
  access_level?: string;
  authorized_features?: string[];
}
export interface CompanyAssociation {
  company_id: string;
  role: string;
  title?: string;
  relationship_type: 'employee' | 'founder' | 'advisor' | 'investor' | 'board' | 'contractor';
  start_date: string;
  end_date?: string;
  ownership_stake?: number;
  is_public: boolean;
}
export interface ProjectContext {
  current_startup_stage?: 'ideation' | 'validation' | 'early_development' | 'mvp' | 'launch' | 'growth';
  current_company_valuation?: number;
  current_funding_round?: string;
  funding_status?: 'bootstrapped' | 'pre-seed' | 'seed' | 'series_a' | 'series_b' | 'series_c' | 'profitable';
  personal_goals?: Goal[];
  current_okrs?: OKR[];
  kpis_tracked?: KPI[];
  milestones?: Milestone[];
  current_challenges?: string[];
  areas_seeking_help?: string[];
  current_priorities?: Priority[];
}
export interface Goal {
  description: string;
  category: 'professional' | 'business' | 'personal' | 'learning';
  target_date?: string;
  progress?: number;
  status: 'not_started' | 'in_progress' | 'completed' | 'deferred';
}
export interface OKR {
  objective: string;
  key_results: {
    description: string;
    target: number;
    current: number;
    unit: string;
  }[];
  time_frame: string;
  status: 'on_track' | 'at_risk' | 'off_track' | 'completed';
}
export interface KPI {
  name: string;
  description?: string;
  current_value: number;
  target_value: number;
  unit: string;
  frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly';
}
export interface Milestone {
  name: string;
  description?: string;
  due_date: string;
  status: 'upcoming' | 'in_progress' | 'completed' | 'missed';
  associated_goals?: string[];
}
export interface Priority {
  task: string;
  importance: 'critical' | 'high' | 'medium' | 'low';
  urgency: 'immediate' | 'this_week' | 'this_month' | 'this_quarter';
  status: 'not_started' | 'in_progress' | 'blocked' | 'completed';
}
export interface AIPersonalization {
  communication_style_preference?: 'detailed' | 'concise' | 'visual' | 'technical' | 'simple';
  content_interests?: string[];
  content_format_preferences?: ('text' | 'video' | 'audio' | 'interactive')[];
  interaction_history?: {
    total_conversations?: number;
    frequent_topics?: string[];
    favorite_tools?: string[];
    saved_prompts?: SavedPrompt[];
  };
  learning_path?: {
    current_focus?: string;
    completed_topics?: string[];
    skill_goals?: string[];
    preferred_learning_style?: string;
  };
  feature_usage?: Record<string, {
    last_used?: string;
    usage_count?: number;
    proficiency?: 'novice' | 'intermediate' | 'advanced';
  }>;
  content_engagement?: {
    clicked_topics?: Record<string, number>;
    time_spent?: Record<string, number>;
    favorited_items?: string[];
  };
}
export interface SavedPrompt {
  id: string;
  name: string;
  content: string;
  tags?: string[];
  created_at: string;
  last_used_at?: string;
  usage_count: number;
}
export interface BillingCompliance {
  subscription_tier?: 'free' | 'pro' | 'business' | 'enterprise';
  subscription_start_date?: string;
  subscription_renewal_date?: string;
  billing_cycle?: 'monthly' | 'annual' | 'quarterly';
  payment_method_id?: string;
  usage_metrics?: {
    api_calls?: number;
    storage_used?: number;
    premium_features_used?: string[];
  };
  plan_limits?: {
    max_projects?: number;
    max_storage?: number;
    max_collaborators?: number;
  };
  terms_accepted?: {
    version: string;
    date_accepted: string;
    ip_address?: string;
  };
  data_processing_consents?: Record<string, {
    consented: boolean;
    date: string;
  }>;
  gdpr_requests?: {
    data_export?: {
      requested_at: string;
      fulfilled_at?: string;
      status: 'pending' | 'processing' | 'completed' | 'denied';
    };
    data_deletion?: {
      requested_at: string;
      fulfilled_at?: string;
      status: 'pending' | 'processing' | 'completed' | 'denied';
    };
  };
}
export interface SystemMetadata {
  profile_version: number;
  last_updated: string;
  update_history?: {
    timestamp: string;
    fields_changed: string[];
    updated_by: 'user' | 'system' | 'admin';
  }[];
  security_level?: 'standard' | 'enhanced' | 'maximum';
  two_factor_enabled: boolean;
  last_password_change?: string;
  login_history?: {
    timestamp: string;
    ip_address: string;
    device_info: string;
    location?: string;
  }[];
  is_beta_tester?: boolean;
  feature_flags?: Record<string, boolean>;
  experiment_groups?: string[];
  referral_code?: string;
  referred_by?: string;
  legacy_user_id?: string;
  imported_from?: string;
  import_date?: string;
}
export interface UserProfile {
  core: CoreIdentity;
  active_persona_id?: string;
  system: SystemMetadata;
  global_settings?: {
    default_persona_id?: string;
    auto_switch_personas?: boolean;
    cross_persona_notifications?: boolean;
  };
}
export interface Persona {
  id: string;
  user_id: string;
  name: string;
  type: 'founder' | 'service_provider' | 'company_member' | 'investor' | 'advisor' | 'community' | 'custom';
  icon?: string;
  is_public: boolean;
  is_active: boolean;
  created_at: string;
  last_used_at?: string;
  professional?: ProfessionalIdentity;
  network?: NetworkIdentity;
  company_affiliations?: CompanyAffiliations;
  project_context?: ProjectContext;
  personalization?: AIPersonalization;
  billing?: BillingCompliance;
  visibility_settings: {
    discoverable_as: ('founder' | 'service_provider' | 'company_member' | 'investor' | 'advisor')[];
    visible_to: ('public' | 'connections' | 'specific_companies' | 'specific_users')[];
    hidden_fields: string[];
    specific_users?: string[];
    company_specific_views?: {
      company_id: string;
      visible_fields: string[];
      hidden_fields: string[];
    }[];
  };
}
export interface PersonaContextSwitching {
  auto_switch_rules?: {
    context: 'url_path' | 'company_view' | 'feature_usage' | 'time_of_day' | 'referring_site';
    condition: string;
    switch_to_persona_id: string;
  }[];
  context_defaults?: {
    dashboard_persona_id?: string;
    messaging_persona_id?: string;
    directory_persona_id?: string;
    company_specific?: {
      company_id: string;
      persona_id: string;
    }[];
  };
  switching_history?: {
    timestamp: string;
    from_persona_id: string;
    to_persona_id: string;
    trigger: 'manual' | 'auto' | 'rule';
    context?: string;
  }[];
}
export interface OnboardingState {
  id: string;
  user_id: string;
  persona_id: string;
  current_step: string;
  completed_steps: string[];
  form_data: Record<string, any>;
  is_complete: boolean;
  last_updated: string;
  metrics?: {
    step_completion_times?: Record<string, string>;
    total_time_spent?: number;
    completion_date?: string;
  };
}
export interface AppSettings {
  user_id: string;
  theme: 'light' | 'dark' | 'system';
  notifications: {
    email: boolean;
    push: boolean;
    inApp: boolean;
    digest: boolean;
  };
  display: {
    compactView: boolean;
    showTips: boolean;
    cardSize: 'small' | 'medium' | 'large';
  };
  features: Record<string, boolean>;
  created_at: string;
  updated_at: string;
}

================
File: src/lib/types/profile.types.ts
================
export interface UserProfile {
  theme?: 'light' | 'dark';
  id: string;
  email: string;
  full_name: string | null;
  avatar_url: string | null;
  role: 'user' | 'admin' | 'superadmin' | 'Platform Admin';
  is_public: boolean;
  allows_messages: boolean;
  professional_background?: string;
  social_links?: Record<string, string>;
  settings?: Record<string, any>;
  setup_progress?: {
    current_step: string;
    completed_steps: string[];
    form_data: Record<string, any>;
    last_updated?: string;
  };
}
export interface User {
  id: string;
  email: string;
  full_name?: string | null;
  display_name?: string | null;
  avatar_url?: string | null;
  status?: 'active' | 'inactive' | 'suspended' | 'pending_verification';
  email_verified?: boolean;
  phone?: string | null;
  created_at: string;
  updated_at: string;
  last_login_at?: string | null;
  metadata?: Record<string, any>;
  setup_progress?: {
    current_step: string;
    completed_steps: string[];
    form_data: Record<string, any>;
    last_updated?: string;
  };
  role?: string;
  is_public?: boolean;
  allows_messages?: boolean;
  professional_background?: string;
  social_links?: Record<string, string>;
}
export interface FeatureFlags {
  [key: string]: {
    enabled: boolean;
    visible: boolean;
  };
}

================
File: src/lib/types/task.types.ts
================
export interface Task {
  id: string;
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  status: 'pending' | 'in_progress' | 'completed';
  category: string;
  task_type: string;
  estimated_hours: number;
  due_date: string;
  implementation_tips?: string[];
  potential_challenges?: string[];
  success_metrics?: string[];
  resources?: Resource[];
  learning_resources?: LearningResource[];
  tools?: Tool[];
}
export interface Resource {
  title: string;
  url: string;
  type: string;
  description: string;
  source_type?: 'ai' | 'web' | 'internal' | 'community' | 'expert';
  tags?: string[];
}
export interface LearningResource {
  title: string;
  url: string;
  type: string;
  platform: string;
  description: string;
  source_type?: 'ai' | 'web' | 'internal' | 'community' | 'expert';
  tags?: string[];
}
export interface Tool {
  name: string;
  url: string;
  category: string;
  description: string;
  source_type?: 'ai' | 'web' | 'internal' | 'community' | 'expert';
  tags?: string[];
}

================
File: src/lib/types/terminology.types.ts
================
export type TerminologyValue = string | number | boolean | Record<string, any>;
export type TerminologyMap = {
  [key: string]: any;
  terms?: Record<string, any>;
  behaviors?: Record<string, TerminologyOverrideBehavior>;
};
export type ResolvedTerminologyMap = {
  [key: string]: any;
};
export type TerminologyEntityType = 'system' | 'partner' | 'organization' | 'company' | 'team' | 'user';
export type TerminologyOverrideBehavior = 'replace' | 'merge' | 'suggest';
export interface TerminologyEntry {
  key: string;
  value: TerminologyValue;
}
export interface DefaultTerminologyEntry extends TerminologyEntry {
  description?: string;
}
export interface PartnerTerminologyEntry extends TerminologyEntry {
  partner_id: string;
  override_behavior: TerminologyOverrideBehavior;
  created_at?: string;
  updated_at?: string;
}
export interface OrganizationTerminologyEntry extends TerminologyEntry {
  organization_id: string;
  override_behavior: TerminologyOverrideBehavior;
  created_at?: string;
  updated_at?: string;
}
export interface CompanyTerminologyEntry extends TerminologyEntry {
  company_id: string;
  override_behavior: TerminologyOverrideBehavior;
  created_at?: string;
  updated_at?: string;
}
export interface TeamTerminologyEntry extends TerminologyEntry {
  team_id: string;
  override_behavior: TerminologyOverrideBehavior;
  created_at?: string;
  updated_at?: string;
}
export interface UserTerminologyEntry extends TerminologyEntry {
  user_id: string;
  created_at?: string;
  updated_at?: string;
}
export interface JourneyTerminology {
  mainUnit: {
    singular: string;
    plural: string;
    verb?: string;
    possessive?: string;
    articleIndefinite?: string;
    articleDefinite?: string;
  };
  phaseUnit?: {
    singular: string;
    plural: string;
    possessive?: string;
    articleIndefinite?: string;
    articleDefinite?: string;
  };
  stepUnit: {
    singular: string;
    plural: string;
    verb?: string;
    possessive?: string;
    articleIndefinite?: string;
    articleDefinite?: string;
  };
  progressTerms?: {
    notStarted: string;
    inProgress: string;
    completed: string;
    skipped?: string;
    notNeeded?: string;
  };
}
export interface ToolTerminology {
  mainUnit: {
    singular: string;
    plural: string;
    verb?: string;
    possessive?: string;
    articleIndefinite?: string;
    articleDefinite?: string;
  };
  evaluationTerms?: {
    singular: string;
    plural: string;
    verb?: string;
    possessive?: string;
    articleIndefinite?: string;
    articleDefinite?: string;
  };
}
export interface SystemTerminology {
  application?: {
    name: string;
    shortName?: string;
    tagline?: string;
  };
  actions?: {
    [key: string]: string;
  };
}
export interface CompleteTerminology {
  journeyTerms?: JourneyTerminology;
  toolTerms?: ToolTerminology;
  systemTerms?: SystemTerminology;
  [key: string]: any;
}
export interface TerminologyResolutionParams {
  entityType: TerminologyEntityType;
  entityId: string;
  keys?: string[];
}
export interface TerminologySettings {
  enabled: boolean;
  abTestId?: string;
  variant?: string;
}

================
File: src/lib/types/unified-idea.types.ts
================
export interface IdeaWorkspace {
  id: string;
  title: string;
  description?: string;
  user_id: string;
  created_at: string;
  updated_at: string;
  status: 'active' | 'completed' | 'archived';
  active_idea_id?: string;
  settings?: Record<string, any>;
}
export interface UnifiedIdea {
  id: string;
  workspace_id: string;
  title: string;
  description?: string;
  problem_statement?: string;
  solution_concept?: string;
  target_audience?: string;
  unique_value?: string;
  business_model?: string;
  marketing_strategy?: string;
  revenue_model?: string;
  go_to_market?: string;
  market_size?: string;
  user_id: string;
  created_at: string;
  updated_at: string;
  refinement_stage: 'draft' | 'concept' | 'business_model' | 'detailed' | 'components' | 'complete';
  is_merged: boolean;
  parent_ideas?: string[];
  version: number;
  analysis?: IdeaAnalysis;
  ai_feedback?: any;
  selected_suggestions?: any;
  concept_variations?: any[];
  selected_variation?: any;
  merged_variation?: any;
  competition?: string[];
  revenue_streams?: string[];
  cost_structure?: string[];
  key_metrics?: string[];
  key_features?: string[];
  implementation_steps?: string[];
  success_metrics?: string[];
  risks_challenges?: string[];
  component_variations?: ComponentVariation[];
}
export interface ComponentVariation {
  name: string;
  description: string;
  benefits: string[];
  implementation_notes: string;
}
export interface IdeaAnalysis {
  strengths: string[];
  weaknesses: string[];
  opportunities: string[];
  threats: string[];
  suggestions: string[];
  market_insights: string[];
  validation_tips: string[];
  created_at?: string;
}
export interface IdeaComparison {
  id: string;
  workspace_id: string;
  idea_ids: string[];
  comparison_result: IdeaComparisonResult;
  user_id: string;
  created_at: string;
}
export interface IdeaComparisonResult {
  common_strengths: string[];
  unique_strengths: Record<string, string[]>;
  common_weaknesses: string[];
  unique_weaknesses: Record<string, string[]>;
  complementary_aspects: string[];
  conflicting_aspects: string[];
  merger_potential: number;
  merger_suggestions: string[];
}
export interface IdeaMerge {
  id: string;
  workspace_id: string;
  source_ideas: string[];
  result_idea: string;
  merge_rationale?: string;
  user_id: string;
  created_at: string;
}
export interface IdeaGenerationParams {
  topic?: string;
  industry?: string;
  audience?: string;
  problem?: string;
  constraints?: string[];
  count?: number;
  context?: string;
  target_audience?: string;
  problem_area?: string;
  technology?: string;
  business_model_preference?: string;
  market_size_preference?: string;
  innovation_level?: string;
  resource_constraints?: string[];
  title?: string;
}
export interface IdeaContext {
  userId: string;
  context: string;
  workspaceId?: string;
}

================
File: src/lib/utils/journey-validators.ts
================
import { ValidationError } from '../errors/journey-errors';
import {
  JourneyStep,
  Tool,
  difficulty_level,
  step_status
} from '../types/journey-unified.types';
export function validateStep(step: Partial<JourneyStep>): void
export function validateStepStatus(status: step_status): void
export function validateTool(tool: Partial<Tool>): void
export function validateRating(rating: number): void
export function validateCompletionPercentage(percentage: number): void

================
File: src/lib/utils/terminology-utils.ts
================
import {
  TerminologyValue,
  TerminologyMap,
  ResolvedTerminologyMap,
  TerminologyOverrideBehavior
} from '../types/terminology.types';
export function deepMergeTerminology(
  base: TerminologyMap,
  override: TerminologyMap,
  behavior: TerminologyOverrideBehavior = 'replace'
): TerminologyMap
export function flattenTerminology(
  obj: Record<string, any>,
  prefix: string = '',
  result: Record<string, TerminologyValue> = {}
): Record<string, TerminologyValue>
export function unflattenTerminology(map: Record<string, TerminologyValue>): Record<string, any>
export function formatTerminology(
  template: string,
  context: Record<string, any> = {}
): string
export function validateTerminologyCompleteness(
  terminology: Record<string, any>,
  requiredPaths: string[]
): boolean
export function deepGet(
  obj: Record<string, any>,
  path: string,
  defaultValue: any = undefined
): any
export function applyTerminologyOverride(
  base: any,
  override: any,
  behavior: TerminologyOverrideBehavior
): any
export function createDefaultTerminology(): ResolvedTerminologyMap

================
File: src/lib/utils/time-utils.ts
================
export function formatTimeRange(minMinutes: number, maxMinutes: number): string
export function calculateTimeEstimate(minMinutes: number, maxMinutes: number): string
export function getCompletionEstimate(
  estimatedMinMinutes: number,
  estimatedMaxMinutes: number,
  progressPercentage: number
): string
export function formatDate(date: Date | string | number): string
export function getRelativeTime(date: Date | string | number): string

================
File: src/lib/cloud-storage.ts
================
import { supabase } from './supabase';
export type CloudProvider = 'google';
export type CloudScope = 'drive' | 'slides' | 'docs' | 'sheets';
interface CloudCredentials {
  provider: CloudProvider;
  access_token: string;
  refresh_token: string;
  expires_at: number;
  scopes: CloudScope[];
}
export async function getCloudCredentials(provider: CloudProvider): Promise<CloudCredentials | null>
export async function initializeGoogleDrive(): Promise<CloudCredentials | null>
----
const handleMessage = async (event: MessageEvent) =>
const cleanup = () =>
----
export async function saveCloudCredentials(
  provider: CloudProvider,
  credentials: Omit<CloudCredentials, 'provider'>
)
export async function handleOAuthCallback(
  provider: CloudProvider,
  code: string
): Promise<CloudCredentials>

================
File: src/lib/database.types.ts
================


================
File: src/lib/google.ts
================
import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';
----
export const createGoogleSlides = async (title: string, content: any[]) =>
export const updateGoogleSlides = async (presentationId: string, updates: any[]) =>
export const getAuthUrl = () =>
export const handleAuthCallback = async (code: string) =>

================
File: src/lib/huggingface-client.ts
================
import axios from 'axios';
import { appSettingsService } from './services/app-settings.service';
----
export type ModelType = 'base' | 'company' | 'abstraction' | 'user';
export interface GenerateOptions {
  maxLength?: number;
  temperature?: number;
  provider?: string;
  useCompanyModel?: boolean;
  useAbstractionModel?: boolean;
  context?: Record<string, any>;
  conversationHistory?: string;
}
export interface HuggingFaceResponse {
  generated_text: string;
  model_version?: string;
  context_applied?: boolean;
  abstraction_applied?: boolean;
}
----
validateApiKey(apiKey: string): boolean
async getAuthAndModel(modelType: ModelType = 'base'): Promise<
async generate(
    prompt: string,
    modelType: ModelType = 'base',
    context?: Record<string, any>,
    options: Partial<GenerateOptions> = {}
): Promise<HuggingFaceResponse>
----
// Provide more helpful error messages for common API issues
----
/**
   * Generate structured output based on a prompt and schema
   */
async generateStructure<T>(
    prompt: string,
    schema: Record<string, any>,
    modelType: ModelType = 'base',
    context?: Record<string, any>,
    options: Partial<GenerateOptions> = {}
): Promise<T>
async generateVariations(
    prompt: string,
    count: number,
    modelType: ModelType = 'base',
    context?: Record<string, any>,
    options: Partial<GenerateOptions> = {}
): Promise<string[]>
streamText(
    prompt: string,
    callback: (text: string, done: boolean) => void,
    modelType: ModelType = 'base',
    context?: Record<string, any>,
    options: Partial<GenerateOptions> = {}
): AbortController

================
File: src/lib/openai-client.ts
================
import OpenAI from 'openai';

================
File: src/lib/openai.ts
================
import OpenAI from 'openai';
import { supabase } from './supabase';
import { standupAIService } from './services/standup-ai.service';
----
import { StandupEntry } from './services/standup-ai.service';
export const generateTasks = async (entry: StandupEntry, userId: string) =>
export const generateMarketAnalysis = async (idea: any) =>
export const generateMarketSuggestions = async (idea: any) =>
export const generateIdeaVariations = async (idea: any) =>
export const generateCombinedIdeas = async (baseIdea: string, selectedVariations: any[]) =>

================
File: src/lib/slides.ts
================
import { google } from 'googleapis';
interface Slide {
  id: string;
  type: 'cover' | 'problem' | 'solution' | 'market' | 'business' | 'team' | 'custom';
  title: string;
  content: {
    text?: string;
    bullets?: string[];
    image?: string;
  };
}
export const createGoogleSlides = async (title: string, slides: Slide[]) =>
export const updateGoogleSlides = async (presentationId: string, updates: any[]) =>
export const getAuthUrl = () =>
export const handleAuthCallback = async (code: string) =>

================
File: src/lib/store.ts
================
import { create } from 'zustand';
import { User } from '../lib/types/profile.types';
import { profileService } from './services/profile.service';
----
export interface FeatureFlags {
  [key: string]: {
    enabled: boolean;
    visible: boolean;
  };
}
----
interface AuthState {
  user: User | null;
  profile: User | null;
  featureFlags: FeatureFlags;
  setUser: (user: User | null) => void;
  setProfile: (profile: User | null) => void;
  setFeatureFlags: (flags: Partial<FeatureFlags>) => void;
  fetchProfile: (userId: string) => Promise<void>;
  updateSetupProgress: (progress: any) => Promise<void>;
  clearAuth: () => void;
}
----
interface IdeaPlaygroundState {
  currentCanvasId: string | null;
  currentIdeaId: string | null;
  isGeneratingIdeas: boolean;
  setCurrentCanvasId: (id: string | null) => void;
  setCurrentIdeaId: (id: string | null) => void;
  setIsGeneratingIdeas: (isGenerating: boolean) => void;
}
----
interface UIState {
  sidebarOpen: boolean;
  darkMode: boolean;
  setSidebarOpen: (open: boolean) => void;
  toggleSidebar: () => void;
  setDarkMode: (enabled: boolean) => void;
  toggleDarkMode: () => void;
}

================
File: src/lib/supabase.ts
================
import { createClient, SupabaseClient } from '@supabase/supabase-js';
----
function getSupabaseClient(): SupabaseClient
----
export function resetSupabaseClient(): void

================
File: src/lib/supabaseClient.ts
================
import { createClient } from '@supabase/supabase-js';
----
export const handleSupabaseError = (error: any) =>

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
export function cn(...inputs: ClassValue[])

================
File: src/pages/admin/AskWheelRequestsPage.tsx
================
import React, { useState, useEffect } from 'react';
import { askWheelService, AskWheelRequest } from '../../lib/services/askWheel.service';
import { supabase } from '../../lib/supabase';
interface RequestWithDetails extends AskWheelRequest {
  journey_steps?: {
    id: string;
    name: string;
    phase_id: string;
  };
  users?: {
    id: string;
    email: string;
    full_name?: string;
  };
}
----
const fetchRequests = async () =>
----
const handleSubmitResponse = async () =>

================
File: src/pages/auth/GoogleCallback.tsx
================
import React, { useEffect, useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { AlertCircle } from 'lucide-react';

================
File: src/pages/auth/MicrosoftCallback.tsx
================
import React, { useEffect, useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { handleOAuthCallback } from '../../lib/cloud-storage';
import { AlertCircle } from 'lucide-react';
----
const handleCallback = async () =>

================
File: src/pages/community/CommunityPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import {
  Users,
  Calendar,
  MessageSquare,
  FolderOpen,
  Plus,
  Settings,
  ChevronRight,
  Clock,
  FileText,
  Tag,
  AlertCircle
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
interface Community {
  id: string;
  name: string;
  description: string;
  slug: string;
  avatar_url: string;
  banner_url: string;
  member_count: number;
  is_private: boolean;
  owner: {
    full_name: string;
  };
}
interface Member {
  id: string;
  role: string;
  user: {
    full_name: string;
    avatar_url: string;
  };
}
interface Post {
  id: string;
  title: string;
  content: string;
  created_at: string;
  author: {
    full_name: string;
  };
  upvotes: number;
  downvotes: number;
}
interface Event {
  id: string;
  title: string;
  description: string;
  start_time: string;
  end_time: string;
  location: string;
  organizer: {
    full_name: string;
  };
}
interface Document {
  id: string;
  title: string;
  description: string;
  file_type: string;
  created_at: string;
  author: {
    full_name: string;
  };
}
----
const loadCommunity = async () =>
----
// Load community details
----
const joinCommunity = async () =>
const handleNewPost = () =>
const handleNewEvent = () =>
const handleUploadDocument = () =>
----
<div className="mt-1 text-sm text-gray-500">
----
Uploaded by

================
File: src/pages/community/NewPost.tsx
================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import {
  ArrowLeft,
  Tag as TagIcon,
  X,
  MessageSquare,
  Plus
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
----
const handleAddTag = (e: React.KeyboardEvent<HTMLInputElement>) =>
const handleRemoveTag = (tagToRemove: string) =>
const handleSubmit = async (e: React.FormEvent) =>
----
onChange=
----
</label>

================
File: src/pages/community/Post.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  ArrowLeft,
  ThumbsUp,
  ThumbsDown,
  MessageCircle,
  Share2,
  Bookmark,
  Clock,
  Tag
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
interface Post {
  id: string;
  title: string;
  content: string;
  author_id: string;
  post_type: string;
  category: string;
  tags: string[];
  upvotes: number;
  downvotes: number;
  created_at: string;
  author?: {
    full_name: string;
    avatar_url: string;
  };
}
interface Comment {
  id: string;
  content: string;
  author_id: string;
  created_at: string;
  upvotes: number;
  downvotes: number;
  author?: {
    full_name: string;
    avatar_url: string;
  };
}
----
if (!id) return; // Ensure we have a valid UUID
----
const loadPost = async () =>
const loadComments = async () =>
const loadUserVote = async () =>
const handleVote = async (voteType: boolean) =>
const handleSubmitComment = async (e: React.FormEvent) =>
----
{/* Back Button */}
----
{/* Post */}
----
{/* Post Header */}
----
{/* Post Content */}
----
{/* Tags */}
----
{/* Post Actions */}
----
{/* Comments */}
----
{/* New Comment Form */}
----
{/* Comments List */}

================
File: src/pages/company/JourneyBoard/AIRecommendationPanel.tsx
================
import React, { useState } from "react";
interface AIRecommendationPanelProps {
  recommendations: string[];
  aiInfo?: string;
  onAskQuestion: (question: string) => void;
  aiAnswer?: string;
  loading?: boolean;
}
const AIRecommendationPanel: React.FC<AIRecommendationPanelProps> = ({
  recommendations,
  aiInfo,
  onAskQuestion,
  aiAnswer,
  loading,
}) =>
----
const handleAsk = (e: React.FormEvent) =>
----
onChange=

================
File: src/pages/company/JourneyBoard/FilterBar.tsx
================
import React from "react";
interface FilterBarProps {
  phases: string[];
  statuses: string[];
  selectedPhase: string | "All";
  selectedStatus: string | "All";
  search: string;
  onPhaseChange: (phase: string | "All") => void;
  onStatusChange: (status: string | "All") => void;
  onSearchChange: (search: string) => void;
  view: string;
  onViewChange: (view: string) => void;
}

================
File: src/pages/company/JourneyBoard/JourneyBoard.tsx
================
import React from "react";
import PhaseColumn from "./PhaseColumn";
interface Step {
  id: string;
  name: string;
  description?: string;
  phaseName: string;
  status: "not_started" | "in_progress" | "completed" | "skipped" | "not_needed";
  isParallel?: boolean;
  isArchived?: boolean;
  notes?: string;
  recommendations?: string[];
  aiInfo?: string;
}
interface JourneyBoardProps {
  phases: string[];
  stepsByPhase: Record<string, Step[]>;
  onStatusChange: (stepId: string, status: string) => void;
  onEditStep?: (stepId: string) => void;
  onDeleteStep?: (stepId: string) => void;
  onToggleParallel?: (stepId: string) => void;
  onArchiveStep?: (stepId: string) => void;
  onNotesChange?: (stepId: string, notes: string) => void;
}

================
File: src/pages/company/JourneyBoard/ListView.tsx
================
import React from "react";
interface ListViewProps {
  steps: Array<{
    id: string;
    name: string;
    status: "not_started" | "in_progress" | "completed" | "skipped" | "not_needed";
    isArchived?: boolean;
    onStatusChange: (status: string) => void;
    onReorder: (stepId: string, direction: "up" | "down") => void;
  }>;
}
const ListView: React.FC<ListViewProps> = (
----
onChange=

================
File: src/pages/company/JourneyBoard/PhaseColumn.tsx
================
import React from "react";
import StepCard from "./StepCard";
interface PhaseColumnProps {
  phaseName: string;
  steps: Array<{
    id: string;
    name: string;
    description?: string;
    status: "not_started" | "in_progress" | "completed" | "skipped" | "not_needed";
    isParallel?: boolean;
    isArchived?: boolean;
    notes?: string;
    recommendations?: string[];
    aiInfo?: string;
  }>;
  onStatusChange: (stepId: string, status: string) => void;
  onEditStep?: (stepId: string) => void;
  onDeleteStep?: (stepId: string) => void;
  onToggleParallel?: (stepId: string) => void;
  onArchiveStep?: (stepId: string) => void;
  onNotesChange?: (stepId: string, notes: string) => void;
}
----
onStatusChange=
----
onNotesChange=

================
File: src/pages/company/JourneyBoard/StepCard.tsx
================
import React from "react";
import { useNavigate } from "react-router-dom";
interface StepCardProps {
  id: string;
  name: string;
  description?: string;
  phaseName?: string;
  status: "not_started" | "in_progress" | "completed" | "skipped" | "not_needed";
  isParallel?: boolean;
  isArchived?: boolean;
  onStatusChange: (status: StepCardProps["status"]) => void;
  onEdit?: () => void;
  onDelete?: () => void;
  onToggleParallel?: () => void;
  onArchive?: () => void;
  notes?: string;
  onNotesChange?: (notes: string) => void;
  recommendations?: string[];
  aiInfo?: string;
}

================
File: src/pages/company/CompanyBudgetPage.tsx
================
import React, { useEffect, useState } from "react";
import { financialHubService } from "../../lib/services/financialHub.service";
----
// eslint-disable-next-line react-hooks/exhaustive-deps
----
async function fetchBudget()
async function fetchTemplates()
async function handleImportTemplate(e: React.FormEvent)
async function handleSaveLine(e: React.FormEvent)
async function handleRemoveLine(budgetId: string)

================
File: src/pages/company/CompanyDashboard.tsx
================
import React, { useEffect, useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { companyJourneyService } from "../../lib/services/companyJourney.service";
import { companyAccessService } from "../../lib/services/company-access.service";
import { useAuthStore } from "../../lib/store";
import { LayoutDashboard, Route, ListChecks, Landmark, Lightbulb, Wrench, Users, Settings, FileText } from 'lucide-react';
import JourneyProgressWidget from '../../components/company/dashboard/JourneyProgressWidget';
import MyTasksWidget from '../../components/company/dashboard/MyTasksWidget';
import FinancialSnapshotWidget from '../../components/company/dashboard/FinancialSnapshotWidget';
import JourneyMapView from '../../components/company/dashboard/JourneyMapView';
----
const fetchUserCompany = async () =>

================
File: src/pages/company/CompanySettings.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Building2,
  Users,
  Settings,
  FolderOpen,
  Cloud,
  Plus,
  X,
  Save,
  Trash2,
  RefreshCw,
  Minus
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
import TeamManagement from '../../components/TeamManagement';
import CloudStorageSettings from '../../components/CloudStorageSettings';
interface Company {
  id: string;
  name: string;
  description?: string;
  mission?: string;
  vision_statement?: string;
  core_values?: string[];
  company_culture?: string;
  industries: string[];
  website?: string;
  size?: string;
  stage?: string;
  business_model?: string;
  target_market?: string;
  is_public: boolean;
  logo_url?: string;
  social_links: {
    linkedin?: string;
    twitter?: string;
    github?: string;
    facebook?: string;
  };
  product_roadmap: {
    current_stage: string | null;
    key_features: string[];
    upcoming_releases: string[];
    long_term_vision: string | null;
  };
  tech_stack: {
    frontend: string[];
    backend: string[];
    infrastructure: string[];
    tools: string[];
  };
  team_structure: {
    departments: string[];
    key_roles: string[];
  };
  team_composition: {
    full_time: number;
    part_time: number;
    contractors: number;
  };
}
interface CompanyMember {
  id: string;
  role: string;
  title: string;
  department: string;
  user_id: string;
  user_email: string;
}
----
const loadCompany = async () =>
----
// Get the latest company where user is owner
----
const loadMembers = async () =>
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) =>
const handleArrayInputChange = (section: keyof Company, field: string, value: string, index: number) =>
const handleAddArrayItem = (section: keyof Company, field: string) =>
const handleRemoveArrayItem = (section: keyof Company, field: string, index: number) =>
const handleJsonInputChange = (section: keyof Company, field: string, value: any) =>
const handleSave = async () =>
const handleDeleteCompany = async () =>
const handleRelaunchSetup = () =>
----
{/* Danger Zone */}

================
File: src/pages/company/CompanySetup.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Building2, Briefcase, Users, Globe, DollarSign, Target, Brain, Plus, X } from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
----
// Try to load saved data from session storage
----
// Market Info
----
// Business Model
----
// Product Info
----
// Team Info
----
// Profile
----
// Filter suggested industries based on search
----
const handleAddIndustry = (industry: string) =>
const handleRemoveIndustry = (industry: string) =>
const handleAddCustomIndustry = () =>
// Save form data to session storage when it changes
----
const checkExistingCompany = async () =>
----
// Check if user is a member of any companies
----
const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
) =>
const handleSave = async (goToDashboard = false) =>
----
// Prepare data for saving, separating direct columns and metadata
----
industries: formData.industries, // Now matches TEXT[] in DB
----
target_market: formData.target_market, // New column
business_model: formData.business_model, // New column
revenue_model: formData.revenue_model, // New column
team_size: formData.team_size, // New column
----
mission: formData.mission, // New column
is_public: formData.is_public, // New column
social_links: formData.social_links, // New JSONB column
metadata: { // Store remaining fields in metadata
----
// Add any other fields not directly mapped to columns
----
// Update existing company
----
const handleNext = () =>
const handleBack = () =>
const handleExit = () =>
----
onChange=
----
placeholder="https://example.com"

================
File: src/pages/company/CompanyToolEvaluationPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { companyToolEvaluationService } from '../../lib/services/companyToolEvaluation.service';
import { companyToolsService } from '../../lib/services/companyTools.service';
import { useAuth } from '../../lib/hooks/useAuth';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';
----
interface EvaluationRecord {
    id: string;
    company_id: string;
    tool_id: string;
    added_by: string;
    added_at: string;
    notes?: string | null;
    is_selected?: boolean;
}
interface ScorecardEntry {
    id: string;
    evaluation_id: string;
    criterion: string;
    rating: number;
    notes?: string | null;
}
function CompanyToolEvaluationPage()
----
const [comments, setComments] = useState(''); // Local state for overall comments
----
async function fetchData(cId: string, ctLinkId: string)
----
// 1. Fetch the company_tools link entry (assuming service exists)
//    We need this to potentially get the actual tool_id if needed later
//    Let's assume companyToolsService.getCompanyToolById(ctLinkId) exists for now
----
// 3. Fetch existing scorecard entries for this evaluation
----
// Populate local state
----
EVALUATION_CRITERIA.forEach(c => initialScores[c.key] = null); // Default null
----
// No evaluation found for this ID - this shouldn't happen if linking is correct
----
// TODO: Fetch actual tool details (name, url etc.) based on evaluation.tool_id if needed
----
const handleScoreChange = (key: string, value: string) =>
const handleScoreNoteChange = (key: string, value: string) =>
const handleSubmit = async (e: React.FormEvent) =>
----
const notes = scoreNotes[criterion.key] || ''; // Get notes for this score
if (rating !== null) { // Only save if a rating was given
----
notes // Pass notes to service
----
return Promise.resolve(); // Return resolved promise if no rating
----
// Update the overall comments/notes
----
// Optionally refetch data
// fetchData(companyId, evaluationId);
----
onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleScoreChange(criterion.key, e.target.value)} // Added type
----
{/* Optional: Add input for notes per criterion */}
{/* <Textarea placeholder="Notes..." value={scoreNotes[criterion.key] ?? ''} onChange={(e) => handleScoreNoteChange(criterion.key, e.target.value)} /> */}
----
onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => setComments(e.target.value)} // Added type
----
{/* Assuming CardFooter is exported from '@/components/ui/card' */}

================
File: src/pages/company/CompanyToolsPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { journeyContentService } from '../../lib/services/journeyContent.service';
import { companyToolsService } from '../../lib/services/companyTools.service';
import { useAuth } from '../../lib/hooks/useAuth';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { toast } from 'sonner';
import EvaluationHistory, { EvaluationHistoryEntry } from '../../components/company/journey/ToolSelector/EvaluationHistory';
----
async function fetchCompanyTools(id: string)
async function handleExpandTool(toolId: string)
----
// Merge evaluations and documents by user/evaluation

================
File: src/pages/company/JourneyChallengeDetailPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { JourneyChallenge, challenge_status } from '../../lib/types/journey-challenges.types';
import { JourneyChallengesService } from '../../lib/services/journeyChallenges.service';
import { StatusBadge, DifficultyIndicator, EstimatedTime } from '../../components/company/journey/ChallengeCard';
import { ArrowLeft, Check, PlayCircle, XCircle } from 'lucide-react';
import { supabase } from '../../lib/supabase';
----
const fetchUserCompany = async () =>
----
const loadChallengeData = async () =>
----
const updateStatus = async (newStatus: challenge_status) =>

================
File: src/pages/company/JourneyChallengesPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { JourneyChallenge, JourneyPhase } from '../../lib/types/journey-challenges.types';
import { JourneyChallengesService } from '../../lib/services/journeyChallenges.service';
import { ChallengeList } from '../../components/company/journey/ChallengeList';
import { PhaseProgress } from '../../components/company/journey/PhaseProgress';
import { supabase } from '../../lib/supabase';
import { Filter, Search, Sliders, ArrowLeft } from 'lucide-react';
----
const fetchUserCompany = async () =>
----
const loadData = async () =>
----
const handleStartChallenge = async (challenge: JourneyChallenge) =>
const handleCustomizeChallenge = (challenge: JourneyChallenge) =>
const handleMarkIrrelevant = async (challenge: JourneyChallenge) =>
const handleChallengeClick = (challenge: JourneyChallenge) =>
const getPhaseProgress = (phase: JourneyPhase) =>

================
File: src/pages/company/JourneyMapPage.tsx
================
import React, { useEffect, useState, useCallback } from "react";
import { toast } from "sonner";
import JourneyBoard from "./JourneyBoard/JourneyBoard";
import AIRecommendationPanel from "./JourneyBoard/AIRecommendationPanel";
import FilterBar from "./JourneyBoard/FilterBar";
----
import ListView from "./JourneyBoard/ListView";
import { RecommendationsPanel } from "../../components/company/journey/StepRecommendations";
import { JourneyAnalyticsDashboard } from "../../components/company/journey/Analytics";
----
aiInfo: "", // TODO: fetch per step
----
// Fetch AI recommendations
----
const handleStatusChange = async (stepId: string, status: string) =>
----
await loadData(); // Refresh data after update
----
const handleEditStep = async (stepId: string) =>
----
// TODO: Implement edit logic
----
const handleDeleteStep = async (stepId: string) =>
----
await loadData(); // Refresh data after deletion
----
const handleToggleParallel = async (stepId: string) =>
----
await loadData(); // Refresh data after toggling parallel
----
const handleArchiveStep = async (stepId: string) =>
----
await loadData(); // Refresh data after archiving
----
const handleNotesChange = async (stepId: string, notes: string) =>
const handleAskAI = async (question: string) =>
----
// Add type assertion to fix TypeScript error
----
// Filtered steps

================
File: src/pages/company/JourneyOverviewPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../lib/supabase';
import { ArrowRight, PlusCircle } from 'lucide-react';
import JourneyOverview from '../../components/company/journey/JourneyOverview';
import { Term } from '../../components/terminology/Term';
----
const fetchUserCompany = async () =>

================
File: src/pages/company/JourneyPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Filter, Settings, X } from 'lucide-react';
import { TimelineView } from '../../components/company/journey/TimelineView';
import { ListView } from '../../components/company/journey/ListView';
import { ViewToggle, ViewMode } from '../../components/company/journey/ViewToggle';
import { SimplePhaseProgressList } from '../../components/company/journey/PhaseProgress/SimplePhaseProgressList';
import { StepStatus } from '../../components/company/journey/StepCard/StepCardProps';
import { Term } from '../../components/terminology/Term';
import { StepAssistant } from '../../components/company/journey/StepAssistant';
import { MilestoneCelebrationAnimation } from '../../components/visualization';
import { useJourneyPageData } from '../../lib/hooks/useJourneyPageData';
----
// Fetch data
----
// Calculate phase completion percentage
const calculatePhaseCompletion = (phaseId: string): number =>
const handleStepSelect = (stepId: string) =>
const handleStatusUpdate = (stepId: string, status: string) =>
const handleFilterToggle = () =>
----
setStatusFilter([...statusFilter, status as StepStatus]);

================
File: src/pages/company/JourneyStepPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import { ChevronLeft } from 'lucide-react';
import JourneyStepDetails from '../../components/company/journey/JourneyStepDetails';
import ChallengeEditor from '../../components/company/journey/ChallengeEditor';
import { supabase } from '../../lib/supabase';
import { JourneyChallengesService } from '../../lib/services/journeyChallenges.service';
import { JourneyChallenge } from '../../lib/types/journey-challenges.types';
interface JourneyStepPageProps {
  mode?: 'view' | 'edit' | 'create';
}
----
const fetchUserCompany = async () =>
----
const fetchChallenge = async () =>
----
const handleChallengeSubmit = (challenge: any) =>
----
const getBackLink = () =>
const getBackText = () =>
----
<Link to=
----

================
File: src/pages/company/JourneyStepsPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { EnhancedJourneyStep } from '../../lib/types/journey-steps.types';
import { StepList, DraggableStepList } from '../../components/company/journey/StepList';
import { PhaseProgress } from '../../components/company/journey/PhaseProgress';
import journeyStepsService from '../../lib/services/journeySteps.service';
import { Switch } from '@headlessui/react';
----
// State
----
// Load data on component mount
----
const loadData = async () =>
----
// Load phases
----
// If no phase is selected, use the first one
----
// Load steps (enhanced version)
----
// Filter steps based on selected filters
----
// Apply phase filter
----
// Apply status filter
----
// Apply search filter
----
// Handle step click - navigate to step detail page
const handleStepClick = (step: EnhancedJourneyStep) =>
// Handle mark as irrelevant click
const handleMarkIrrelevant = async (step: EnhancedJourneyStep) =>
----
// Update local state
----
const handleStepsReorder = async (reorderedSteps: EnhancedJourneyStep[]) =>
const handleSaveOrder = async () =>

================
File: src/pages/company/JourneyStepsRedirect.tsx
================
import React, { useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
const JourneyStepsRedirect: React.FC = () =>

================
File: src/pages/idea-hub/AIDiscussion.tsx
================
import React, { useState, useEffect } from 'react';
import { Bot, Send, ArrowLeft, Save, Plus, RotateCw } from 'lucide-react';
import { Link } from 'react-router-dom';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
import { ideaGenerationService, Message as AIMessage } from '../../lib/services/idea-generation.service';
import { ideaMemoryService } from '../../lib/services/idea-memory.service';
interface Message {
  role: 'user' | 'assistant';
  content: string;
}
----
const loadDiscussion = async () =>
----
const handleSubmit = async (e: React.FormEvent) =>
----
// Check if enhanced idea generation is enabled
----
// Use the new ideaGenerationService
----
// Convert messages to the format expected by the service
----
// Fallback to mock response
----
// Add AI response
----
const handleSave = async (messagesToSave = messages) =>
const handleNew = () =>
----
onChange=

================
File: src/pages/idea-hub/BusinessGenerator.tsx
================
import React from 'react';
import BusinessGenerator from '../../components/BusinessGenerator';
export default function BusinessGeneratorPage()

================
File: src/pages/idea-hub/BusinessModel.tsx
================
import React, { useState, useEffect } from 'react';
import { Coins, ArrowLeft, Save, Plus, DollarSign, MinusCircle } from 'lucide-react';
import { Link } from 'react-router-dom';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
interface RevenueStream {
  name: string;
  type: string;
  amount: number;
  frequency: string;
  description: string;
}
interface CostItem {
  name: string;
  type: 'fixed' | 'variable';
  amount: number;
  frequency: string;
}
interface KeyMetric {
  name: string;
  target: string;
  current: string;
  unit: string;
}
----
const loadModel = async () =>
----
const handleSave = async () =>
const handleNew = () =>
const addRevenueStream = () =>
const addCostItem = () =>
const addKeyMetric = () =>
----
{/* Header */}
----
setRevenueStreams(newStreams);
----
setCostStructure(newCosts);
----
setKeyMetrics(newMetrics);

================
File: src/pages/idea-hub/CofounderBot.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Bot,
  Send,
  Brain,
  MessageSquare,
  Clock,
  CheckSquare,
  Target,
  AlertCircle,
  ArrowRight,
  ListChecks,
  FileText
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
import TaskPromptDialog from '../../components/TaskPromptDialog';
import { generateTasks } from '../../lib/openai';
import { standupAIService, StandupEntry } from '../../lib/services/standup-ai.service';
interface Message {
  role: 'user' | 'assistant';
  content: string;
  type: 'question' | 'answer' | 'feedback' | 'summary' | 'section_transition';
  section?: string;
}
----
const handleNextSection = async () =>
const generateSummary = async () =>
----
// Try to get company ID if it exists, but don't require it
----
// Store tasks for later use
// This could be used to display task suggestions or populate the task creation dialog
----
const handleSaveStandup = async () =>
----
// Create a data object without the answers field first
----
const handleInputSubmit = async (e: React.FormEvent) =>
----
// Create context for AI service without requiring company_id
----
// Try to get company ID if it exists, but don't require it
----
const handleGenerateTasks = () =>
const handleExit = () =>
----
onChange=

================
File: src/pages/idea-hub/EnhancedIdeaHub.tsx
================
import React, { useEffect, useState } from 'react';
import { useIdeaHubStore } from '../../enhanced-idea-hub/store/idea-hub-store';
import ViewManager from '../../enhanced-idea-hub/components/ViewManager';
import { EnhancedIdeaPlaygroundIdea, OwnershipType, IdeaType } from '../../enhanced-idea-hub/types';
const DashboardIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
    <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
  </svg>
);
const PersonalIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
    <path fillRule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clipRule="evenodd" />
  </svg>
);
const CompanyIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
    <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" />
  </svg>
);
const PlusIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
    <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
  </svg>
);
const SearchIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
    <path fillRule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clipRule="evenodd" />
  </svg>
);
const FilterIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
    <path fillRule="evenodd" d="M3 3a1 1 0 011-1h12a1 1 0 011 1v3a1 1 0 01-.293.707L12 11.414V15a1 1 0 01-.293.707l-2 2A1 1 0 018 17v-5.586L3.293 6.707A1 1 0 013 6V3z" clipRule="evenodd" />
  </svg>
);
----
const [selectedIdeaTypes, setSelectedIdeaTypes] = useState<IdeaType[]>([]);
----
const [newIdeaData, setNewIdeaData] = useState({
    title: '',
    description: '',
    ideaType: 'new_feature' as IdeaType,
    ownershipType: 'personal' as OwnershipType
  });
----
fetchIdeas();
----
const handleSelectIdea = (idea: EnhancedIdeaPlaygroundIdea) =>
const handleCreateIdea = async () =>
const handleCloseDetail = () =>
----
onChange=

================
File: src/pages/idea-hub/ExplorationHub.tsx
================
import React from 'react';
import IdeaExplorer from '../../components/idea-exploration/IdeaExplorer';
export default function ExplorationHub()

================
File: src/pages/idea-hub/IdeaCanvas.tsx
================
import React, { useState, useEffect } from 'react';
import { FileSpreadsheet, ArrowLeft, Save, Plus, Trash2 } from 'lucide-react';
import { Link } from 'react-router-dom';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
interface CanvasSection {
  title: string;
  content: string;
  placeholder: string;
}
----
const loadCanvas = async () =>
----
const handleSectionChange = (index: number, content: string) =>
const handleSave = async () =>
const handleNew = () =>
----
{/* Header */}

================
File: src/pages/idea-hub/IdeaComparisonPage.tsx
================
import React from 'react';
import IdeaComparison from '../../components/idea-exploration/IdeaComparison';
export default function IdeaComparisonPage()

================
File: src/pages/idea-hub/IdeaDetailPage.tsx
================
import React from 'react';
import IdeaDetail from '../../components/idea-exploration/IdeaDetail';
export default function IdeaDetailPage()

================
File: src/pages/idea-hub/IdeaFlow.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Lightbulb,
  Brain,
  Target,
  Users,
  DollarSign,
  BarChart3,
  Rocket,
  ChevronRight,
  Plus,
  Save,
  MessageSquare,
  ArrowRight,
  X,
  Edit,
  Archive,
  Trash2
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
import { generateTasks } from '../../lib/openai';
interface Idea {
  id: string;
  title: string;
  description: string;
  status: 'draft' | 'exploring' | 'validated' | 'archived';
  problem_statement: string;
  solution_concept: string;
  target_audience: string;
  unique_value: string;
  market_size: string;
  competitors: any[];
  market_trends: string[];
  revenue_streams: any[];
  cost_structure: any[];
  key_metrics: string[];
  channels: string[];
  assumptions: string[];
  validation_steps: any[];
  feedback_collected: any[];
  pivot_notes: string[];
  ai_feedback: {
    strengths: string[];
    weaknesses: string[];
    opportunities: string[];
    threats: string[];
    suggestions: string[];
    market_insights: string[];
    validation_tips: string[];
  };
}
----
const loadIdeas = async () =>
const createNewIdea = () =>
const generateAIFeedback = async () =>
----
// Parse AI feedback into sections
----
// Extract insights from feedback
----
const handleSave = async () =>
const handleDelete = async (idea: Idea) =>
const handleArchive = async (idea: Idea) =>
----
onChange=
----
setCurrentIdea(

================
File: src/pages/idea-hub/IdeaMergerPage.tsx
================
import React from 'react';
import IdeaMerger from '../../components/idea-exploration/IdeaMerger';
export default function IdeaMergerPage()

================
File: src/pages/idea-hub/IdeaRefinement.tsx
================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Lightbulb,
  ArrowLeft,
  Brain,
  AlertCircle,
  Save,
  ArrowRight,
  Check,
  RotateCw,
  Edit,
  Plus,
  X,
  Wand2,
  RefreshCw
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
import { generateIdeaVariations, generateCombinedIdeas } from '../../lib/openai';
interface Variation {
  id: string;
  title: string;
  description: string;
  differentiator: string;
  targetMarket: string;
  revenueModel: string;
  isSelected: boolean;
  isEditing: boolean;
  editedTitle?: string;
  editedDescription?: string;
  likedAspects?: string;
}
interface RefinedIdea {
  id: string;
  title: string;
  description: string;
  sourceElements: string[];
  targetMarket: string;
  revenueModel: string;
  valueProposition: string;
  isSelected: boolean;
  isEditing: boolean;
  editedTitle?: string;
  editedDescription?: string;
}
----
const handleSave = async (continueToNext: boolean = false) =>
----
// Prepare the idea data based on selection
----
const generateVariations = async () =>
const regenerateVariation = async (variationId: string) =>
const generateCombined = async () =>
const toggleVariationSelection = (id: string) =>
const toggleVariationEdit = (id: string) =>
const saveVariationEdit = (id: string) =>
const updateVariationContent = (id: string, field: string, value: string) =>
const updateLikedAspects = (id: string, value: string) =>
const selectRefinedIdea = (id: string) =>
const toggleRefinedIdeaEdit = (id: string) =>
const updateRefinedIdeaContent = (id: string, field: string, value: string) =>
const regenerateCombinedIdea = async (id: string) =>
const handleBack = () =>
----
onChange=

================
File: src/pages/idea-hub/MarketResearch.tsx
================
import React, { useState, useEffect } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';
import {
  BarChart3,
  ArrowLeft,
  Brain,
  Users,
  Target,
  Building,
  DollarSign,
  TrendingUp,
  Save,
  RotateCw,
  ArrowRight,
  Edit2,
  X,
  Check,
  Trash2
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
import { generateMarketAnalysis } from '../../lib/openai';
interface Source {
  name: string;
  url: string;
  type: string;
  year: number;
}
interface CustomerProfile {
  segment: string;
  description: string;
  needs: string[];
  pain_points: string[];
  buying_behavior: string;
  sources: Source[];
}
interface MarketAnalysis {
  customer_profiles: CustomerProfile[];
  early_adopters: {
    type: string;
    characteristics: string[];
    acquisition_strategy: string;
    sources: Source[];
  }[];
  sales_channels: {
    channel: string;
    effectiveness: number;
    cost: string;
    timeline: string;
    sources: Source[];
  }[];
  pricing_insights: {
    model: string;
    price_point: string;
    justification: string;
    sources: Source[];
  }[];
  market_size: {
    tam: string;
    sam: string;
    som: string;
    growth_rate: string;
    sources: Source[];
  };
}
interface EditableProfile extends CustomerProfile {
  isEditing: boolean;
}
----
const loadIdea = async () =>
const handleGenerateAnalysis = async () =>
const toggleEditProfile = (index: number) =>
const updateProfile = (index: number, field: keyof CustomerProfile, value: any) =>
const handleDeleteProfile = (index: number) =>
const handleSave = async () =>
----
// Update analysis with edited profiles
----
{/* Header */}
----
{/* Analysis Content */}
----
{/* Navigation */}
----
onChange=
----
updateProfile(index, 'needs', newNeeds);
----
updateProfile(index, 'pain_points', newPoints);

================
File: src/pages/idea-hub/MarketValidation.tsx
================
import React from 'react';
import { useLocation, Navigate } from 'react-router-dom';
import MarketValidationQuestions from '../../components/MarketValidationQuestions';
interface LocationState {
  ideaId: string;
  ideaData: {
    title: string;
    description: string;
    target_market: string;
    solution_concept: string;
  };
}
export default function MarketValidation()

================
File: src/pages/idea-hub/PitchDeck.tsx
================
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import {
  Rocket,
  ArrowLeft,
  Save,
  Plus,
  Presentation,
  ChevronLeft,
  ChevronRight,
  Share2,
  Download,
  Copy,
  Check,
  Globe,
  Lock
} from 'lucide-react';
import { supabase } from '../../lib/supabase';
import { useAuthStore } from '../../lib/store';
import { createGoogleSlides } from '../../lib/slides';
interface Slide {
  id: string;
  type: 'cover' | 'problem' | 'solution' | 'market' | 'business' | 'team' | 'custom';
  title: string;
  content: {
    text?: string;
    bullets?: string[];
    image?: string;
  };
}
----
const loadDeck = async () =>
const handleSave = async () =>
const handleNew = () =>
const addSlide = (type: Slide['type']) =>
const updateSlide = (index: number, updates: Partial<Slide>) =>
const handleExport = async () =>
----
updateSlide(currentSlide, {
                              content: { ...slides[currentSlide].content, bullets: newBullets }
                            });
----
updateSlide(currentSlide, {
                          content: { ...slides[currentSlide].content, bullets: newBullets }
                        });
----
{/* Share Dialog */}
----
{/* Visibility Setting */}

================
File: src/pages/idea-hub/QuickGeneration.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, Button, CircularProgress, Typography, Container, Paper } from '@mui/material';
import { ArrowRight, Save, Lightbulb } from 'lucide-react';
import SaveIdeaModal from '../../components/idea-playground/SaveIdeaModal';
import { useAuthStore } from '../../lib/store';
import SuggestionsScreen from '../../components/idea-playground/pathway1/SuggestionsScreen';
import { Suggestion } from '../../components/idea-playground/pathway1/SuggestionCard';
import IdeaCaptureScreen from '../../components/idea-playground/pathway1/IdeaCaptureScreen';
import { IdeaPlaygroundIdea } from '../../lib/types/idea-playground.types';
import { ideaPlaygroundAdapter } from '../../lib/services/idea-playground/service-adapter';
import { AIContextProvider } from '../../lib/services/ai/ai-context-provider';
enum WorkflowStep {
  CAPTURE_IDEA = 'capture_idea',
  SUGGESTIONS = 'suggestions',
  COMPLETE = 'complete'
}
----
const handleCreateIdea = async (initialIdeaData: {
    title: string;
    description: string;
    solution_concept?: string;
    used_company_context?: boolean;
    company_id?: string;
}, event?: React.FormEvent) =>
----
problem_statement: '', // Added to ensure we have required fields
target_audience: [], // Initialize as empty array to match type
----
// Set the idea in state
----
// Move to the suggestions step within this component
----
// Handle suggestion selection and completion
const handleSelectSuggestion = (suggestion: Suggestion) =>
----
// Set the selected suggestion
----
// Update the idea with the selected suggestion details
----
// Convert target_audience from string to string[] to match IdeaPlaygroundIdea type
----
target_audience: targetAudienceArray, // Use the array version
----
// Update the idea in the database
----
// Move to the complete step
----
// Handle back navigation
const handleBack = () =>
----
// If we're already at the first step, go back to the idea selection screen
----
onCreateIdea=
----
onSave=
----

================
File: src/pages/idea-hub/Refinement.tsx
================
import React, { useEffect, useState } from 'react';
import { useAuthStore } from '../../lib/store';
import { IdeaProvider } from '../../lib/contexts/IdeaContext';
import IdeaRefinementWorkflow from '../../components/idea-refinement/IdeaRefinementWorkflow';
import { useLocation } from 'react-router-dom';
----
export default function Refinement()

================
File: src/pages/idea-hub/ResourceLibrary.tsx
================
import React, { useState, useEffect } from 'react';
import { Library, ArrowLeft, Search, Download, ExternalLink, Tag, Filter } from 'lucide-react';
import { Link } from 'react-router-dom';
import { supabase } from '../../lib/supabase';
interface Resource {
  id: string;
  title: string;
  description: string;
  category: string;
  type: string;
  content_url: string;
  thumbnail_url: string;
  tags: string[];
  is_premium: boolean;
}
----
const loadResources = async () =>

================
File: src/pages/idea-hub/SavedIdeasPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Typography,
  Box,
  Grid,
  Card,
  CardContent,
  CardActions,
  Button,
  Chip,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  CircularProgress,
  Divider,
  IconButton,
  Tooltip,
  SelectChangeEvent
} from '@mui/material';
import {
  Lightbulb,
  Edit,
  Trash2,
  Search,
  Filter,
  Building,
  User,
  Calendar,
  ArrowRight,
  RefreshCw
} from 'lucide-react';
import { useAuthStore } from '../../lib/store';
import { ideaPlaygroundAdapter } from '../../lib/services/idea-playground/service-adapter';
import { IdeaPlaygroundIdea, IdeaType, Company } from '../../lib/types/idea-playground.types';
import { companyService } from '../../lib/services/company.service';
----
const fetchIdeas = async () =>
const fetchCompanies = async () =>
----
const sortIdeas = (ideasToSort: IdeaPlaygroundIdea[], sortCriteria: string) =>
const handleDeleteIdea = async (ideaId: string) =>
const getCompanyName = (companyId: string | undefined) =>
// Format date for display
const formatDate = (dateString: string) =>
const getIdeaTypeDisplay = (type: string | undefined) =>
const getIdeaTypeColor = (type: string | undefined): "primary" | "secondary" | "success" | "info" | "default" =>
----
onChange=
----

================
File: src/pages/idea-hub/TestComponent.tsx
================
import React from 'react';
import IdeaRefinement from '../../components/IdeaRefinement';
import { useAuthStore } from '../../lib/store';
----
export default function TestComponent()

================
File: src/pages/idea-hub/UnifiedWorkflow.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { UnifiedIdeaProvider } from '../../lib/contexts/UnifiedIdeaContext';
import UnifiedIdeaWorkspace from '../../components/unified-idea/UnifiedIdeaWorkspace';
const UnifiedWorkflow: React.FC = () =>

================
File: src/pages/idea-playground/IdeaPlaygroundPage.tsx
================
import React from 'react';
import { useAuthStore } from '../../lib/store';
import PathwayRouter from './PathwayRouter';
const IdeaPlaygroundPage: React.FC = () =>

================
File: src/pages/idea-playground/IdeaPlaygroundPageWrapper.tsx
================
import React, { useEffect } from 'react';
import IdeaPlaygroundPage from './IdeaPlaygroundPage';
import { activateAllFeatures } from '../../lib/services/feature-activator';
import { useAuthStore } from '../../lib/store';
const IdeaPlaygroundPageWrapper: React.FC = () =>

================
File: src/pages/idea-playground/PathwayRouter.tsx
================
import React, { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuthStore } from '../../lib/store';
import { AIContextProvider } from '../../lib/services/ai/ai-context-provider';
----
const handlePathwaySelect = (pathwayId: string) =>

================
File: src/pages/profile/PersonaManagementPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { multiPersonaProfileService } from '../../lib/services/multi-persona-profile.service';
import { useAuthStore } from '../../lib/store';
import { Plus, Edit, Trash, Check, RefreshCw } from 'lucide-react';
----
const loadPersonas = async () =>
----
const showSuccessMessage = (message: string) =>
const handleSetActive = async (personaId: string) =>
const handleDelete = async (personaId: string) =>
const getTypeStyles = (type: string): string =>

================
File: src/pages/AdminAppSettingsPage.tsx
================
import React, { useEffect, useState } from "react";
import { appSettingsService } from "../lib/services/appSettings.service";
----
async function fetchSettings()
async function handleSave(key: string)

================
File: src/pages/AdminJourneyContentPage.tsx
================
import React, { useEffect, useState } from "react";
import { journeyContentService } from "../lib/services/journeyContent.service";
import ExcelImportMapper from "../components/admin/ExcelImportMapper";
----
// State for new step creation
----
// State for new tool creation
----
// State for global tool selection - COMMENTED OUT as getAllGlobalTools was removed
// const [globalTools, setGlobalTools] = useState<any[]>([]);
// const [selectedGlobalToolId, setSelectedGlobalToolId] = useState<string | null>(null);
// const [addingGlobalTool, setAddingGlobalTool] = useState(false);
----
// eslint-disable-next-line react-hooks/exhaustive-deps
----
async function fetchPhases()
----
console.error("Error fetching phases:", err); // Log error
----
// eslint-disable-next-line react-hooks/exhaustive-deps
----
async function fetchSteps(phaseId: string)
----
setSelectedStepId(null); // Reset step selection when phase changes
----
console.error("Error fetching steps:", err); // Log error
----
// setGlobalTools([]); // Commented out
----
// fetchGlobalTools(); // Commented out
// eslint-disable-next-line react-hooks/exhaustive-deps
----
async function fetchTools(stepId: string)
----
console.error("Error fetching tools:", err); // Log error
----
// Commented out as getAllGlobalTools was removed
// async function fetchGlobalTools() {
//   try {
//       const data = await journeyContentService.getAllGlobalTools(); // This function no longer exists
//       setGlobalTools(data || []);
//   } catch (err) {
//       console.error("Error fetching global tools:", err);
//       setGlobalTools([]);
//   }
// }
// CRUD: Create/Update Phase (using Upsert)
async function handleCreatePhase(e: React.FormEvent)
----
// Assuming order_index should be based on current count or needs manual input later
----
order_index: nextOrderIndex, // Assign next order index
order: nextOrderIndex // Also set 'order' if it exists
----
await fetchPhases(); // Refresh list
----
// TODO: Show error to user
----
// CRUD: Delete Phase
async function handleDeletePhase(phaseId: string)
----
await fetchPhases(); // Refresh list
----
// TODO: Show error to user
----
// CRUD: Create/Update Step (using Upsert)
async function handleCreateStep(e: React.FormEvent)
----
// Assuming order_index should be based on current count or needs manual input later
----
order_index: nextOrderIndex, // Assign next order index
order: nextOrderIndex // Also set 'order' if it exists
----
await fetchSteps(selectedPhaseId); // Refresh list
----
// TODO: Show error to user
----
// CRUD: Delete Step
async function handleDeleteStep(stepId: string)
----
if (!selectedPhaseId) return; // Should not happen if button is visible
----
await fetchSteps(selectedPhaseId); // Refresh list
----
// TODO: Show error to user
----
// CRUD: Create Tool (Now uses upsertToolForStep)
async function handleCreateTool(e: React.FormEvent)
----
// We need more info than just name (like URL) for upsertToolForStep
// For now, just log and don't call service, or implement a modal to get more details
----
// Example call if URL was available:
// await journeyContentService.upsertToolForStep(selectedStepId, { name: newToolName, url: 'http://example.com' });
// setNewToolName("");
// await fetchTools(selectedStepId); // Refresh list
----
// TODO: Show error to user
----
// CRUD: Delete Tool (Now deletes the tool entry itself)
async function handleDeleteTool(toolId: string) { // Only needs toolId now
    if (!window.confirm("Delete this tool permanently?")) return;
----
if (!selectedStepId) return; // Should have selected step to be viewing tools
----
await journeyContentService.deleteTool(toolId); // Call updated service function
await fetchTools(selectedStepId); // Refresh list for the current step
----
// TODO: Show error to user
----
// Add existing global tool to step - COMMENTED OUT
// async function handleAddGlobalTool(e: React.FormEvent) {
//   e.preventDefault();
//   if (!selectedStepId || !selectedGlobalToolId) return;
//   setAddingGlobalTool(true);
//   try {
//     // This function no longer exists in the service
//     // await journeyContentService.addExistingToolToStep(selectedStepId, selectedGlobalToolId);
//     console.warn("handleAddGlobalTool needs update: addExistingToolToStep was removed.");
//     alert("Adding global tools needs implementation update.");
//     setSelectedGlobalToolId(null);
//     // await fetchTools(selectedStepId);
//   } finally {
//     setAddingGlobalTool(false);
//   }
// }
----
onChange=
----
{/* Tools Section */}
----
{/* Simplified Add Tool Form - Needs enhancement to collect URL etc. */}
----
{/* Global Tool Section Commented Out */}
{/*
            <form onSubmit={handleAddGlobalTool} className="flex items-center mb-4 gap-2">
              <select
                className="input input-bordered"
                value={selectedGlobalToolId || ""}
                onChange={e => setSelectedGlobalToolId(e.target.value)}
                disabled={addingGlobalTool}
              >
                <option value="">Select global tool to add...</option>
                {globalTools.map(tool => (
                  <option key={tool.id} value={tool.id}>
                    {tool.name} {tool.category ? `(${tool.category})` : ""}
                  </option>
                ))}
              </select>
              <button className="btn btn-primary" type="submit" disabled={addingGlobalTool || !selectedGlobalToolId}>
                {addingGlobalTool ? "Adding..." : "Add Existing Tool"}
              </button>
            </form>
             */}

================
File: src/pages/AdminPanel.tsx
================
import React from 'react';
import UserManagement from '../components/admin/UserManagement';
import FeatureFlagsSettings from '../components/admin/FeatureFlagsSettings';
import OpenAISettings from '../components/admin/OpenAISettings';
import AppCredentialsSettings from '../components/admin/AppCredentialsSettings';
import ModelManagementPanel from '../components/admin/ModelManagementPanel';
import TerminologyManagement from '../components/admin/TerminologyManagement';
import { useAuthStore } from '../lib/store';
const AdminPanel: React.FC = () =>

================
File: src/pages/AdminToolModerationPage.tsx
================
import React, { useEffect, useState } from "react";
import { toolSubmissionService } from "../lib/services/toolSubmission.service";
----
async function fetchSubmissions()
async function handleEnrich(submissionId: string)
async function handleApprove(submissionId: string)
async function handleReject(submissionId: string)
----
onClick=

================
File: src/pages/Community.tsx
================
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import {
  MessageSquare,
  Calendar,
  TrendingUp,
  Clock,
  Tag,
  ThumbsUp,
  MessageCircle,
  Plus,
  Users,
  Search,
  Filter,
  Building2
} from 'lucide-react';
import { supabase } from '../lib/supabase';
import { useAuthStore } from '../lib/store';
import CreateCommunityModal from '../components/CreateCommunityModal';
interface Community {
  id: string;
  name: string;
  description: string;
  slug: string;
  member_count: number;
  is_private: boolean;
  created_at: string;
  owner_id: string;
}
----
const loadCommunities = async () =>

================
File: src/pages/Dashboard.tsx
================
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { useAuthStore } from '../lib/store';
import { supabase } from '../lib/supabase';
import ErrorBoundary from '../components/ErrorBoundary';
import {
  LayoutDashboard,
  MessageSquare,
  Users,
  Code,
  BookOpen,
  GraduationCap,
  Building2,
  FileText,
  Bell,
  Clock,
  ChevronRight,
  Bot,
  Brain,
  Target,
  Lightbulb,
  Calendar,
  Plus
} from 'lucide-react';
import OnboardingProgressCard from '../components/OnboardingProgressCard';
import StandupHistory from '../components/StandupHistory';
import JoinCompanyDialog from '../components/JoinCompanyDialog';
----
// Enhanced debug logging
----
// Performance tracking
----
// Mark component as mounted to help with debugging
----
// Always set a timeout to end loading state even if other operations fail
----
}, 5000); // 5 seconds max loading time
----
// Create an array of promises to run in parallel
----
// Company access check with detailed error handling
----
setHasCompany(false); // Sensible default
----
// Standup entries with detailed error handling
----
setStandupEntries([]); // Empty fallback
----
// Wait for all promises to settle (not necessarily resolve)
----
// Calculate loading time
----
// Ensure loading state is false
----
// Don't block rendering on errors
----
const checkCompanyAccess = async () =>
----
// Use the company access service to prevent infinite recursion
----
const loadStandupEntries = async () =>
----
onSuccess=

================
File: src/pages/Directory.tsx
================
import React, { useState, useEffect } from 'react';
import { Users, Search, MapPin, Globe, Briefcase, Filter, X } from 'lucide-react';
import { supabase } from '../lib/supabase';
interface Profile {
  id: string;
  full_name: string;
  headline: string;
  bio: string;
  skills: string[];
  interests: string[];
  location: string;
  avatar_url: string;
  website: string;
  social_links: {
    linkedin?: string;
    twitter?: string;
    github?: string;
  };
  available_for: {
    mentoring: boolean;
    investing: boolean;
    advising: boolean;
    cofounding: boolean;
  };
}
----
const searchProfiles = async () =>
----
{/* Interests Filter */}
----
setSelectedAvailability([...selectedAvailability, option.value]);
----

================
File: src/pages/EnhancedIdeaHubPage.tsx
================
import React from 'react';
import EnhancedIdeaHub from './idea-hub/EnhancedIdeaHub';
const EnhancedIdeaHubPage: React.FC = () =>

================
File: src/pages/EnhancedOnboardingPage.tsx
================
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuthStore } from '../lib/store';
import { EnhancedOnboardingWizard } from '../components/onboarding/EnhancedOnboardingWizard';
export const EnhancedOnboardingPage: React.FC = () =>

================
File: src/pages/FinancialHubPage.tsx
================
import React, { useEffect, useState } from "react";
import { financialHubService } from "../lib/services/financialHub.service";
import { financialAnalyticsService } from "../lib/services/financialAnalytics.service";
import { appSettingsService } from "../lib/services/appSettings.service";
----
function BreakEvenCalculator(
----
async function fetchTemplates()
async function fetchCompanyBudget()
async function fetchBenchmarks()
async function fetchBudgetStats()
async function fetchBenchmarkMinCount()
function renderAnalytics()

================
File: src/pages/IdeaHub.tsx
================
import React from 'react';
import { Link } from 'react-router-dom';
import {
  Bot,
  FileSpreadsheet,
  Coins,
  Rocket,
  BarChart3,
  Library,
  Plus,
  Lightbulb,
  ArrowRight
} from 'lucide-react';

================
File: src/pages/InitialOnboardingPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '../lib/store';
import { supabase } from '../lib/supabase';
import InitialOnboardingWizard from '../components/onboarding/InitialOnboardingWizard';
import Login from '../pages/Login';
const InitialOnboardingPage: React.FC = () =>
----
const handleOnboardingComplete = async () =>

================
File: src/pages/Login.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Shield, Mail, Key, Eye, EyeOff, AlertCircle } from 'lucide-react';
import { supabase } from '../lib/supabase';
import { useAuthStore } from '../lib/store';
----
// Check if user is already authenticated and redirect to dashboard
----
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleSubmit = async (e: React.FormEvent) =>
----
// Sign up new user
----
// Create initial profile

================
File: src/pages/Messages.tsx
================
import React, { useState, useEffect } from 'react';
import { MessageSquare, Send, Search, User, Clock, Plus, X } from 'lucide-react';
import { supabase } from '../lib/supabase';
import { useAuthStore } from '../lib/store';
interface Message {
  id: string;
  sender_id: string;
  recipient_id: string;
  content: string;
  is_read: boolean;
  created_at: string;
  sender?: {
    full_name: string;
    avatar_url: string;
  };
}
interface Conversation {
  id: string;
  participant1_id: string;
  participant2_id: string;
  last_message_at: string;
  participant?: {
    full_name: string;
    avatar_url: string;
    email: string;
  };
  last_message?: Message;
}
----
const loadConversations = async () =>
const loadMessages = async (conversationId: string) =>
const startNewConversation = async () =>
const sendMessage = async (e: React.FormEvent) =>
----
loadConversations(); // Refresh conversation list to update last_message_at
----
{/* Conversations Sidebar */}
----
{/* Search and New Message */}
----
{/* Conversations List */}
----
{/* Messages Area */}
----
{/* Conversation Header */}
----
{/* Messages */}
----
onChange=

================
File: src/pages/OnboardingDemoPage.tsx
================
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import OnboardingWelcome from '../components/onboarding/steps/OnboardingWelcome';
import GoalsSelectionStep from '../components/onboarding/steps/GoalsSelectionStep';
import { EnhancedCompanyStageStep } from '../components/onboarding/steps/EnhancedCompanyStageStep';
import InitialRoleStep from '../components/onboarding/steps/InitialRoleStep';
import ProfileSetupDemo from '../components/profile/ProfileSetupDemo';
import IndustrySelectionStep from '../components/onboarding/steps/IndustrySelectionStep';
import SkillLevelStep from '../components/onboarding/steps/SkillLevelStep';
import ThemePreferencesStep from '../components/onboarding/steps/ThemePreferencesStep';
import NotificationPreferencesStep from '../components/onboarding/steps/NotificationPreferencesStep';
import FeatureRecommendations from '../components/onboarding/steps/FeatureRecommendations';
import OnboardingCompletion from '../components/onboarding/steps/OnboardingCompletion';
import { IndustryCategory, UserSkillLevel } from '../lib/services/onboarding.service';
import { ProgressTrackingDemo } from '../components/onboarding/ProgressTrackingDemo';
----
const handleBackToSelection = () =>
----
onSelect=
----
onNext=

================
File: src/pages/OnboardingPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import OnboardingController from '../components/onboarding/OnboardingController';
import { useAuthStore } from '../lib/store';
const OnboardingPage: React.FC = () =>

================
File: src/pages/OnboardingWizardPage.tsx
================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '../lib/store';
import OnboardingWizard from '../components/onboarding/OnboardingWizard';
const OnboardingWizardPage: React.FC = () =>
----
const handleOnboardingComplete = async (data: {
    role: ('founder' | 'company_member' | 'service_provider')[];

================
File: src/pages/Profile.tsx
================
import React, { useState, useEffect } from 'react';
import { useAuthStore } from '../lib/store';
import { supabase } from '../lib/supabase';
import { UserCircle, Save, Camera, Briefcase, GraduationCap, Building, Cog, Target } from 'lucide-react';
import { enhancedProfileService } from '../lib/services/enhanced-profile.service';
import { Link } from 'react-router-dom';
import { UserRoleType, CompanyStageType } from '../lib/types/enhanced-profile.types';
----
// These fields might need to be added to the profile type
----
// Enhanced profile data with placeholders
----
// Fetch enhanced profile data if available
----
const fetchEnhancedProfile = async () =>
----
const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
) =>
const handleSocialLinkChange = (platform: string, value: string) =>
const handleArrayItemChange = (field: string, value: string, isAdd: boolean = true) =>
const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) =>
const handleSubmit = async (e: React.FormEvent) =>
----
<span className="sr-only">Remove</span>
                            &times;
                          </button>
                        </div>
                      ))}
                      {isEditing && (
                        <div className="flex">
                          <input
                            type="text"
                            id="new-goal"
                            placeholder="Add a goal"
                            className="flex-grow rounded-l-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
onKeyDown=
----
if (target.value.trim())
----
<span className="sr-only">Remove</span>
                            &times;
                          </button>
                        </div>
                      ))}
                      {isEditing && (
                        <div className="flex">
                          <input
                            type="text"
                            id="new-expertise"
                            placeholder="Add an expertise area"
                            className="flex-grow rounded-l-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
onKeyDown=
----
onChange=

================
File: src/pages/ProfileSetup.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  User,
  Plus,
  Briefcase,
  Globe,
  Link as LinkIcon,
  Mail,
  Building2,
  GraduationCap,
  Target,
  ArrowRight,
  ArrowLeft,
  Check,
  X,
  Settings,
  Save
} from 'lucide-react';
import { supabase } from '../lib/supabase';
import { useAuth } from '../lib/hooks/useAuth';
import CloudStorageSetup from '../components/CloudStorageSetup';
----
interface FormData {
  full_name: string;
  headline: string;
  bio: string;
  location: string;
  timezone: string;
  languages: string[];
  professional_background: string;
  current_role: string;
  company: string;
  industry_experience: string[];
  education: Array<{
    degree: string;
    school: string;
    year: string;
  }>;
  skills: string[];
  interests: string[];
  achievements: string[];
  looking_for: string[];
  is_public: boolean;
  allows_messages: boolean;
  availability_status: 'full-time' | 'part-time' | 'weekends' | 'evenings' | 'not-available';
  mentor_preferences: {
    willing_to_mentor: boolean;
    seeking_mentor: boolean;
    areas_of_expertise: string[];
    areas_of_interest: string[];
  };
  social_links: {
    linkedin: string;
    twitter: string;
    github: string;
    website: string;
  };
}
----
// Expertise
----
// Preferences
----
const saveProgress = async () =>
----
const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
) =>
const handleArrayInput = (field: keyof FormData, value: string) =>
const removeArrayItem = (field: keyof FormData, index: number) =>
const handleSocialLinkChange = (platform: string, value: string) =>
const handleSubmit = async (e: React.FormEvent) =>
const handleSaveAndExit = async () =>
const handleNext = () =>
const handleBack = () =>
----
handleArrayInput('industry_experience', e.currentTarget.value);
----
handleArrayInput('skills', e.currentTarget.value);
----
handleArrayInput('interests', e.currentTarget.value);

================
File: src/pages/SettingsPage.tsx
================
import React, { useState, useEffect } from 'react';
import { Cog, Users, Link, Flag } from 'lucide-react';
import OpenAISettings from '../components/admin/OpenAISettings';
import AppCredentialsSettings from '../components/admin/AppCredentialsSettings';
import FeatureFlagsSettings from '../components/admin/FeatureFlagsSettings';
import UserManagement from '../components/admin/UserManagement';
import { featureFlagsService } from '../lib/services/feature-flags.service';
----
const loadFlags = async () =>

================
File: src/pages/SimplifiedDashboard.tsx
================
import React, { useState, useEffect } from 'react';
import { useAuthStore } from '../lib/store';
import { supabase } from '../lib/supabase';
import ErrorBoundary from '../components/ErrorBoundary';
----
// Enhanced debug logging
----
// Performance tracking
----
// Mark component as mounted to help with debugging
----
// Always set a timeout to end loading state even if other operations fail
----
}, 5000); // 5 seconds max loading time
----
// Simplified data loading - no dynamic imports
----
// Handle missing profile case
----
const checkCompanyAccess = async () =>
----
// Direct query instead of using service
----
const loadStandupEntries = async () =>

================
File: src/pages/StandupTestPage.tsx
================
import React, { useState } from 'react';
import { StandupEntry, StandupFeedback, StandupTask } from '../lib/services/standup-ai.service';
import { useStandupAIContext } from '../lib/services/ai/standup-context-provider';
import { useAuthStore } from '../lib/store';
----
const toggleFeatureFlag = (flag: string) =>
const handleGenerateFeedback = async () =>
const handleGenerateTasks = async () =>
const updateEntry = (field: keyof StandupEntry, value: string) =>

================
File: src/pages/StandupTestPageWrapper.tsx
================
import React from 'react';
import StandupTestPage from './StandupTestPage';
import { StandupAIProvider } from '../lib/services/ai/standup-context-provider';
const StandupTestPageWrapper: React.FC = () =>

================
File: src/pages/TerminologyDemoPage.tsx
================
import React from 'react';
import { TerminologyShowcase, TerminologyProvider } from '../components/terminology';

================
File: src/pages/TestPage.tsx
================
import React from 'react';
import IdeaPathway1AIServiceTest from '../test';
function TestPage()

================
File: src/pages/ToolsMarketplacePage.tsx
================
import React, { useEffect, useState } from 'react';
import { journeyContentService } from '../lib/services/journeyContent.service';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
----
async function fetchTools()
----
// TODO: Decide how to fetch tools for the marketplace now.
// Option 1: Fetch all unique tools from journey_step_tools? Requires backend change or complex query.
// Option 2: Fetch tools from a different source if applicable?
// For now, commenting out the call to the removed function.
// const data = await journeyContentService.getAllGlobalTools();
----
const data: any[] = []; // Placeholder
----
onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchTerm(e.target.value)} // Added type for 'e'

================
File: src/tests/journey-unified-tools.test.ts
================
import { JourneyUnifiedService } from '../lib/services/journey-unified.service';
import { supabase } from '../lib/supabase';
import { Tool, CompanyStepTool } from '../lib/types/journey-unified.types';

================
File: src/tests/journey-unified.service.test.ts
================
import { JourneyUnifiedService } from '../lib/services/journey-unified.service';
import { supabase } from '../lib/supabase';
import {
  JourneyPhase,
  JourneyStep,
  CompanyJourneyStep,
  JourneyStepComplete
} from '../lib/types/journey-unified.types';

================
File: src/types/global.d.ts
================
interface Window {
}

================
File: src/ui/components/Dashboard/DashboardLayout.tsx
================
import React from 'react';
import { colors, spacing, shadows, borderRadius } from '../../design-system';
import Card from '../Card';
export interface MetricProps {
  title: string;
  value: string | number;
  previousValue?: string | number;
  change?: number;
  trend?: boolean;
  icon?: React.ReactNode;
  description?: string;
  footer?: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
export interface WidgetProps {
  title?: string;
  children: React.ReactNode;
  width?: number;
  height?: number;
  collapsible?: boolean;
  collapsed?: boolean;
  onToggleCollapse?: () => void;
  loading?: boolean;
  actions?: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
export interface DashboardLayoutProps {
  title?: string;
  description?: string;
  children: React.ReactNode;
  columns?: number;
  gap?: string;
  actions?: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
----
/**
 * Widget component for dashboard content
 */

================
File: src/ui/components/DragDrop/DraggableList.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import { colors, spacing, shadows, borderRadius } from '../../design-system';
export interface DraggableItem {
  id: string;
  content: React.ReactNode;
  disabled?: boolean;
  data?: any;
}
export interface DraggableListProps {
  items: DraggableItem[];
  onReorder: (items: DraggableItem[]) => void;
  direction?: 'horizontal' | 'vertical';
  showPlaceholder?: boolean;
  placeholder?: React.ReactNode;
  disabled?: boolean;
  renderItem?: (item: DraggableItem, isDragging: boolean, index: number) => React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
  handleSelector?: string;
  animationDuration?: number;
  dragDelay?: number;
}
----
// State for tracking dragging
----
// Refs
----
// Reset item refs when items change
----
// Handle drag start
const handleDragStart = (e: React.MouseEvent | React.TouchEvent, item: DraggableItem, index: number) =>
----
// Check if handle selector is specified and if the event target matches it
----
// Get client position
----
const handleDragMove = (e: MouseEvent | TouchEvent) =>
const handleDragEnd = () =>
const getDragOffset = () =>
----
onMouseDown=
onTouchStart=

================
File: src/ui/components/Navigation/Sidebar.tsx
================
import React, { useState } from 'react';
import { colors, spacing, shadows, borderRadius } from '../../design-system';
export interface NavItem {
  key: string;
  label: string;
  icon?: React.ReactNode;
  url?: string;
  active?: boolean;
  disabled?: boolean;
  children?: NavItem[];
  expanded?: boolean;
  badge?: React.ReactNode | string | number;
  onClick?: (item: NavItem) => void;
}
export interface SidebarProps {
  items: NavItem[];
  collapsed?: boolean;
  onToggleCollapse?: () => void;
  expandedWidth?: string;
  collapsedWidth?: string;
  backgroundColor?: string;
  textColor?: string;
  activeBackgroundColor?: string;
  activeTextColor?: string;
  hoverBackgroundColor?: string;
  hoverTextColor?: string;
  logo?: React.ReactNode;
  footer?: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
----
// State for expanded sections
----
// Toggle section expansion
const toggleSection = (key: string) =>
// Check if a section is expanded
const isSectionExpanded = (key: string): boolean =>
// Handle item click
const handleItemClick = (item: NavItem) =>
// Render a navigation item

================
File: src/ui/components/Card.tsx
================
import React from 'react';
import { colors, shadows, borderRadius, spacing } from '../design-system';
export interface CardProps {
  title?: string;
  subtitle?: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  width?: string;
  height?: string;
  elevation?: 1 | 2 | 3 | 4 | 5;
  hoverable?: boolean;
  selectable?: boolean;
  selected?: boolean;
  draggable?: boolean;
  bordered?: boolean;
  borderColor?: string;
  backgroundColor?: string;
  padding?: string;
  margin?: string;
  borderRadius?: string;
  headerActions?: React.ReactNode;
  coverImage?: string;
  coverImageAlt?: string;
  coverImageHeight?: string;
  onClick?: () => void;
  className?: string;
  style?: React.CSSProperties;
  id?: string;
  'data-testid'?: string;
}
----
const getShadow = (level: number) =>

================
File: src/ui/styles/components.css
================
.card {
.card.hoverable:hover {
.card.draggable:active {
.card.selected {

================
File: src/ui/design-system.ts
================


================
File: src/App.tsx
================
import React, { useEffect, useState } from 'react';
import { Routes, Route, Navigate, useLocation, useNavigate } from 'react-router-dom';
import { useAuthStore } from './lib/store';
import type { User, UserProfile } from './lib/types/profile.types';
import { loggingService } from './lib/services/logging.service';
import { LoggingProvider } from './components/LoggingProvider';
import ErrorBoundary from './components/ErrorBoundary';
import Login from './pages/Login';
import Dashboard from './pages/Dashboard';
import Profile from './pages/Profile';
import ProfileSetup from './pages/ProfileSetup';
import OnboardingPage from './pages/OnboardingPage';
import OnboardingWizardPage from './pages/OnboardingWizardPage';
import InitialOnboardingPage from './pages/InitialOnboardingPage';
import { EnhancedOnboardingPage } from './pages/EnhancedOnboardingPage';
import OnboardingDemoPage from './pages/OnboardingDemoPage';
import TerminologyDemoPage from './pages/TerminologyDemoPage';
import Directory from './pages/Directory';
import CofounderBot from './pages/idea-hub/CofounderBot';
import AIDiscussion from './pages/idea-hub/AIDiscussion';
import MarketValidation from './pages/idea-hub/MarketValidation';
import BusinessModel from './pages/idea-hub/BusinessModel';
import PitchDeck from './pages/idea-hub/PitchDeck';
import IdeaCanvas from './pages/idea-hub/IdeaCanvas';
import TestComponent from './pages/idea-hub/TestComponent';
import TestPage from './pages/TestPage';
import AdminPanel from './pages/AdminPanel';
import SettingsPage from './pages/SettingsPage';
import CompanySetup from './pages/company/CompanySetup';
import CompanyDashboard from './pages/company/CompanyDashboard';
import CompanySettings from './pages/company/CompanySettings';
import JourneyMapPage from './pages/company/JourneyMapPage';
import JourneyStepPage from './pages/company/JourneyStepPage';
import JourneyChallengesPage from './pages/company/JourneyChallengesPage';
import JourneyOverviewPage from './pages/company/JourneyOverviewPage';
import JourneyChallengeDetailPage from './pages/company/JourneyChallengeDetailPage';
import JourneyStepsPage from './pages/company/JourneyStepsPage';
import JourneyPage from './pages/company/JourneyPage';
import JourneyStepsRedirect from './pages/company/JourneyStepsRedirect';
import IdeaHub from './pages/IdeaHub';
import EnhancedIdeaHub from './pages/idea-hub/EnhancedIdeaHub';
import EnhancedIdeaHubPage from './pages/EnhancedIdeaHubPage';
import TaskCreation from './components/tasks/TaskCreation';
import Refinement from './pages/idea-hub/Refinement';
import Community from './pages/Community';
import Messages from './pages/Messages';
import Layout from './components/Layout';
import GoogleCallback from './pages/auth/GoogleCallback';
import AdminJourneyContentPage from './pages/AdminJourneyContentPage';
import AdminToolModerationPage from './pages/AdminToolModerationPage';
import AskWheelRequestsPage from './pages/admin/AskWheelRequestsPage';
import ExplorationHub from './pages/idea-hub/ExplorationHub';
import IdeaDetailPage from './pages/idea-hub/IdeaDetailPage';
import IdeaComparisonPage from './pages/idea-hub/IdeaComparisonPage';
import IdeaMergerPage from './pages/idea-hub/IdeaMergerPage';
import UnifiedWorkflow from './pages/idea-hub/UnifiedWorkflow';
import QuickGeneration from './pages/idea-hub/QuickGeneration';
import SavedIdeasPage from './pages/idea-hub/SavedIdeasPage';
import { cleanLocalStorage } from './lib/services/localStorage-cleaner';
import { AIContextProvider as AIProvider } from './lib/services/ai/ai-context-provider';
import LLMProviderTest from './components/LLMProviderTest';
import DragDropProvider from './components/DragDropProvider';
----
const handleUnhandledRejection = (event: PromiseRejectionEvent) =>

================
File: src/index.css
================
:root {
.dark {
@tailwind base;
@tailwind components;
@tailwind utilities;
@layer base {
----
body {

================
File: src/Layout.tsx
================
import React, { useState, useEffect } from 'react';
import { Link, useNavigate, useLocation, Outlet } from 'react-router-dom';
import { useAuthStore } from './lib/store';
import { useAuth } from './lib/hooks/useAuth';
----
import {
  LayoutDashboard,
  Building2,
  MessageSquare,
  Users,
  BookOpen,
  FileText,
  Wallet,
  Settings,
  LogOut,
  Menu,
  X,
  Bell,
  Search,
  Shield,
  Scale,
  Code2,
  Wrench,
  Lightbulb,
  PiggyBank,
  ChevronDown,
  User,
  UserCircle,
  Construction
} from 'lucide-react';
import { supabase } from './lib/supabase';
interface NavItem {
  name: string;
  href: string;
  icon: React.ElementType;
  badge?: string;
  isEnabled?: boolean;
  children?: NavItem[];
}
----
const checkCompanyAccess = async () =>
----
const handleSignOut = async () =>
----
const renderNavItem = (item: NavItem) =>
----

================
File: src/main.tsx
================
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter as Router } from 'react-router-dom';
import { authService } from './lib/services/auth.service';
import { useAuthStore } from './lib/store';
import { featureFlagsService } from './lib/services/feature-flags.service';
import App from './App.tsx';
----
const initApp = async () =>
----
email: session.user.email || '', // Ensure email is never undefined
----
email: session.user.email || '', // Ensure email is never undefined

================
File: src/setupTests.ts
================


================
File: src/test.tsx
================
import React, { useEffect, useState } from 'react';
import { Typography, Box, CircularProgress, Button } from '@mui/material';
import { ideaPathway1AIService } from './lib/services/idea-pathway1-ai.service';
function IdeaPathway1AIServiceTest()
----
const runTests = async () =>

================
File: src/vite-env.d.ts
================


================
File: supabase/migrations/20250316131100_multi_persona_profile_system.sql
================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS user_core_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT NOT NULL,
  full_name TEXT,
  display_name TEXT,
  avatar_url TEXT,
  bio TEXT,
  pronouns TEXT,
  locale TEXT DEFAULT 'en-US',
  timezone TEXT,
  verified BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_active_at TIMESTAMP WITH TIME ZONE,
  account_status TEXT DEFAULT 'active',
  system_metadata JSONB DEFAULT '{}'::JSONB,
  CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);
CREATE TABLE IF NOT EXISTS user_settings (
  user_id UUID PRIMARY KEY REFERENCES user_core_profiles(id),
  theme TEXT DEFAULT 'system',
  notifications JSONB DEFAULT '{"email": true, "push": true, "inApp": true, "digest": false}'::JSONB,
  display JSONB DEFAULT '{"compactView": false, "showTips": true, "cardSize": "medium"}'::JSONB,
  features JSONB DEFAULT '{}'::JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS user_personas (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES user_core_profiles(id),
  name TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('founder', 'service_provider', 'company_member', 'investor', 'advisor', 'community', 'custom')),
  icon TEXT,
  is_public BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT false,
  professional JSONB DEFAULT '{}'::JSONB,
  network JSONB DEFAULT '{}'::JSONB,
  company_affiliations JSONB DEFAULT '{}'::JSONB,
  project_context JSONB DEFAULT '{}'::JSONB,
  personalization JSONB DEFAULT '{}'::JSONB,
  billing JSONB DEFAULT '{}'::JSONB,
  visibility_settings JSONB DEFAULT '{
    "discoverable_as": ["founder"],
    "visible_to": ["public"],
    "hidden_fields": []
  }'::JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_used_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(user_id, name)
);
CREATE TABLE IF NOT EXISTS persona_context_rules (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES user_core_profiles(id),
  persona_id UUID NOT NULL REFERENCES user_personas(id),
  context TEXT NOT NULL,
  condition TEXT NOT NULL,
  priority INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, context, condition)
);
CREATE TABLE IF NOT EXISTS persona_switch_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES user_core_profiles(id),
  from_persona_id UUID REFERENCES user_personas(id),
  to_persona_id UUID NOT NULL REFERENCES user_personas(id),
  trigger TEXT NOT NULL CHECK (trigger IN ('manual', 'auto', 'rule')),
  context TEXT,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS onboarding_state (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES user_core_profiles(id),
  persona_id UUID NOT NULL REFERENCES user_personas(id),
  current_step TEXT,
  completed_steps JSONB DEFAULT '[]'::JSONB,
  form_data JSONB DEFAULT '{}'::JSONB,
  is_complete BOOLEAN DEFAULT false,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  metrics JSONB DEFAULT '{}'::JSONB,
  UNIQUE(user_id, persona_id)
);
CREATE INDEX IF NOT EXISTS idx_user_core_profiles_email ON user_core_profiles(email);
CREATE INDEX IF NOT EXISTS idx_user_core_profiles_status ON user_core_profiles(account_status);
CREATE INDEX IF NOT EXISTS idx_personas_user_id ON user_personas(user_id);
CREATE INDEX IF NOT EXISTS idx_personas_user_active ON user_personas(user_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_personas_type ON user_personas(user_id, type);
CREATE INDEX IF NOT EXISTS idx_personas_public ON user_personas(is_public) WHERE is_public = true;
CREATE INDEX IF NOT EXISTS idx_onboarding_user_persona ON onboarding_state(user_id, persona_id);
CREATE INDEX IF NOT EXISTS idx_onboarding_incomplete ON onboarding_state(user_id) WHERE is_complete = false;
CREATE INDEX IF NOT EXISTS idx_context_rules_context ON persona_context_rules(user_id, context);
CREATE INDEX IF NOT EXISTS idx_context_rules_priority ON persona_context_rules(user_id, priority DESC);
CREATE OR REPLACE FUNCTION update_timestamp_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER update_user_settings_timestamp
BEFORE UPDATE ON user_settings
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE OR REPLACE FUNCTION manage_active_personas()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_active THEN
    UPDATE user_personas
    SET is_active = false
    WHERE user_id = NEW.user_id AND id != NEW.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER ensure_single_active_persona
BEFORE UPDATE OF is_active ON user_personas
FOR EACH ROW
WHEN (NEW.is_active = true)
EXECUTE FUNCTION manage_active_personas();
CREATE OR REPLACE FUNCTION migrate_existing_profiles()
RETURNS void AS $$
DECLARE
  profile_record RECORD;
  persona_id UUID;
BEGIN
  FOR profile_record IN SELECT * FROM profiles LOOP
    INSERT INTO user_core_profiles (
      id, email, full_name, avatar_url, verified, created_at, last_active_at
    ) VALUES (
      profile_record.id,
      profile_record.email,
      profile_record.full_name,
      profile_record.avatar_url,
      true,
      profile_record.created_at,
      NOW()
    ) ON CONFLICT (id) DO NOTHING;
    INSERT INTO user_settings (
      user_id,
      theme,
      notifications,
      features
    ) VALUES (
      profile_record.id,
      COALESCE((profile_record.settings->>'theme'), 'system'),
      COALESCE(profile_record.settings->'notifications', '{"email": true, "push": true, "inApp": true, "digest": false}'::jsonb),
      COALESCE(profile_record.settings->'features', '{}'::jsonb)
    ) ON CONFLICT (user_id) DO NOTHING;
    INSERT INTO user_personas (
      user_id,
      name,
      type,
      is_public,
      is_active,
      professional,
      company_affiliations
    ) VALUES (
      profile_record.id,
      CASE
        WHEN profile_record.company_role = 'founder' THEN 'Founder Profile'
        WHEN profile_record.company_role IS NOT NULL THEN 'Company Member Profile'
        ELSE 'Primary Profile'
      END,
      CASE
        WHEN profile_record.company_role = 'founder' THEN 'founder'
        WHEN profile_record.company_role IS NOT NULL THEN 'company_member'
        ELSE 'custom'
      END,
      COALESCE(profile_record.is_public, false),
      true,
      jsonb_build_object(
        'title', profile_record.company_role,
        'industry', profile_record.company_industry,
        'role_category', CASE
          WHEN profile_record.company_role = 'founder' THEN 'FOUNDER'
          WHEN profile_record.company_role IS NOT NULL THEN 'COMPANY_MEMBER'
          ELSE 'CUSTOM'
        END
      ),
      jsonb_build_object(
        'primary_company_id', profile_record.company_id,
        'primary_company_role', profile_record.company_role,
        'primary_company_title', profile_record.company_role
      )
    )
    RETURNING id INTO persona_id;
    IF profile_record.setup_progress IS NOT NULL THEN
      INSERT INTO onboarding_state (
        user_id,
        persona_id,
        current_step,
        completed_steps,
        form_data,
        is_complete,
        last_updated
      ) VALUES (
        profile_record.id,
        persona_id,
        COALESCE(profile_record.setup_progress->>'current_step', 'welcome'),
        COALESCE(profile_record.setup_progress->'completed_steps', '[]'::jsonb),
        COALESCE(profile_record.setup_progress->'form_data', '{}'::jsonb),
        CASE
          WHEN profile_record.setup_progress->>'current_step' = 'complete' THEN true
          ELSE false
        END,
        COALESCE(profile_record.setup_progress->>'last_updated', NOW()::text)::timestamp with time zone
      );
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
ALTER TABLE user_core_profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_core_profiles_select ON user_core_profiles
  FOR SELECT
  USING (auth.uid() = id OR auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY user_core_profiles_update ON user_core_profiles
  FOR UPDATE
  USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);
ALTER TABLE user_personas ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_personas_select ON user_personas
  FOR SELECT
  USING (auth.uid() = user_id OR is_public = true OR
         auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY user_personas_insert ON user_personas
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY user_personas_update ON user_personas
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY user_personas_delete ON user_personas
  FOR DELETE
  USING (auth.uid() = user_id);
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_settings_select ON user_settings
  FOR SELECT
  USING (auth.uid() = user_id OR
         auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY user_settings_update ON user_settings
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
ALTER TABLE onboarding_state ENABLE ROW LEVEL SECURITY;
CREATE POLICY onboarding_state_select ON onboarding_state
  FOR SELECT
  USING (auth.uid() = user_id OR
         auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY onboarding_state_update ON onboarding_state
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
ALTER TABLE user_core_profiles ADD COLUMN IF NOT EXISTS active_persona_id UUID REFERENCES user_personas(id);
CREATE INDEX IF NOT EXISTS idx_core_active_persona ON user_core_profiles(active_persona_id);
CREATE OR REPLACE VIEW active_personas AS
SELECT
  c.id AS user_id,
  c.email,
  c.full_name,
  p.id AS persona_id,
  p.name AS persona_name,
  p.type AS persona_type,
  p.is_public,
  p.professional,
  p.company_affiliations,
  p.visibility_settings
FROM
  user_core_profiles c
JOIN
  user_personas p ON p.id = c.active_persona_id OR (c.active_persona_id IS NULL AND p.is_active = true AND p.user_id = c.id);
CREATE OR REPLACE VIEW user_onboarding_status AS
SELECT
  c.id AS user_id,
  c.email,
  p.id AS persona_id,
  p.name AS persona_name,
  p.type AS persona_type,
  o.is_complete,
  o.current_step,
  o.completed_steps,
  o.last_updated
FROM
  user_core_profiles c
JOIN
  user_personas p ON p.user_id = c.id
LEFT JOIN
  onboarding_state o ON o.persona_id = p.id AND o.user_id = c.id;
COMMENT ON TABLE user_core_profiles IS 'Core user identity information shared across all personas';
COMMENT ON TABLE user_personas IS 'User personas representing different professional identities';
COMMENT ON TABLE user_settings IS 'Application settings separated from profile data';
COMMENT ON TABLE onboarding_state IS 'Onboarding progress tracked per persona';
COMMENT ON TABLE persona_context_rules IS 'Rules for automatic context-based persona switching';

================
File: supabase/migrations/20250316145000_enhanced_profile_completion.sql
================
CREATE TABLE IF NOT EXISTS profile_sections (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  section_key TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  completion_percentage INTEGER DEFAULT 0,
  is_required BOOLEAN DEFAULT false,
  display_order INTEGER DEFAULT 0,
  required_fields JSONB DEFAULT '[]'::JSONB,
  optional_fields JSONB DEFAULT '[]'::JSONB,
  is_role_specific BOOLEAN DEFAULT false,
  applicable_roles TEXT[] DEFAULT '{}'::TEXT[],
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, section_key)
);
CREATE TABLE IF NOT EXISTS user_work_experience (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  company_name TEXT NOT NULL,
  title TEXT NOT NULL,
  start_date DATE,
  end_date DATE,
  is_current BOOLEAN DEFAULT false,
  description TEXT,
  location TEXT,
  skills TEXT[],
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS user_education (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  institution TEXT NOT NULL,
  degree TEXT,
  field_of_study TEXT,
  start_date DATE,
  end_date DATE,
  is_current BOOLEAN DEFAULT false,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS professional_services (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  category TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  expertise_level TEXT CHECK (expertise_level IN ('beginner', 'intermediate', 'advanced', 'expert')),
  rate_type TEXT CHECK (rate_type IN ('hourly', 'project', 'retainer')),
  rate_range JSONB,
  availability TEXT CHECK (availability IN ('part_time', 'full_time', 'contract')),
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS profile_notifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  type TEXT NOT NULL CHECK (type IN ('milestone', 'section', 'inactivity', 'quality', 'recommendation')),
  priority TEXT NOT NULL CHECK (priority IN ('critical', 'important', 'standard', 'informational')),
  title TEXT NOT NULL,
  description TEXT,
  action_url TEXT,
  action_label TEXT,
  icon TEXT,
  is_read BOOLEAN DEFAULT false,
  dismissible BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  triggered_by TEXT
);
CREATE TABLE IF NOT EXISTS company_invitations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL,
  code TEXT NOT NULL UNIQUE,
  email TEXT,
  invited_by UUID NOT NULL REFERENCES auth.users(id),
  role TEXT,
  department TEXT,
  message TEXT,
  is_accepted BOOLEAN DEFAULT false,
  accepted_by UUID REFERENCES auth.users(id),
  accepted_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE
);
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS completion_percentage INTEGER DEFAULT 0;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS completion_last_updated TIMESTAMP WITH TIME ZONE;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS primary_role TEXT;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS additional_roles TEXT[];
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT false;
CREATE INDEX IF NOT EXISTS idx_profile_sections_user ON profile_sections(user_id);
CREATE INDEX IF NOT EXISTS idx_profile_sections_completion ON profile_sections(user_id, completion_percentage);
CREATE INDEX IF NOT EXISTS idx_profile_sections_required ON profile_sections(user_id) WHERE is_required = true;
CREATE INDEX IF NOT EXISTS idx_work_experience_user ON user_work_experience(user_id);
CREATE INDEX IF NOT EXISTS idx_work_experience_current ON user_work_experience(user_id) WHERE is_current = true;
CREATE INDEX IF NOT EXISTS idx_education_user ON user_education(user_id);
CREATE INDEX IF NOT EXISTS idx_services_user ON professional_services(user_id);
CREATE INDEX IF NOT EXISTS idx_services_category ON professional_services(category);
CREATE INDEX IF NOT EXISTS idx_services_active ON professional_services(user_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_profile_notifications_user ON profile_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_profile_notifications_unread ON profile_notifications(user_id) WHERE is_read = false;
CREATE OR REPLACE FUNCTION calculate_section_completion(
  p_section_id UUID,
  p_field_data JSONB
) RETURNS INTEGER AS $$
DECLARE
  v_required_fields JSONB;
  v_optional_fields JSONB;
  v_required_count INTEGER := 0;
  v_optional_count INTEGER := 0;
  v_completed_required INTEGER := 0;
  v_completed_optional INTEGER := 0;
  v_field TEXT;
  v_percentage INTEGER;
BEGIN
  SELECT required_fields, optional_fields
  INTO v_required_fields, v_optional_fields
  FROM profile_sections
  WHERE id = p_section_id;
  v_required_count := jsonb_array_length(v_required_fields);
  v_optional_count := jsonb_array_length(v_optional_fields);
  FOR i IN 0..v_required_count-1 LOOP
    v_field := v_required_fields->i->>'field';
    IF p_field_data ? v_field AND p_field_data->>v_field IS NOT NULL AND p_field_data->>v_field != '' THEN
      v_completed_required := v_completed_required + 1;
    END IF;
  END LOOP;
  -- Check optional fields
  FOR i IN 0..v_optional_count-1 LOOP
    v_field := v_optional_fields->i->>'field';
    IF p_field_data ? v_field AND p_field_data->>v_field IS NOT NULL AND p_field_data->>v_field != '' THEN
      v_completed_optional := v_completed_optional + 1;
    END IF;
  END LOOP;
  -- Calculate percentage
  IF v_required_count > 0 THEN
    v_percentage := (v_completed_required::FLOAT / v_required_count::FLOAT * 80)::INTEGER;
  ELSE
    v_percentage := 80; -- If no required fields, assume 80% base completion
  END IF;
  -- Add optional fields contribution
  IF v_optional_count > 0 THEN
    v_percentage := v_percentage + (v_completed_optional::FLOAT / v_optional_count::FLOAT * 20)::INTEGER;
  END IF;
  RETURN v_percentage;
END;
$$ LANGUAGE plpgsql;
-- Function to update overall profile completion
CREATE OR REPLACE FUNCTION update_profile_completion(p_user_id UUID)
RETURNS void AS $$
DECLARE
  v_total_weight INTEGER := 0;
  v_weighted_sum INTEGER := 0;
  v_section RECORD;
  v_new_percentage INTEGER;
BEGIN
  -- Sum up section completions with their weights
  FOR v_section IN
    SELECT
      id,
      completion_percentage,
      CASE WHEN is_required THEN 2 ELSE 1 END AS weight
    FROM
      profile_sections
    WHERE
      user_id = p_user_id
  LOOP
    v_weighted_sum := v_weighted_sum + (v_section.completion_percentage * v_section.weight);
    v_total_weight := v_total_weight + v_section.weight;
  END LOOP;
  -- Calculate new overall percentage
  IF v_total_weight > 0 THEN
    v_new_percentage := (v_weighted_sum / v_total_weight);
  ELSE
    v_new_percentage := 0;
  END IF;
  -- Update the profile in BOTH tables to maintain compatibility
  -- Update new system
  UPDATE profiles
  SET
    completion_percentage = v_new_percentage,
    completion_last_updated = NOW()
  WHERE
    id = p_user_id;
  -- Create milestone notification if needed
  PERFORM create_milestone_notification(p_user_id, v_new_percentage);
END;
$$ LANGUAGE plpgsql;
-- Function for milestone notifications
CREATE OR REPLACE FUNCTION create_milestone_notification(
  p_user_id UUID,
  p_percentage INTEGER
) RETURNS void AS $$
DECLARE
  v_last_milestone INTEGER;
  v_milestone INTEGER;
  v_milestones INTEGER[] := ARRAY[25, 50, 75, 100];
  v_title TEXT;
  v_description TEXT;
  v_icon TEXT;
BEGIN
  -- Find the highest milestone achieved
  SELECT MAX(milestone)
  INTO v_last_milestone
  FROM (
    SELECT
      (regexp_matches(title, 'Profile (\d+)% Complete'))[1]::INTEGER AS milestone
    FROM
      profile_notifications
    WHERE
      user_id = p_user_id AND
      type = 'milestone'
  ) AS milestones;
  v_last_milestone := COALESCE(v_last_milestone, 0);
  SELECT milestone
  INTO v_milestone
  FROM (
    SELECT unnest(v_milestones) AS milestone
  ) AS m
  WHERE
    milestone <= p_percentage AND
    milestone > v_last_milestone
  ORDER BY milestone DESC
  LIMIT 1;
  IF v_milestone IS NOT NULL THEN
    CASE v_milestone
      WHEN 25 THEN
        v_title := 'Profile 25% Complete';
        v_description := 'You''ve made a great start on your profile! Keep going to unlock more features.';
        v_icon := 'milestone_25';
      WHEN 50 THEN
        v_title := 'Profile 50% Complete';
        v_description := 'Halfway there! Your profile is starting to look good.';
        v_icon := 'milestone_50';
      WHEN 75 THEN
        v_title := 'Profile 75% Complete';
        v_description := 'Your profile is looking great! Just a few more sections to complete.';
        v_icon := 'milestone_75';
      WHEN 100 THEN
        v_title := 'Profile 100% Complete';
        v_description := 'Congratulations! Your profile is now complete. You''ll get the most out of the platform now.';
        v_icon := 'milestone_100';
    END CASE;
    INSERT INTO profile_notifications (
      user_id,
      type,
      priority,
      title,
      description,
      action_url,
      action_label,
      icon,
      triggered_by
    ) VALUES (
      p_user_id,
      'milestone',
      CASE WHEN v_milestone = 100 THEN 'important' ELSE 'standard' END,
      v_title,
      v_description,
      '/profile',
      'View Profile',
      v_icon,
      'system'
    );
  END IF;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trigger_profile_completion_update()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM update_profile_completion(NEW.user_id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER update_profile_completion_on_section_change
AFTER INSERT OR UPDATE OF completion_percentage ON profile_sections
FOR EACH ROW
EXECUTE FUNCTION trigger_profile_completion_update();
CREATE OR REPLACE FUNCTION initialize_profile_sections(p_user_id UUID)
RETURNS void AS $$
BEGIN
  DECLARE
    v_primary_role TEXT;
  BEGIN
    SELECT primary_role INTO v_primary_role FROM profiles WHERE id = p_user_id;
    INSERT INTO profile_sections (
      user_id,
      section_key,
      title,
      description,
      is_required,
      display_order,
      required_fields,
      optional_fields
    ) VALUES
    (p_user_id, 'basic_info', 'Basic Information', 'Your name and profile photo',
     true, 1,
     '[{"field": "full_name"}, {"field": "avatar_url"}]'::jsonb,
     '[{"field": "headline"}, {"field": "location"}]'::jsonb),
    (p_user_id, 'bio', 'About You', 'Tell others about yourself',
     true, 2,
     '[{"field": "bio"}]'::jsonb,
     '[]'::jsonb),
    (p_user_id, 'skills', 'Skills & Expertise', 'List your professional skills',
     false, 3,
     '[]'::jsonb,
     '[{"field": "skills"}]'::jsonb);
    IF v_primary_role = 'founder' THEN
      INSERT INTO profile_sections (
        user_id,
        section_key,
        title,
        description,
        is_required,
        display_order,
        is_role_specific,
        applicable_roles,
        required_fields,
        optional_fields
      ) VALUES
      (p_user_id, 'founder_info', 'Founder Information', 'Details about your founder journey',
       true, 4,
       true,
       '{founder}',
       '[{"field": "company_stage"}]'::jsonb,
       '[]'::jsonb);
    END IF;
    IF v_primary_role = 'service_provider' THEN
      INSERT INTO profile_sections (
        user_id,
        section_key,
        title,
        description,
        is_required,
        display_order,
        is_role_specific,
        applicable_roles,
        required_fields,
        optional_fields
      ) VALUES
      (p_user_id, 'services_offered', 'Services Offered', 'Professional services you provide',
       true, 4,
       true,
       '{service_provider}',
       '[{"field": "service_categories"}]'::jsonb,
       '[]'::jsonb);
    END IF;
    IF v_primary_role = 'company_member' THEN
      INSERT INTO profile_sections (
        user_id,
        section_key,
        title,
        description,
        is_required,
        display_order,
        is_role_specific,
        applicable_roles,
        required_fields,
        optional_fields
      ) VALUES
      (p_user_id, 'company_role', 'Company Role', 'Your role and responsibilities',
       true, 4,
       true,
       '{company_member}',
       '[{"field": "company_id"}, {"field": "company_role"}]'::jsonb,
       '[]'::jsonb);
    END IF;
  END;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trigger_initialize_profile_sections()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.primary_role IS NOT NULL AND (OLD.primary_role IS NULL OR NEW.primary_role != OLD.primary_role) THEN
    PERFORM initialize_profile_sections(NEW.id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER initialize_sections_for_profile
AFTER INSERT OR UPDATE OF primary_role ON profiles
FOR EACH ROW
EXECUTE FUNCTION trigger_initialize_profile_sections();
ALTER TABLE profile_sections ENABLE ROW LEVEL SECURITY;
CREATE POLICY profile_sections_select ON profile_sections
  FOR SELECT
  USING (auth.uid() = user_id OR
         auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY profile_sections_update ON profile_sections
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
ALTER TABLE user_work_experience ENABLE ROW LEVEL SECURITY;
CREATE POLICY work_experience_select ON user_work_experience
  FOR SELECT
  USING (auth.uid() = user_id OR
         auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY work_experience_insert ON user_work_experience
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY work_experience_update ON user_work_experience
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY work_experience_delete ON user_work_experience
  FOR DELETE
  USING (auth.uid() = user_id);
ALTER TABLE user_education ENABLE ROW LEVEL SECURITY;
CREATE POLICY education_select ON user_education
  FOR SELECT
  USING (auth.uid() = user_id OR
         auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY education_insert ON user_education
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY education_update ON user_education
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY education_delete ON user_education
  FOR DELETE
  USING (auth.uid() = user_id);
ALTER TABLE professional_services ENABLE ROW LEVEL SECURITY;
CREATE POLICY services_select ON professional_services
  FOR SELECT
  USING (true);
CREATE POLICY services_insert ON professional_services
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY services_update ON professional_services
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY services_delete ON professional_services
  FOR DELETE
  USING (auth.uid() = user_id);
ALTER TABLE profile_notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY notifications_select ON profile_notifications
  FOR SELECT
  USING (auth.uid() = user_id OR
         auth.uid() IN (SELECT user_id FROM service_roles WHERE role = 'admin'));
CREATE POLICY notifications_update ON profile_notifications
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY notifications_delete ON profile_notifications
  FOR DELETE
  USING (auth.uid() = user_id);
CREATE OR REPLACE VIEW enhanced_profiles AS
SELECT
  p.*,
  COALESCE(p.completion_percentage, 0) AS profile_completion,
  (
    SELECT COUNT(*)
    FROM profile_notifications
    WHERE user_id = p.id AND is_read = false
  ) AS unread_notifications,
  (
    SELECT json_agg(s)
    FROM profile_sections s
    WHERE s.user_id = p.id
  ) AS profile_sections,
  (
    SELECT json_agg(w)
    FROM user_work_experience w
    WHERE w.user_id = p.id
  ) AS work_experience,
  (
    SELECT json_agg(e)
    FROM user_education e
    WHERE e.user_id = p.id
  ) AS education,
  (
    SELECT json_agg(s)
    FROM professional_services s
    WHERE s.user_id = p.id
  ) AS services
FROM profiles p;
CREATE OR REPLACE VIEW service_provider_directory AS
SELECT
  p.id,
  p.full_name,
  p.avatar_url,
  p.bio,
  p.company_id,
  p.is_public,
  p.primary_role,
  p.completion_percentage,
  array_agg(DISTINCT ps.category) AS service_categories,
  array_agg(DISTINCT ps.title) AS service_titles
FROM
  profiles p
JOIN
  professional_services ps ON ps.user_id = p.id
WHERE
  p.primary_role = 'service_provider'
  AND p.is_public = true
  AND ps.is_active = true
GROUP BY
  p.id;
CREATE OR REPLACE VIEW company_members_directory AS
SELECT
  p.id,
  p.full_name,
  p.avatar_url,
  p.bio,
  p.company_id,
  p.company_role,
  p.primary_role,
  c.name AS company_name
FROM
  profiles p
LEFT JOIN
  companies c ON c.id = p.company_id
WHERE
  p.company_id IS NOT NULL
  AND p.is_public = true;

================
File: supabase/migrations/20250429_add_multi_tenant_terminology_system.sql
================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS partners (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  logo_url TEXT,
  primary_color TEXT,
  secondary_color TEXT,
  status TEXT DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS organizations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  partner_id UUID REFERENCES partners(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS companies (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  organization_id UUID REFERENCES organizations(id) ON DELETE SET NULL,
  status TEXT DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS teams (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS partner_members (
  partner_id UUID REFERENCES partners(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_role TEXT NOT NULL,
  PRIMARY KEY (partner_id, user_id)
);
CREATE TABLE IF NOT EXISTS organization_members (
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_role TEXT NOT NULL,
  PRIMARY KEY (organization_id, user_id)
);
CREATE TABLE IF NOT EXISTS company_members (
  company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_role TEXT NOT NULL,
  PRIMARY KEY (company_id, user_id)
);
CREATE TABLE IF NOT EXISTS team_members (
  team_id UUID REFERENCES teams(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_role TEXT NOT NULL,
  PRIMARY KEY (team_id, user_id)
);
CREATE TABLE IF NOT EXISTS service_roles (
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  admin_role TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS terminology_defaults (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  description TEXT
);
CREATE TABLE IF NOT EXISTS partner_terminology (
  partner_id UUID REFERENCES partners(id) ON DELETE CASCADE,
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (partner_id, key)
);
CREATE TABLE IF NOT EXISTS organization_terminology (
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (organization_id, key)
);
CREATE TABLE IF NOT EXISTS company_terminology (
  company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (company_id, key)
);
CREATE TABLE IF NOT EXISTS team_terminology (
  team_id UUID REFERENCES teams(id) ON DELETE CASCADE,
  key TEXT,
  value JSONB NOT NULL,
  override_behavior TEXT DEFAULT 'replace',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (team_id, key)
);
CREATE TABLE IF NOT EXISTS user_terminology_preferences (
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  key TEXT,
  value JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (user_id, key)
);
CREATE TABLE IF NOT EXISTS white_label_configuration (
  partner_id UUID REFERENCES partners(id) ON DELETE CASCADE PRIMARY KEY,
  terminology_settings JSONB DEFAULT '{}'::JSONB,
  branding_settings JSONB DEFAULT '{}'::JSONB,
  domain_settings JSONB DEFAULT '{}'::JSONB,
  feature_toggles JSONB DEFAULT '{}'::JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS terminology_ab_test (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  end_date TIMESTAMP WITH TIME ZONE,
  variants JSONB NOT NULL,
  status TEXT NOT NULL DEFAULT 'draft',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);
CREATE TABLE IF NOT EXISTS terminology_ab_test_assignments (
  test_id UUID REFERENCES terminology_ab_test(id) ON DELETE CASCADE,
  entity_type TEXT NOT NULL,
  entity_id UUID NOT NULL,
  variant TEXT NOT NULL,
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (test_id, entity_type, entity_id)
);
CREATE TABLE IF NOT EXISTS terminology_feedback (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  entity_type TEXT NOT NULL,
  entity_id UUID NOT NULL,
  terminology_key TEXT NOT NULL,
  feedback_type TEXT NOT NULL,
  details TEXT,
  context JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  user_id UUID REFERENCES auth.users(id)
);
CREATE INDEX IF NOT EXISTS idx_partner_terminology_partner ON partner_terminology(partner_id);
CREATE INDEX IF NOT EXISTS idx_organization_terminology_org ON organization_terminology(organization_id);
CREATE INDEX IF NOT EXISTS idx_company_terminology_company ON company_terminology(company_id);
CREATE INDEX IF NOT EXISTS idx_team_terminology_team ON team_terminology(team_id);
CREATE INDEX IF NOT EXISTS idx_user_terminology_user ON user_terminology_preferences(user_id);
CREATE INDEX IF NOT EXISTS idx_terminology_ab_test_status ON terminology_ab_test(status);
CREATE INDEX IF NOT EXISTS idx_terminology_ab_test_dates ON terminology_ab_test(start_date, end_date);
CREATE INDEX IF NOT EXISTS idx_terminology_ab_test_assignments_entity ON terminology_ab_test_assignments(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_terminology_feedback_entity ON terminology_feedback(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_terminology_feedback_key ON terminology_feedback(terminology_key);
CREATE INDEX IF NOT EXISTS idx_terminology_feedback_type ON terminology_feedback(feedback_type);
CREATE OR REPLACE FUNCTION update_timestamp_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER update_partner_terminology_timestamp
BEFORE UPDATE ON partner_terminology
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE TRIGGER update_organization_terminology_timestamp
BEFORE UPDATE ON organization_terminology
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE TRIGGER update_company_terminology_timestamp
BEFORE UPDATE ON company_terminology
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE TRIGGER update_team_terminology_timestamp
BEFORE UPDATE ON team_terminology
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE TRIGGER update_user_terminology_timestamp
BEFORE UPDATE ON user_terminology_preferences
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE TRIGGER update_white_label_config_timestamp
BEFORE UPDATE ON white_label_configuration
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE TRIGGER update_terminology_ab_test_timestamp
BEFORE UPDATE ON terminology_ab_test
FOR EACH ROW EXECUTE FUNCTION update_timestamp_column();
CREATE OR REPLACE FUNCTION resolve_terminology(
  p_entity_type TEXT,
  p_entity_id UUID,
  p_keys TEXT[] DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result JSONB := '{}'::JSONB;
  system_defaults JSONB;
  partner_terms JSONB := '{}'::JSONB;
  org_terms JSONB := '{}'::JSONB;
  company_terms JSONB := '{}'::JSONB;
  team_terms JSONB := '{}'::JSONB;
  user_terms JSONB := '{}'::JSONB;
  partner_id UUID;
  org_id UUID;
  company_id UUID;
  team_id UUID;
  user_id UUID;
  term_record RECORD;
  key_filter TEXT := '';
BEGIN
  -- Prepare key filter if specific keys requested
  IF p_keys IS NOT NULL THEN
    key_filter := ' AND key = ANY($3)';
  END IF;
  -- Get system defaults
  EXECUTE 'SELECT
    COALESCE(jsonb_object_agg(key, value), ''{}''::JSONB)
    FROM terminology_defaults
    WHERE 1=1' || key_filter
  USING p_entity_type, p_entity_id, p_keys
  INTO system_defaults;
  result := result || system_defaults;
  CASE p_entity_type
    WHEN 'user' THEN
      user_id := p_entity_id;
      EXECUTE 'SELECT team_id FROM team_members WHERE user_id = $1 LIMIT 1'
      USING user_id
      INTO team_id;
      EXECUTE 'SELECT company_id FROM company_members WHERE user_id = $1 LIMIT 1'
      USING user_id
      INTO company_id;
      IF company_id IS NOT NULL THEN
        EXECUTE 'SELECT organization_id FROM companies WHERE id = $1'
        USING company_id
        INTO org_id;
      END IF;
      IF org_id IS NOT NULL THEN
        EXECUTE 'SELECT partner_id FROM organizations WHERE id = $1'
        USING org_id
        INTO partner_id;
      END IF;
    WHEN 'team' THEN
      team_id := p_entity_id;
      EXECUTE 'SELECT company_id FROM teams WHERE id = $1'
      USING team_id
      INTO company_id;
      IF company_id IS NOT NULL THEN
        EXECUTE 'SELECT organization_id FROM companies WHERE id = $1'
        USING company_id
        INTO org_id;
      END IF;
      IF org_id IS NOT NULL THEN
        EXECUTE 'SELECT partner_id FROM organizations WHERE id = $1'
        USING org_id
        INTO partner_id;
      END IF;
    WHEN 'company' THEN
      company_id := p_entity_id;
      EXECUTE 'SELECT organization_id FROM companies WHERE id = $1'
      USING company_id
      INTO org_id;
      IF org_id IS NOT NULL THEN
        EXECUTE 'SELECT partner_id FROM organizations WHERE id = $1'
        USING org_id
        INTO partner_id;
      END IF;
    WHEN 'organization' THEN
      org_id := p_entity_id;
      EXECUTE 'SELECT partner_id FROM organizations WHERE id = $1'
      USING org_id
      INTO partner_id;
    WHEN 'partner' THEN
      partner_id := p_entity_id;
  END CASE;
  IF partner_id IS NOT NULL THEN
    FOR term_record IN EXECUTE 'SELECT key, value, override_behavior FROM partner_terminology WHERE partner_id = $1' || key_filter
    USING partner_id, p_entity_type, p_keys
    LOOP
      IF term_record.override_behavior = 'merge' AND jsonb_typeof(result->term_record.key) = 'object' THEN
        result := jsonb_set(result, ARRAY[term_record.key], result->term_record.key || term_record.value);
      ELSE
        result := jsonb_set(result, ARRAY[term_record.key], term_record.value);
      END IF;
    END LOOP;
  END IF;
  IF org_id IS NOT NULL THEN
    FOR term_record IN EXECUTE 'SELECT key, value, override_behavior FROM organization_terminology WHERE organization_id = $1' || key_filter
    USING org_id, p_entity_type, p_keys
    LOOP
      IF term_record.override_behavior = 'merge' AND jsonb_typeof(result->term_record.key) = 'object' THEN
        result := jsonb_set(result, ARRAY[term_record.key], result->term_record.key || term_record.value);
      ELSE
        result := jsonb_set(result, ARRAY[term_record.key], term_record.value);
      END IF;
    END LOOP;
  END IF;
  IF company_id IS NOT NULL THEN
    FOR term_record IN EXECUTE 'SELECT key, value, override_behavior FROM company_terminology WHERE company_id = $1' || key_filter
    USING company_id, p_entity_type, p_keys
    LOOP
      IF term_record.override_behavior = 'merge' AND jsonb_typeof(result->term_record.key) = 'object' THEN
        result := jsonb_set(result, ARRAY[term_record.key], result->term_record.key || term_record.value);
      ELSE
        result := jsonb_set(result, ARRAY[term_record.key], term_record.value);
      END IF;
    END LOOP;
  END IF;
  IF team_id IS NOT NULL THEN
    FOR term_record IN EXECUTE 'SELECT key, value, override_behavior FROM team_terminology WHERE team_id = $1' || key_filter
    USING team_id, p_entity_type, p_keys
    LOOP
      IF term_record.override_behavior = 'merge' AND jsonb_typeof(result->term_record.key) = 'object' THEN
        result := jsonb_set(result, ARRAY[term_record.key], result->term_record.key || term_record.value);
      ELSE
        result := jsonb_set(result, ARRAY[term_record.key], term_record.value);
      END IF;
    END LOOP;
  END IF;
  IF user_id IS NOT NULL THEN
    EXECUTE 'SELECT
      COALESCE(jsonb_object_agg(key, value), ''{}''::JSONB)
      FROM user_terminology_preferences
      WHERE user_id = $1' || key_filter
    USING user_id, p_entity_type, p_keys
    INTO user_terms;
    result := result || user_terms;
  END IF;
  RETURN result;
END;
$$;
CREATE OR REPLACE FUNCTION has_custom_terminology(
  p_entity_type TEXT,
  p_entity_id UUID
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  term_count INTEGER;
  table_name TEXT;
  id_column TEXT;
BEGIN
  CASE p_entity_type
    WHEN 'partner' THEN
      table_name := 'partner_terminology';
      id_column := 'partner_id';
    WHEN 'organization' THEN
      table_name := 'organization_terminology';
      id_column := 'organization_id';
    WHEN 'company' THEN
      table_name := 'company_terminology';
      id_column := 'company_id';
    WHEN 'team' THEN
      table_name := 'team_terminology';
      id_column := 'team_id';
    WHEN 'user' THEN
      table_name := 'user_terminology_preferences';
      id_column := 'user_id';
    ELSE
      RETURN FALSE;
  END CASE;
  EXECUTE format('SELECT COUNT(*) FROM %I WHERE %I = $1', table_name, id_column)
  USING p_entity_id
  INTO term_count;
  RETURN term_count > 0;
END;
$$;
COMMENT ON TABLE terminology_defaults IS 'System-wide default terminology';
COMMENT ON TABLE partner_terminology IS 'Partner-level terminology customizations for white labeling';
COMMENT ON TABLE organization_terminology IS 'Organization-level terminology (for parent orgs like VCs/Studios)';
COMMENT ON TABLE company_terminology IS 'Company-specific terminology customizations';
COMMENT ON TABLE team_terminology IS 'Team-specific terminology customizations';
COMMENT ON TABLE user_terminology_preferences IS 'Individual user terminology preferences';
COMMENT ON TABLE white_label_configuration IS 'Configuration for white label partners';
COMMENT ON TABLE terminology_ab_test IS 'A/B tests for terminology optimization';
COMMENT ON TABLE terminology_ab_test_assignments IS 'Entity assignments for terminology A/B tests';
COMMENT ON TABLE terminology_feedback IS 'User feedback on terminology effectiveness';
COMMENT ON FUNCTION resolve_terminology IS 'Resolves terminology for a specific entity with proper inheritance';
COMMENT ON FUNCTION has_custom_terminology IS 'Checks if an entity has custom terminology defined';

================
File: supabase/migrations/20250430_create_test_hierarchy.sql
================
DO $$
DECLARE
  v_partner_id UUID := 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::UUID;
  v_org_id UUID := 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'::UUID;
  v_company_id UUID := 'cccccccc-cccc-cccc-cccc-cccccccccccc'::UUID;
  v_team_id UUID := 'dddddddd-dddd-dddd-dddd-dddddddddddd'::UUID;
  v_user_id UUID := 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'::UUID;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM partners WHERE id = v_partner_id) THEN
    INSERT INTO partners (
      id, name, slug, status, primary_color, secondary_color
    ) VALUES (
      v_partner_id,
      'Partner Level',
      'test-partner-a',
      'active',
      '#4F46E5',
      '#10B981'
    );
  END IF;
  IF NOT EXISTS (SELECT 1 FROM organizations WHERE id = v_org_id) THEN
    INSERT INTO organizations (
      id, name, partner_id, status
    ) VALUES (
      v_org_id,
      'Organization Level',
      v_partner_id,
      'active'
    );
  END IF;
  IF NOT EXISTS (SELECT 1 FROM companies WHERE id = v_company_id) THEN
    INSERT INTO companies (
      id, name, organization_id, status
    ) VALUES (
      v_company_id,
      'Company Level',
      v_org_id,
      'active'
    );
  END IF;
  IF NOT EXISTS (SELECT 1 FROM teams WHERE id = v_team_id) THEN
    INSERT INTO teams (
      id, name, company_id, status
    ) VALUES (
      v_team_id,
      'Team Level',
      v_company_id,
      'active'
    );
  END IF;
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM users WHERE id = v_user_id) THEN
      INSERT INTO users (
        id, name, email, status
      ) VALUES (
        v_user_id,
        'User Level',
        'test.user@example.com',
        'active'
      );
    END IF;
  EXCEPTION
    WHEN undefined_table THEN
      RAISE NOTICE 'Users table not found, skipping user creation';
  END;
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM company_members WHERE user_id = v_user_id AND company_id = v_company_id) THEN
      INSERT INTO company_members (
        user_id, company_id, role, status
      ) VALUES (
        v_user_id,
        v_company_id,
        'member',
        'active'
      );
    END IF;
  EXCEPTION
    WHEN undefined_table THEN
      RAISE NOTICE 'company_members table not found, skipping relationship';
  END;
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM team_members WHERE user_id = v_user_id AND team_id = v_team_id) THEN
      INSERT INTO team_members (
        user_id, team_id, role, status
      ) VALUES (
        v_user_id,
        v_team_id,
        'member',
        'active'
      );
    END IF;
  EXCEPTION
    WHEN undefined_table THEN
      RAISE NOTICE 'team_members table not found, skipping relationship';
  END;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'partner_terminology') THEN
    DELETE FROM partner_terminology WHERE partner_id = v_partner_id;
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'organization_terminology') THEN
    DELETE FROM organization_terminology WHERE organization_id = v_org_id;
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'company_terminology') THEN
    DELETE FROM company_terminology WHERE company_id = v_company_id;
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'team_terminology') THEN
    DELETE FROM team_terminology WHERE team_id = v_team_id;
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_terminology_preferences') THEN
    DELETE FROM user_terminology_preferences WHERE user_id = v_user_id;
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'partner_terminology') THEN
    INSERT INTO partner_terminology (key, value, override_behavior, partner_id) VALUES
      ('journeyTerms.mainUnit.singular', '"roadmap"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.mainUnit.plural', '"roadmaps"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.application.name', '"Partner App"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.application.tagline', '"Partner-branded solution"'::jsonb, 'replace', v_partner_id);
  ELSE
    RAISE NOTICE 'partner_terminology table does not exist yet, skipping insertions';
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'organization_terminology') THEN
    INSERT INTO organization_terminology (key, value, override_behavior, organization_id) VALUES
      ('journeyTerms.phaseUnit.singular', '"segment"'::jsonb, 'replace', v_org_id),
      ('journeyTerms.phaseUnit.plural', '"segments"'::jsonb, 'replace', v_org_id);
  ELSE
    RAISE NOTICE 'organization_terminology table does not exist yet, skipping insertions';
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'company_terminology') THEN
    INSERT INTO company_terminology (key, value, override_behavior, company_id) VALUES
      ('journeyTerms.stepUnit.singular', '"activity"'::jsonb, 'replace', v_company_id),
      ('journeyTerms.stepUnit.plural', '"activities"'::jsonb, 'replace', v_company_id),
      ('journeyTerms.progressTerms.completed', '"accomplished"'::jsonb, 'replace', v_company_id);
  ELSE
    RAISE NOTICE 'company_terminology table does not exist yet, skipping insertions';
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'team_terminology') THEN
    INSERT INTO team_terminology (key, value, override_behavior, team_id) VALUES
      ('toolTerms.mainUnit.singular', '"utility"'::jsonb, 'replace', v_team_id),
      ('toolTerms.mainUnit.plural', '"utilities"'::jsonb, 'replace', v_team_id);
  ELSE
    RAISE NOTICE 'team_terminology table does not exist yet, skipping insertions';
  END IF;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_terminology_preferences') THEN
    INSERT INTO user_terminology_preferences (key, value, user_id) VALUES
      ('systemTerms.actions.save', '"Keep"'::jsonb, v_user_id),
      ('systemTerms.actions.cancel', '"Nevermind"'::jsonb, v_user_id);
  ELSE
    RAISE NOTICE 'user_terminology_preferences table does not exist yet, skipping insertions';
  END IF;
  RAISE NOTICE 'Test hierarchy created with terminology at each level:';
  RAISE NOTICE '- Partner: %', v_partner_id;
  RAISE NOTICE '- Organization: %', v_org_id;
  RAISE NOTICE '- Company: %', v_company_id;
  RAISE NOTICE '- Team: %', v_team_id;
  RAISE NOTICE '- User: %', v_user_id;
END;
$$;

================
File: supabase/migrations/20250430_seed_terminology_defaults.sql
================
DO $$
BEGIN
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'terminology_defaults') THEN
    DELETE FROM terminology_defaults;
    INSERT INTO terminology_defaults (key, value, description) VALUES
  ('journeyTerms.mainUnit.singular', '"journey"'::jsonb, 'Default journey singular name'),
  ('journeyTerms.mainUnit.plural', '"journeys"'::jsonb, 'Default journey plural name'),
  ('journeyTerms.mainUnit.verb', '"complete"'::jsonb, 'Default verb for journey actions'),
  ('journeyTerms.mainUnit.possessive', '"journey''s"'::jsonb, 'Default possessive form for journey'),
  ('journeyTerms.mainUnit.articleIndefinite', '"a"'::jsonb, 'Default indefinite article for journey'),
  ('journeyTerms.mainUnit.articleDefinite', '"the"'::jsonb, 'Default definite article for journey'),
  ('journeyTerms.phaseUnit.singular', '"phase"'::jsonb, 'Default phase singular name'),
  ('journeyTerms.phaseUnit.plural', '"phases"'::jsonb, 'Default phase plural name'),
  ('journeyTerms.phaseUnit.possessive', '"phase''s"'::jsonb, 'Default possessive form for phase'),
  ('journeyTerms.phaseUnit.articleIndefinite', '"a"'::jsonb, 'Default indefinite article for phase'),
  ('journeyTerms.phaseUnit.articleDefinite', '"the"'::jsonb, 'Default definite article for phase'),
  ('journeyTerms.stepUnit.singular', '"step"'::jsonb, 'Default step singular name'),
  ('journeyTerms.stepUnit.plural', '"steps"'::jsonb, 'Default step plural name'),
  ('journeyTerms.stepUnit.verb', '"complete"'::jsonb, 'Default verb for step actions'),
  ('journeyTerms.stepUnit.possessive', '"step''s"'::jsonb, 'Default possessive form for step'),
  ('journeyTerms.stepUnit.articleIndefinite', '"a"'::jsonb, 'Default indefinite article for step'),
  ('journeyTerms.stepUnit.articleDefinite', '"the"'::jsonb, 'Default definite article for step'),
  ('journeyTerms.progressTerms.notStarted', '"not started"'::jsonb, 'Default label for not started status'),
  ('journeyTerms.progressTerms.inProgress', '"in progress"'::jsonb, 'Default label for in progress status'),
  ('journeyTerms.progressTerms.completed', '"completed"'::jsonb, 'Default label for completed status'),
  ('journeyTerms.progressTerms.skipped', '"skipped"'::jsonb, 'Default label for skipped status'),
  ('journeyTerms.progressTerms.notNeeded', '"not needed"'::jsonb, 'Default label for not needed status');
INSERT INTO terminology_defaults (key, value, description) VALUES
  ('toolTerms.mainUnit.singular', '"tool"'::jsonb, 'Default tool singular name'),
  ('toolTerms.mainUnit.plural', '"tools"'::jsonb, 'Default tool plural name'),
  ('toolTerms.mainUnit.verb', '"use"'::jsonb, 'Default verb for tool actions'),
  ('toolTerms.mainUnit.possessive', '"tool''s"'::jsonb, 'Default possessive form for tool'),
  ('toolTerms.mainUnit.articleIndefinite', '"a"'::jsonb, 'Default indefinite article for tool'),
  ('toolTerms.mainUnit.articleDefinite', '"the"'::jsonb, 'Default definite article for tool'),
  ('toolTerms.evaluationTerms.singular', '"evaluation"'::jsonb, 'Default evaluation singular name'),
  ('toolTerms.evaluationTerms.plural', '"evaluations"'::jsonb, 'Default evaluation plural name'),
  ('toolTerms.evaluationTerms.verb', '"evaluate"'::jsonb, 'Default verb for evaluation actions'),
  ('toolTerms.evaluationTerms.possessive', '"evaluation''s"'::jsonb, 'Default possessive form for evaluation'),
  ('toolTerms.evaluationTerms.articleIndefinite', '"an"'::jsonb, 'Default indefinite article for evaluation'),
  ('toolTerms.evaluationTerms.articleDefinite', '"the"'::jsonb, 'Default definite article for evaluation');
INSERT INTO terminology_defaults (key, value, description) VALUES
  ('systemTerms.application.name', '"The Wheel"'::jsonb, 'Application name'),
  ('systemTerms.application.shortName', '"Wheel"'::jsonb, 'Short application name'),
  ('systemTerms.application.tagline', '"Guiding your startup journey"'::jsonb, 'Application tagline'),
  ('systemTerms.actions.save', '"Save"'::jsonb, 'Save action label'),
  ('systemTerms.actions.cancel', '"Cancel"'::jsonb, 'Cancel action label'),
  ('systemTerms.actions.edit', '"Edit"'::jsonb, 'Edit action label'),
  ('systemTerms.actions.delete', '"Delete"'::jsonb, 'Delete action label'),
  ('systemTerms.actions.add', '"Add"'::jsonb, 'Add action label'),
  ('systemTerms.actions.submit', '"Submit"'::jsonb, 'Submit action label'),
  ('systemTerms.actions.back', '"Back"'::jsonb, 'Back action label'),
  ('systemTerms.actions.next', '"Next"'::jsonb, 'Next action label'),
  ('systemTerms.actions.finish', '"Finish"'::jsonb, 'Finish action label');
  ELSE
    RAISE NOTICE 'terminology_defaults table does not exist yet, skipping insertions';
  END IF;
END;
$$;

================
File: supabase/migrations/20250430_seed_terminology_templates.sql
================
DO $$
DECLARE
  v_partner_id UUID := '11111111-1111-1111-1111-111111111111'::UUID;
  partner_exists boolean;
BEGIN
  SELECT EXISTS(SELECT 1 FROM partners WHERE id = v_partner_id) INTO partner_exists;
  IF NOT partner_exists THEN
    INSERT INTO partners (
      id, name, slug, primary_color, secondary_color, status
    ) VALUES (
      v_partner_id,
      'Terminology Templates Demo',
      'terminology-templates',
      '#4F46E5',
      '#10B981',
      'active'
    );
  END IF;
  RAISE NOTICE 'Using partner_id: %', v_partner_id;
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'partner_terminology') THEN
    DELETE FROM partner_terminology WHERE partner_id = v_partner_id;
    INSERT INTO partner_terminology (key, value, override_behavior, partner_id) VALUES
      ('journeyTerms.mainUnit.singular', '"objective"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.mainUnit.plural', '"objectives"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.mainUnit.verb', '"achieve"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.mainUnit.possessive', '"objective''s"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.mainUnit.articleIndefinite', '"an"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.mainUnit.articleDefinite', '"the"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.phaseUnit.singular', '"milestone"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.phaseUnit.plural', '"milestones"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.phaseUnit.possessive', '"milestone''s"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.phaseUnit.articleIndefinite', '"a"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.phaseUnit.articleDefinite', '"the"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.stepUnit.singular', '"action item"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.stepUnit.plural', '"action items"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.stepUnit.verb', '"complete"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.stepUnit.possessive', '"action item''s"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.stepUnit.articleIndefinite', '"an"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.stepUnit.articleDefinite', '"the"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.progressTerms.notStarted', '"not commenced"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.progressTerms.inProgress', '"in progress"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.progressTerms.completed', '"achieved"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.progressTerms.skipped', '"bypassed"'::jsonb, 'replace', v_partner_id),
      ('journeyTerms.progressTerms.notNeeded', '"not applicable"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.mainUnit.singular', '"instrument"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.mainUnit.plural', '"instruments"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.mainUnit.verb', '"utilize"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.mainUnit.possessive', '"instrument''s"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.mainUnit.articleIndefinite', '"an"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.mainUnit.articleDefinite', '"the"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.evaluationTerms.singular', '"assessment"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.evaluationTerms.plural', '"assessments"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.evaluationTerms.verb', '"assess"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.evaluationTerms.possessive', '"assessment''s"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.evaluationTerms.articleIndefinite', '"an"'::jsonb, 'replace', v_partner_id),
      ('toolTerms.evaluationTerms.articleDefinite', '"the"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.save', '"Save"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.cancel', '"Cancel"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.edit', '"Edit"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.delete', '"Remove"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.add', '"Add"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.submit', '"Submit"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.back', '"Previous"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.next', '"Next"'::jsonb, 'replace', v_partner_id),
      ('systemTerms.actions.finish', '"Complete"'::jsonb, 'replace', v_partner_id);
  ELSE
    RAISE NOTICE 'partner_terminology table does not exist yet, skipping terminology insertions';
  END IF;
  IF EXISTS (
    SELECT FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_name = 'white_label_configuration'
  ) THEN
    INSERT INTO white_label_configuration (
      partner_id, terminology_settings, branding_settings
    )
    VALUES (
      v_partner_id,
      jsonb_build_object(
        'availableTemplates', jsonb_build_array(
          jsonb_build_object(
            'id', 'businessFormal',
            'displayName', 'Business Formal',
            'description', 'Formal, enterprise-oriented terminology suitable for corporate environments'
          ),
          jsonb_build_object(
            'id', 'startupFocused',
            'displayName', 'Startup Focused',
            'description', 'Casual, growth-oriented terminology for startup environments'
          ),
          jsonb_build_object(
            'id', 'projectManagement',
            'displayName', 'Project Management',
            'description', 'Delivery and milestone-focused terminology for project management'
          ),
          jsonb_build_object(
            'id', 'casual',
            'displayName', 'Casual',
            'description', 'Simplified, user-friendly terminology for general use'
          )
        ),
        'defaultTemplate', 'businessFormal'
      ),
      jsonb_build_object(
        'showTemplateSelector', true
      )
    )
    ON CONFLICT (partner_id)
    DO UPDATE SET
      terminology_settings = EXCLUDED.terminology_settings,
      branding_settings = EXCLUDED.branding_settings;
  ELSE
    RAISE NOTICE 'white_label_configuration table does not exist yet, skipping template configuration';
  END IF;
END;
$$;

================
File: supabase/migrations/20250501000000_create_step_enhanced_views.sql
================
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='difficulty_level'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN difficulty_level INTEGER DEFAULT 3;
    END IF;
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='estimated_time_min'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN estimated_time_min INTEGER DEFAULT 30;
    END IF;
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='estimated_time_max'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN estimated_time_max INTEGER DEFAULT 60;
    END IF;
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='key_outcomes'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN key_outcomes JSONB DEFAULT '[]'::jsonb;
    END IF;
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='prerequisite_steps'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN prerequisite_steps JSONB DEFAULT '[]'::jsonb;
    END IF;
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='company_id'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN company_id UUID DEFAULT NULL;
    END IF;
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='is_custom'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN is_custom BOOLEAN DEFAULT FALSE;
    END IF;
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name='journey_steps' AND column_name='order_index'
    ) THEN
        ALTER TABLE journey_steps ADD COLUMN order_index INTEGER DEFAULT 0;
    END IF;
END
$$;
CREATE OR REPLACE VIEW journey_steps_enhanced AS
SELECT
  s.id,
  s.name,
  s.description,
  s.phase_id,
  COALESCE(s.difficulty_level, 3) as difficulty_level,
  COALESCE(s.estimated_time_min, 30) as estimated_time_min,
  COALESCE(s.estimated_time_max, 60) as estimated_time_max,
  s.key_outcomes,
  s.prerequisite_steps,
  s.order_index,
  s.created_at,
  s.updated_at,
  s.company_id,
  s.is_custom,
  p.name as phase_name,
  p.color as phase_color
FROM journey_steps s
LEFT JOIN journey_phases p ON s.phase_id = p.id;
CREATE OR REPLACE VIEW company_step_progress AS
SELECT
  p.id,
  p.company_id,
  p.step_id,
  p.status,
  p.notes,
  p.completed_at,
  p.created_at,
  p.updated_at,
  s.name as step_name,
  s.phase_id,
  ph.name as phase_name
FROM company_progress p
LEFT JOIN journey_steps s ON p.step_id = s.id
LEFT JOIN journey_phases ph ON s.phase_id = ph.id;
CREATE OR REPLACE FUNCTION get_enhanced_step(step_id UUID)
RETURNS JSON AS $$
BEGIN
  RETURN (
    SELECT json_build_object(
      'id', s.id,
      'name', s.name,
      'description', s.description,
      'phase_id', s.phase_id,
      'phase_name', p.name,
      'difficulty_level', COALESCE(s.difficulty_level, 3),
      'estimated_time_min', COALESCE(s.estimated_time_min, 30),
      'estimated_time_max', COALESCE(s.estimated_time_max, 60),
      'key_outcomes', s.key_outcomes,
      'tools', (
        SELECT json_agg(t.*)
        FROM journey_step_tools jst
        JOIN tools t ON jst.tool_id = t.id
        WHERE jst.step_id = s.id
      ),
      'status', (
        SELECT cp.status
        FROM company_progress cp
        WHERE cp.step_id = s.id
        LIMIT 1
      )
    )
    FROM journey_steps s
    LEFT JOIN journey_phases p ON s.phase_id = p.id
    WHERE s.id = get_enhanced_step.step_id
  );
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_personalized_step_tools(company_id UUID, step_id UUID)
RETURNS TABLE(
  id UUID,
  name TEXT,
  description TEXT,
  url TEXT,
  logo_url TEXT,
  relevance_score FLOAT
) AS $$
BEGIN
  RETURN QUERY
  WITH company_industry AS (
    SELECT industry_id FROM companies WHERE id = company_id LIMIT 1
  ),
  step_info AS (
    SELECT
      s.id,
      s.name,
      s.description,
      s.phase_id
    FROM journey_steps s
    WHERE s.id = step_id
  ),
  ranked_tools AS (
    SELECT
      t.id,
      t.name,
      t.description,
      t.url,
      t.logo_url,
      (CASE WHEN jst.step_id IS NOT NULL THEN 3.0 ELSE 0.0 END) +
      (CASE WHEN t.industry_focus = (SELECT industry_id FROM company_industry) THEN 2.0 ELSE 0.0 END) +
      (CASE WHEN EXISTS (
          SELECT 1 FROM journey_step_tools jst2
          JOIN journey_steps s2 ON jst2.step_id = s2.id
          WHERE jst2.tool_id = t.id AND s2.phase_id = (SELECT phase_id FROM step_info)
        ) THEN 1.5 ELSE 0.0 END) +
      (random() * 0.5) AS relevance_score
    FROM tools t
    LEFT JOIN journey_step_tools jst ON t.id = jst.tool_id AND jst.step_id = step_id
  )
  SELECT
    id,
    name,
    description,
    url,
    logo_url,
    relevance_score
  FROM ranked_tools
  ORDER BY relevance_score DESC
  LIMIT 10;
END;
$$ LANGUAGE plpgsql;
COMMENT ON VIEW journey_steps_enhanced IS
  'Enhanced view of journey steps with additional fields for improved UI';
COMMENT ON VIEW company_step_progress IS
  'Company progress on journey steps with step and phase information';
COMMENT ON FUNCTION get_enhanced_step IS
  'Get enhanced step data with associated tools';
COMMENT ON FUNCTION get_personalized_step_tools IS
  'Get personalized tool recommendations for a specific step';

================
File: supabase/migrations/20250501000000_transform_journey_steps_to_challenges.sql
================
CREATE TABLE IF NOT EXISTS journey_phases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
DROP TRIGGER IF EXISTS update_journey_phases_timestamp ON journey_phases;
CREATE TRIGGER update_journey_phases_timestamp
BEFORE UPDATE ON journey_phases
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
CREATE TABLE IF NOT EXISTS journey_challenges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  phase_id UUID REFERENCES journey_phases(id) ON DELETE CASCADE,
  difficulty_level INTEGER NOT NULL CHECK (difficulty_level BETWEEN 1 AND 5),
  estimated_time_min INTEGER NOT NULL,
  estimated_time_max INTEGER NOT NULL,
  key_outcomes TEXT[] NOT NULL DEFAULT '{}',
  prerequisite_challenges UUID[] DEFAULT '{}',
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
DROP TRIGGER IF EXISTS update_journey_challenges_timestamp ON journey_challenges;
CREATE TRIGGER update_journey_challenges_timestamp
BEFORE UPDATE ON journey_challenges
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
CREATE TABLE IF NOT EXISTS companies (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS company_challenge_progress (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
  challenge_id UUID REFERENCES journey_challenges(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('not_started', 'in_progress', 'completed', 'skipped')),
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(company_id, challenge_id)
);
DROP TRIGGER IF EXISTS update_company_challenge_progress_timestamp ON company_challenge_progress;
CREATE TRIGGER update_company_challenge_progress_timestamp
BEFORE UPDATE ON company_challenge_progress
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
CREATE TABLE IF NOT EXISTS tools (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  url TEXT,
  category TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS challenge_tool_recommendations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenge_id UUID REFERENCES journey_challenges(id) ON DELETE CASCADE,
  tool_id UUID REFERENCES tools(id) ON DELETE CASCADE,
  relevance_score FLOAT,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(challenge_id, tool_id)
);
DROP TRIGGER IF EXISTS update_challenge_tool_recommendations_timestamp ON challenge_tool_recommendations;
CREATE TRIGGER update_challenge_tool_recommendations_timestamp
BEFORE UPDATE ON challenge_tool_recommendations
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
CREATE INDEX IF NOT EXISTS idx_journey_challenges_phase_id ON journey_challenges(phase_id);
CREATE INDEX IF NOT EXISTS idx_company_challenge_progress_company_id ON company_challenge_progress(company_id);
CREATE INDEX IF NOT EXISTS idx_company_challenge_progress_challenge_id ON company_challenge_progress(challenge_id);
CREATE INDEX IF NOT EXISTS idx_challenge_tool_recommendations_challenge_id ON challenge_tool_recommendations(challenge_id);
CREATE INDEX IF NOT EXISTS idx_challenge_tool_recommendations_tool_id ON challenge_tool_recommendations(tool_id);

================
File: supabase/migrations/20250502000000_add_recommendation_functions.sql
================
/*
 * IMPORTANT: This migration creates the tables, views, and functions in the correct order
 * to avoid dependency issues. The steps are:
 * 1. Create tool_recommendations table first
 * 2. Create initial views without dependencies on the table
 * 3. Create functions that depend on the views
 * 4. Update views with full functionality
 */
DROP TABLE IF EXISTS tool_recommendations CASCADE;
CREATE TABLE tool_recommendations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  relevance_score NUMERIC(5,2) NOT NULL DEFAULT 5.0,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  UNIQUE(step_id, tool_id)
);
COMMENT ON TABLE tool_recommendations IS 'Stores tool recommendations for journey steps with relevance scores';
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_step_id ON tool_recommendations(step_id);
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_tool_id ON tool_recommendations(tool_id);
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_relevance ON tool_recommendations(relevance_score DESC);
ALTER TABLE tool_recommendations ENABLE ROW LEVEL SECURITY;
CREATE POLICY IF NOT EXISTS tool_recommendations_select_policy ON tool_recommendations
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM journey_steps js
    JOIN company_members cm ON js.company_id = cm.company_id
    WHERE js.id = tool_recommendations.step_id
    AND cm.user_id = auth.uid()
  )
);
CREATE POLICY IF NOT EXISTS tool_recommendations_all_policy ON tool_recommendations
FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE id = auth.uid() AND role = 'admin'
  )
);
CREATE OR REPLACE FUNCTION get_steps_by_industry_popularity(
  p_industry_id UUID
)
RETURNS TABLE (
  step_id UUID,
  step_name TEXT,
  completion_count INTEGER,
  percentile NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH industry_companies AS (
    SELECT id FROM companies WHERE industry_id = p_industry_id
  ),
  step_completions AS (
    SELECT
      step_id,
      COUNT(*) as completion_count
    FROM company_progress
    WHERE
      company_id IN (SELECT id FROM industry_companies)
      AND status = 'completed'
    GROUP BY step_id
  ),
  step_ranks AS (
    SELECT
      step_id,
      completion_count,
      PERCENT_RANK() OVER (ORDER BY completion_count) * 100 as percentile
    FROM step_completions
  )
  SELECT
    sr.step_id,
    s.name as step_name,
    sr.completion_count,
    sr.percentile
  FROM step_ranks sr
  JOIN journey_steps s ON sr.step_id = s.id
  ORDER BY sr.percentile DESC;
END;
$$;
COMMENT ON FUNCTION get_steps_by_industry_popularity IS
  'Get journey steps ranked by popularity within a specific industry';
CREATE OR REPLACE FUNCTION get_common_step_sequences(
  p_completed_steps UUID[]
)
RETURNS TABLE (
  next_step_id UUID,
  next_step_name TEXT,
  frequency INTEGER,
  avg_time_to_completion INTERVAL
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH target_companies AS (
    SELECT DISTINCT cp.company_id
    FROM company_progress cp
    WHERE
      cp.step_id = ANY(p_completed_steps)
      AND cp.status = 'completed'
  ),
  next_steps AS (
    SELECT
      cp.step_id,
      cp.company_id,
      cp.completed_at,
      cp.created_at,
      ROW_NUMBER() OVER (
        PARTITION BY cp.company_id
        ORDER BY cp.completed_at
      ) as step_order
    FROM company_progress cp
    JOIN target_companies tc ON cp.company_id = tc.company_id
    WHERE
      cp.status = 'completed'
      AND NOT (cp.step_id = ANY(p_completed_steps))
  ),
  next_step_frequencies AS (
    SELECT
      ns.step_id,
      COUNT(DISTINCT ns.company_id) as frequency,
      AVG(ns.completed_at - ns.created_at) as avg_time_to_completion
    FROM next_steps ns
    WHERE ns.step_order = 1
    GROUP BY ns.step_id
  )
  SELECT
    nsf.step_id as next_step_id,
    js.name as next_step_name,
    nsf.frequency,
    nsf.avg_time_to_completion
  FROM next_step_frequencies nsf
  JOIN journey_steps js ON nsf.step_id = js.id
  ORDER BY nsf.frequency DESC;
END;
$$;
COMMENT ON FUNCTION get_common_step_sequences IS
  'Get steps commonly completed after a given set of steps, ranked by frequency';
CREATE OR REPLACE VIEW journey_step_relationships AS
WITH prerequisite_relationships AS (
  SELECT
    js.id as step_id,
    js.name as step_name,
    pre.prerequisite_id,
    'prerequisite' as relationship_type
  FROM journey_steps js
  CROSS JOIN LATERAL (
    SELECT jsonb_array_elements_text(js.prerequisite_steps::jsonb)::uuid as prerequisite_id
  ) pre
  WHERE js.prerequisite_steps IS NOT NULL AND js.prerequisite_steps != '{}'::jsonb
),
dependent_steps AS (
  SELECT
    pr.prerequisite_id as step_id,
    js.id as dependent_id,
    js.name as dependent_name,
    'dependent' as relationship_type
  FROM prerequisite_relationships pr
  JOIN journey_steps js ON js.id = pr.step_id
)
SELECT
  r.step_id,
  s1.name as step_name,
  r.prerequisite_id as related_id,
  s2.name as related_name,
  r.relationship_type
FROM prerequisite_relationships r
JOIN journey_steps s1 ON r.step_id = s1.id
JOIN journey_steps s2 ON r.prerequisite_id = s2.id
UNION ALL
SELECT
  d.step_id,
  s1.name as step_name,
  d.dependent_id as related_id,
  d.dependent_name as related_name,
  d.relationship_type
FROM dependent_steps d
JOIN journey_steps s1 ON d.step_id = s1.id;
COMMENT ON VIEW journey_step_relationships IS
  'View showing prerequisite and dependent relationships between journey steps';
DROP VIEW IF EXISTS journey_step_recommendations CASCADE;
CREATE VIEW journey_step_recommendations AS
SELECT
  js.id,
  js.name,
  js.description,
  js.phase_id,
  jp.name as phase_name,
  js.difficulty_level,
  js.estimated_time_min,
  js.estimated_time_max,
  js.key_outcomes,
  js.prerequisite_steps,
  js.order_index,
  NULL::jsonb as recommended_tools,
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', r.related_id,
        'name', r.related_name,
        'relationship_type', r.relationship_type
      )
    )
    FROM journey_step_relationships r
    WHERE r.step_id = js.id
  ) as related_steps
FROM journey_steps js
LEFT JOIN journey_phases jp ON js.phase_id = jp.id;
CREATE OR REPLACE FUNCTION get_recommended_tools_for_step(p_step_id UUID, p_limit INTEGER DEFAULT 5)
RETURNS TABLE (
  tool_id UUID,
  tool_name TEXT,
  tool_description TEXT,
  tool_url TEXT,
  tool_logo_url TEXT,
  relevance_score NUMERIC(5,2),
  category TEXT
)
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT
    t.id AS tool_id,
    t.name AS tool_name,
    t.description AS tool_description,
    t.url AS tool_url,
    NULL AS tool_logo_url,
    tr.relevance_score,
    t.category
  FROM tool_recommendations tr
  JOIN tools t ON tr.tool_id = t.id
  WHERE tr.step_id = p_step_id
  ORDER BY tr.relevance_score DESC
  LIMIT p_limit;
$$;
COMMENT ON FUNCTION get_recommended_tools_for_step IS
  'Get top recommended tools for a specific journey step with relevance scores';
CREATE OR REPLACE FUNCTION get_personalized_step_recommendations(
  p_company_id UUID,
  p_limit INTEGER DEFAULT 5,
  p_exclude_completed BOOLEAN DEFAULT true
)
RETURNS TABLE (
  step_id UUID,
  step_name TEXT,
  step_description TEXT,
  phase_name TEXT,
  estimated_min_minutes INTEGER,
  estimated_max_minutes INTEGER,
  difficulty_level INTEGER,
  relevance_score NUMERIC(5,2),
  reasoning TEXT[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  completed_steps UUID[];
  company_industry_id UUID;
BEGIN
  IF p_exclude_completed THEN
    SELECT array_agg(company_progress.step_id) INTO completed_steps
    FROM company_progress
    WHERE company_id = p_company_id AND status = 'completed';
    IF completed_steps IS NULL THEN
      completed_steps := ARRAY[]::UUID[];
    END IF;
  ELSE
    completed_steps := ARRAY[]::UUID[];
  END IF;
  SELECT industry_id INTO company_industry_id
  FROM companies
  WHERE id = p_company_id;
  RETURN QUERY
  WITH step_scores AS (
    SELECT
      js.id,
      js.name,
      js.description,
      jp.name AS phase_name,
      js.estimated_time_min,
      js.estimated_time_max,
      js.difficulty_level,
      5.0 AS base_score,
      CASE
        WHEN js.prerequisite_steps IS NULL OR js.prerequisite_steps = '{}' THEN 2.0
        WHEN (SELECT COUNT(*) FROM jsonb_array_elements_text(js.prerequisite_steps::jsonb) AS prereq_id
              WHERE prereq_id::UUID NOT IN (SELECT unnest(completed_steps))) = 0 THEN 2.0
        ELSE -5.0
      END AS prereq_score,
      COALESCE((
        SELECT (ip.percentile / 50) * 2
        FROM get_steps_by_industry_popularity(company_industry_id) ip
        WHERE ip.step_id = js.id
        LIMIT 1
      ), 0) AS industry_score,
      COALESCE((
        SELECT (cs.frequency / 10)
        FROM get_common_step_sequences(completed_steps) cs
        WHERE cs.next_step_id = js.id
        LIMIT 1
      ), 0) AS sequence_score,
      ARRAY[
        CASE WHEN js.prerequisite_steps IS NULL OR js.prerequisite_steps = '{}'
             THEN 'No prerequisites required'
             WHEN (SELECT COUNT(*) FROM jsonb_array_elements_text(js.prerequisite_steps::jsonb) AS prereq_id
                  WHERE prereq_id::UUID NOT IN (SELECT unnest(completed_steps))) = 0
             THEN 'All prerequisites are completed'
             ELSE 'Some prerequisites are not yet completed'
        END,
        COALESCE((
          SELECT 'Popular choice in your industry (' || ROUND(ip.percentile) || '% percentile)'
          FROM get_steps_by_industry_popularity(company_industry_id) ip
          WHERE ip.step_id = js.id
          LIMIT 1
        ), 'New option for your industry'),
        COALESCE((
          SELECT cs.frequency || ' companies completed this step next'
          FROM get_common_step_sequences(completed_steps) cs
          WHERE cs.next_step_id = js.id
          LIMIT 1
        ), 'Builds on your current progress')
      ] AS reasoning
    FROM journey_steps js
    LEFT JOIN journey_phases jp ON js.phase_id = jp.id
    WHERE (NOT p_exclude_completed OR js.id <> ALL(completed_steps))
  ),
  scored_steps AS (
    SELECT
      id,
      name,
      description,
      phase_name,
      estimated_time_min,
      estimated_time_max,
      difficulty_level,
      GREATEST(1.0, LEAST(10.0, (
        base_score +
        prereq_score +
        industry_score +
        sequence_score
      ))) AS relevance_score,
      reasoning
    FROM step_scores
  )
  SELECT * FROM scored_steps
  ORDER BY relevance_score DESC, name
  LIMIT p_limit;
END;
$$;
COMMENT ON FUNCTION get_personalized_step_recommendations IS
  'Get personalized step recommendations for a company based on their progress and industry';
CREATE OR REPLACE FUNCTION get_step_relationships(p_step_id UUID, p_depth INTEGER DEFAULT 1)
RETURNS TABLE (
  source_id UUID,
  source_name TEXT,
  target_id UUID,
  target_name TEXT,
  relationship_type TEXT,
  relationship_strength INTEGER
)
LANGUAGE sql
SECURITY DEFINER
AS $$
WITH RECURSIVE relationship_tree AS (
  SELECT
    r.step_id AS source_id,
    s1.name AS source_name,
    r.related_id AS target_id,
    r.related_name AS target_name,
    r.relationship_type,
    1 AS depth,
    CASE
      WHEN r.relationship_type = 'prerequisite' THEN 3
      WHEN r.relationship_type = 'dependent' THEN 2
      ELSE 1
    END AS relationship_strength
  FROM journey_step_relationships r
  JOIN journey_steps s1 ON r.step_id = s1.id
  WHERE r.step_id = p_step_id OR r.related_id = p_step_id
  UNION ALL
  SELECT
    r.step_id AS source_id,
    s1.name AS source_name,
    r.related_id AS target_id,
    r.related_name AS target_name,
    r.relationship_type,
    rt.depth + 1,
    CASE
      WHEN r.relationship_type = 'prerequisite' THEN 3
      WHEN r.relationship_type = 'dependent' THEN 2
      ELSE 1
    END AS relationship_strength
  FROM journey_step_relationships r
  JOIN journey_steps s1 ON r.step_id = s1.id
  JOIN relationship_tree rt ON r.step_id = rt.target_id
  WHERE rt.depth < p_depth
)
SELECT DISTINCT
  source_id,
  source_name,
  target_id,
  target_name,
  relationship_type,
  relationship_strength
FROM relationship_tree
ORDER BY relationship_strength DESC, source_name, target_name;
$$;
COMMENT ON FUNCTION get_step_relationships IS
  'Get relationships between steps for visualization with configurable depth';
DROP VIEW IF EXISTS journey_step_recommendations CASCADE;
CREATE VIEW journey_step_recommendations AS
SELECT
  js.id,
  js.name,
  js.description,
  js.phase_id,
  jp.name as phase_name,
  js.difficulty_level,
  js.estimated_time_min,
  js.estimated_time_max,
  js.key_outcomes,
  js.prerequisite_steps,
  js.order_index,
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', t.id,
        'name', t.name,
        'description', t.description,
        'url', t.url,
        'logo_url', NULL,
        'relevance_score', tr.relevance_score
      )
    )
    FROM tools t
    JOIN tool_recommendations tr ON t.id = tr.tool_id
    WHERE tr.step_id = js.id
  ) as recommended_tools,
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', r.related_id,
        'name', r.related_name,
        'relationship_type', r.relationship_type
      )
    )
    FROM journey_step_relationships r
    WHERE r.step_id = js.id
  ) as related_steps
FROM journey_steps js
LEFT JOIN journey_phases jp ON js.phase_id = jp.id;
COMMENT ON VIEW journey_step_recommendations IS
  'View providing step recommendations with related tools and step relationships';

================
File: supabase/migrations/20250503000000_add_feedback_system_tables.sql
================
CREATE TABLE IF NOT EXISTS feedback (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users NOT NULL,
  company_id UUID REFERENCES companies,
  entity_type VARCHAR(50) NOT NULL,
  entity_id UUID NOT NULL,
  rating INTEGER CHECK (rating BETWEEN 1 AND 5),
  comment TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS feedback_entity_idx ON feedback(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS feedback_user_idx ON feedback(user_id);
CREATE TABLE IF NOT EXISTS improvement_suggestions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users NOT NULL,
  company_id UUID REFERENCES companies,
  entity_type VARCHAR(50) NOT NULL,
  entity_id UUID NOT NULL,
  category VARCHAR(50) NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  impact_description TEXT,
  status VARCHAR(50) DEFAULT 'pending',
  votes INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS improvement_suggestions_entity_idx ON improvement_suggestions(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS improvement_suggestions_user_idx ON improvement_suggestions(user_id);
CREATE INDEX IF NOT EXISTS improvement_suggestions_status_idx ON improvement_suggestions(status);
CREATE TABLE IF NOT EXISTS suggestion_votes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  suggestion_id UUID REFERENCES improvement_suggestions NOT NULL,
  user_id UUID REFERENCES auth.users NOT NULL,
  vote_type VARCHAR(10) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(suggestion_id, user_id)
);
CREATE INDEX IF NOT EXISTS suggestion_votes_suggestion_idx ON suggestion_votes(suggestion_id);
CREATE INDEX IF NOT EXISTS suggestion_votes_user_idx ON suggestion_votes(user_id);
CREATE OR REPLACE FUNCTION update_suggestion_votes()
RETURNS TRIGGER AS $$
DECLARE
  vote_diff INTEGER := 0;
BEGIN
  IF TG_OP = 'INSERT' THEN
    vote_diff := CASE WHEN NEW.vote_type = 'up' THEN 1 ELSE -1 END;
  ELSIF TG_OP = 'UPDATE' THEN
    vote_diff := CASE
      WHEN OLD.vote_type = 'up' AND NEW.vote_type = 'down' THEN -2
      WHEN OLD.vote_type = 'down' AND NEW.vote_type = 'up' THEN 2
      ELSE 0
    END;
  ELSIF TG_OP = 'DELETE' THEN
    vote_diff := CASE WHEN OLD.vote_type = 'up' THEN -1 ELSE 1 END;
  END IF;
  IF TG_OP = 'DELETE' THEN
    UPDATE improvement_suggestions
    SET votes = votes + vote_diff,
        updated_at = NOW()
    WHERE id = OLD.suggestion_id;
  ELSE
    UPDATE improvement_suggestions
    SET votes = votes + vote_diff,
        updated_at = NOW()
    WHERE id = NEW.suggestion_id;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER suggestion_vote_insert
AFTER INSERT ON suggestion_votes
FOR EACH ROW
EXECUTE FUNCTION update_suggestion_votes();
CREATE TRIGGER suggestion_vote_update
AFTER UPDATE ON suggestion_votes
FOR EACH ROW
EXECUTE FUNCTION update_suggestion_votes();
CREATE TRIGGER suggestion_vote_delete
AFTER DELETE ON suggestion_votes
FOR EACH ROW
EXECUTE FUNCTION update_suggestion_votes();
CREATE OR REPLACE FUNCTION vote_on_suggestion(
  p_suggestion_id UUID,
  p_user_id UUID,
  p_vote_type VARCHAR,
  p_previous_vote_type VARCHAR
)
RETURNS VOID AS $$
BEGIN
  BEGIN
    IF p_previous_vote_type IS NOT NULL THEN
      IF p_previous_vote_type = p_vote_type THEN
        DELETE FROM suggestion_votes
        WHERE suggestion_id = p_suggestion_id AND user_id = p_user_id;
      ELSE
        UPDATE suggestion_votes
        SET vote_type = p_vote_type
        WHERE suggestion_id = p_suggestion_id AND user_id = p_user_id;
      END IF;
    ELSE
      INSERT INTO suggestion_votes (suggestion_id, user_id, vote_type)
      VALUES (p_suggestion_id, p_user_id, p_vote_type);
    END IF;
  END;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_feedback_stats(
  p_entity_id UUID,
  p_entity_type VARCHAR
)
RETURNS TABLE (
  entity_id UUID,
  average_rating DECIMAL,
  rating_count INTEGER,
  rating_1_count INTEGER,
  rating_2_count INTEGER,
  rating_3_count INTEGER,
  rating_4_count INTEGER,
  rating_5_count INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    p_entity_id,
    COALESCE(AVG(rating), 0)::DECIMAL AS average_rating,
    COUNT(rating) AS rating_count,
    COUNT(*) FILTER (WHERE rating = 1) AS rating_1_count,
    COUNT(*) FILTER (WHERE rating = 2) AS rating_2_count,
    COUNT(*) FILTER (WHERE rating = 3) AS rating_3_count,
    COUNT(*) FILTER (WHERE rating = 4) AS rating_4_count,
    COUNT(*) FILTER (WHERE rating = 5) AS rating_5_count
  FROM feedback
  WHERE entity_id = p_entity_id AND entity_type = p_entity_type;
END;
$$ LANGUAGE plpgsql;
ALTER TABLE feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE improvement_suggestions ENABLE ROW LEVEL SECURITY;
ALTER TABLE suggestion_votes ENABLE ROW LEVEL SECURITY;
CREATE POLICY feedback_read_policy ON feedback
  FOR SELECT USING (true);
CREATE POLICY feedback_insert_policy ON feedback
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY feedback_update_policy ON feedback
  FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY improvement_suggestions_read_policy ON improvement_suggestions
  FOR SELECT USING (true);
CREATE POLICY improvement_suggestions_insert_policy ON improvement_suggestions
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY improvement_suggestions_update_policy ON improvement_suggestions
  FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY suggestion_votes_read_policy ON suggestion_votes
  FOR SELECT USING (true);
CREATE POLICY suggestion_votes_insert_policy ON suggestion_votes
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY suggestion_votes_update_policy ON suggestion_votes
  FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY suggestion_votes_delete_policy ON suggestion_votes
  FOR DELETE USING (auth.uid() = user_id);

================
File: supabase/migrations/20250504000000_sprint5_journey_analytics_foundation.sql
================
CREATE TABLE IF NOT EXISTS journey_analytics (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  entity_type VARCHAR(50) NOT NULL CHECK (entity_type IN ('step', 'phase', 'journey')),
  entity_id UUID NOT NULL,
  metric_type VARCHAR(50) NOT NULL,
  metric_value JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS journey_analytics_company_id_idx ON journey_analytics(company_id);
CREATE INDEX IF NOT EXISTS journey_analytics_entity_idx ON journey_analytics(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS journey_analytics_metric_type_idx ON journey_analytics(metric_type);
COMMENT ON TABLE journey_analytics IS 'Stores analytics data for journey steps, phases, and overall journeys';
CREATE TABLE IF NOT EXISTS journey_analytics_aggregations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  aggregation_key VARCHAR(100) NOT NULL,
  aggregation_type VARCHAR(50) NOT NULL,
  aggregation_period VARCHAR(20) CHECK (aggregation_period IN ('day', 'week', 'month', 'quarter', 'year', 'all')),
  aggregation_data JSONB NOT NULL,
  start_date DATE,
  end_date DATE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS journey_analytics_aggregations_unique_idx ON
  journey_analytics_aggregations(company_id, aggregation_key, aggregation_type,
  COALESCE(aggregation_period, 'all'), COALESCE(start_date, '1970-01-01'::DATE), COALESCE(end_date, '2999-12-31'::DATE));
COMMENT ON TABLE journey_analytics_aggregations IS 'Stores pre-calculated aggregations for journey analytics to improve performance';
CREATE TABLE IF NOT EXISTS user_preferences (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preference_key VARCHAR(100) NOT NULL,
  preference_value JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS user_preferences_unique_idx ON user_preferences(user_id, preference_key);
CREATE INDEX IF NOT EXISTS user_preferences_key_idx ON user_preferences(preference_key);
COMMENT ON TABLE user_preferences IS 'Stores user preferences for UI personalization and feature customization';
CREATE TABLE IF NOT EXISTS company_preferences (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  preference_key VARCHAR(100) NOT NULL,
  preference_value JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS company_preferences_unique_idx ON company_preferences(company_id, preference_key);
COMMENT ON TABLE company_preferences IS 'Stores company-level preferences for journey customization';
CREATE TABLE IF NOT EXISTS team_assignments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  entity_type VARCHAR(50) NOT NULL CHECK (entity_type IN ('step', 'phase', 'task')),
  entity_id UUID NOT NULL,
  assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  assigned_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  status VARCHAR(50) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'blocked')),
  due_date TIMESTAMPTZ,
  priority VARCHAR(20) CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS team_assignments_company_id_idx ON team_assignments(company_id);
CREATE INDEX IF NOT EXISTS team_assignments_entity_idx ON team_assignments(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS team_assignments_assigned_to_idx ON team_assignments(assigned_to);
CREATE INDEX IF NOT EXISTS team_assignments_status_idx ON team_assignments(status);
COMMENT ON TABLE team_assignments IS 'Tracks assignment of journey steps and tasks to team members';
CREATE TABLE IF NOT EXISTS collaborative_notes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  entity_type VARCHAR(50) NOT NULL CHECK (entity_type IN ('step', 'phase', 'journey', 'tool')),
  entity_id UUID NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  content TEXT NOT NULL,
  is_private BOOLEAN NOT NULL DEFAULT FALSE,
  parent_note_id UUID REFERENCES collaborative_notes(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS collaborative_notes_company_id_idx ON collaborative_notes(company_id);
CREATE INDEX IF NOT EXISTS collaborative_notes_entity_idx ON collaborative_notes(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS collaborative_notes_user_id_idx ON collaborative_notes(user_id);
CREATE INDEX IF NOT EXISTS collaborative_notes_parent_idx ON collaborative_notes(parent_note_id);
COMMENT ON TABLE collaborative_notes IS 'Stores collaborative notes and comments for journey entities';
CREATE TABLE IF NOT EXISTS activity_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  activity_type VARCHAR(100) NOT NULL,
  entity_type VARCHAR(50) NOT NULL,
  entity_id UUID,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS activity_logs_company_id_idx ON activity_logs(company_id);
CREATE INDEX IF NOT EXISTS activity_logs_user_id_idx ON activity_logs(user_id);
CREATE INDEX IF NOT EXISTS activity_logs_activity_type_idx ON activity_logs(activity_type);
CREATE INDEX IF NOT EXISTS activity_logs_entity_idx ON activity_logs(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS activity_logs_created_at_idx ON activity_logs(created_at);
COMMENT ON TABLE activity_logs IS 'Tracks user activities for the activity feed and notifications';
ALTER TABLE journey_steps
ADD COLUMN IF NOT EXISTS collaboration_enabled BOOLEAN DEFAULT TRUE,
ADD COLUMN IF NOT EXISTS requires_approval BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS last_activity_at TIMESTAMPTZ;
ALTER TABLE companies
ADD COLUMN IF NOT EXISTS personalization_settings JSONB DEFAULT '{}'::JSONB,
ADD COLUMN IF NOT EXISTS journey_customizations JSONB DEFAULT '{}'::JSONB;
CREATE OR REPLACE FUNCTION update_step_last_activity()
RETURNS TRIGGER AS $$
BEGIN
  NEW.last_activity_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
DROP TRIGGER IF EXISTS journey_steps_activity_trigger ON journey_steps;
CREATE TRIGGER journey_steps_activity_trigger
BEFORE UPDATE ON journey_steps
FOR EACH ROW
EXECUTE FUNCTION update_step_last_activity();
CREATE OR REPLACE FUNCTION record_journey_activity()
RETURNS TRIGGER AS $$
DECLARE
  activity_type VARCHAR;
  entity_type VARCHAR;
  metadata_json JSONB;
BEGIN
  IF TG_OP = 'INSERT' THEN
    activity_type := 'create_' || TG_TABLE_NAME;
  ELSIF TG_OP = 'UPDATE' THEN
    activity_type := 'update_' || TG_TABLE_NAME;
  ELSIF TG_OP = 'DELETE' THEN
    activity_type := 'delete_' || TG_TABLE_NAME;
  END IF;
  CASE TG_TABLE_NAME
    WHEN 'journey_steps' THEN
      entity_type := 'step';
    WHEN 'journey_phases' THEN
      entity_type := 'phase';
    WHEN 'team_assignments' THEN
      entity_type := 'assignment';
    WHEN 'collaborative_notes' THEN
      entity_type := 'note';
    ELSE
      entity_type := TG_TABLE_NAME;
  END CASE;
  IF TG_OP = 'INSERT' THEN
    metadata_json := to_jsonb(NEW);
  ELSIF TG_OP = 'UPDATE' THEN
    metadata_json := jsonb_build_object(
      'old', to_jsonb(OLD),
      'new', to_jsonb(NEW),
      'changed_fields', (
        SELECT jsonb_object_agg(key, value)
        FROM jsonb_each(to_jsonb(NEW))
        WHERE to_jsonb(NEW) -> key <> to_jsonb(OLD) -> key
      )
    );
  ELSIF TG_OP = 'DELETE' THEN
    metadata_json := to_jsonb(OLD);
  END IF;
  INSERT INTO activity_logs (
    company_id,
    user_id,
    activity_type,
    entity_type,
    entity_id,
    metadata
  ) VALUES (
    CASE
      WHEN TG_TABLE_NAME = 'journey_steps' OR TG_TABLE_NAME = 'journey_phases' THEN
        CASE
          WHEN TG_OP = 'DELETE' THEN OLD.company_id
          ELSE NEW.company_id
        END
      ELSE
        CASE
          WHEN TG_OP = 'DELETE' THEN OLD.company_id
          ELSE NEW.company_id
        END
    END,
    current_setting('request.jwt.claims', true)::jsonb->>'sub'::text,
    activity_type,
    entity_type,
    CASE
      WHEN TG_OP = 'DELETE' THEN OLD.id
      ELSE NEW.id
    END,
    metadata_json
  );
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
DROP TRIGGER IF EXISTS journey_steps_activity_log_trigger ON journey_steps;
CREATE TRIGGER journey_steps_activity_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON journey_steps
FOR EACH ROW EXECUTE FUNCTION record_journey_activity();
DROP TRIGGER IF EXISTS journey_phases_activity_log_trigger ON journey_phases;
CREATE TRIGGER journey_phases_activity_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON journey_phases
FOR EACH ROW EXECUTE FUNCTION record_journey_activity();
DROP TRIGGER IF EXISTS team_assignments_activity_log_trigger ON team_assignments;
CREATE TRIGGER team_assignments_activity_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON team_assignments
FOR EACH ROW EXECUTE FUNCTION record_journey_activity();
DROP TRIGGER IF EXISTS collaborative_notes_activity_log_trigger ON collaborative_notes;
CREATE TRIGGER collaborative_notes_activity_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON collaborative_notes
FOR EACH ROW EXECUTE FUNCTION record_journey_activity();
ALTER TABLE journey_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE journey_analytics_aggregations ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE company_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE team_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE collaborative_notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY journey_analytics_company_access ON journey_analytics
  FOR ALL USING (
    auth.uid() IN (
      SELECT user_id FROM company_members WHERE company_id = journey_analytics.company_id
    ) OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );
CREATE POLICY journey_analytics_aggregations_company_access ON journey_analytics_aggregations
  FOR ALL USING (
    auth.uid() IN (
      SELECT user_id FROM company_members WHERE company_id = journey_analytics_aggregations.company_id
    ) OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );
CREATE POLICY user_preferences_owner_access ON user_preferences
  FOR ALL USING (
    auth.uid() = user_preferences.user_id OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );
CREATE POLICY company_preferences_company_access ON company_preferences
  FOR ALL USING (
    auth.uid() IN (
      SELECT user_id FROM company_members WHERE company_id = company_preferences.company_id
    ) OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );
CREATE POLICY team_assignments_company_access ON team_assignments
  FOR ALL USING (
    auth.uid() IN (
      SELECT user_id FROM company_members WHERE company_id = team_assignments.company_id
    ) OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );
CREATE POLICY collaborative_notes_company_access ON collaborative_notes
  FOR ALL USING (
    (NOT is_private AND auth.uid() IN (
      SELECT user_id FROM company_members WHERE company_id = collaborative_notes.company_id
    )) OR
    (is_private AND auth.uid() = collaborative_notes.user_id) OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );
CREATE POLICY activity_logs_company_access ON activity_logs
  FOR ALL USING (
    auth.uid() IN (
      SELECT user_id FROM company_members WHERE company_id = activity_logs.company_id
    ) OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );
CREATE OR REPLACE FUNCTION get_journey_progress_stats(
  p_company_id UUID,
  p_journey_id UUID DEFAULT NULL,
  p_start_date DATE DEFAULT NULL,
  p_end_date DATE DEFAULT NULL
) RETURNS JSONB AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT
    jsonb_build_object(
      'total_steps', COUNT(js.id),
      'completed_steps', COUNT(js.id) FILTER (WHERE js.status = 'completed'),
      'in_progress_steps', COUNT(js.id) FILTER (WHERE js.status = 'in_progress'),
      'not_started_steps', COUNT(js.id) FILTER (WHERE js.status = 'not_started'),
      'blocked_steps', COUNT(js.id) FILTER (WHERE js.status = 'blocked'),
      'completion_percentage',
        CASE
          WHEN COUNT(js.id) > 0 THEN
            ROUND((COUNT(js.id) FILTER (WHERE js.status = 'completed')::NUMERIC / COUNT(js.id)) * 100, 2)
          ELSE 0
        END,
      'phases', (
        SELECT jsonb_agg(
          jsonb_build_object(
            'phase_id', jp.id,
            'phase_name', jp.name,
            'total_steps', COUNT(js_inner.id),
            'completed_steps', COUNT(js_inner.id) FILTER (WHERE js_inner.status = 'completed'),
            'completion_percentage',
              CASE
                WHEN COUNT(js_inner.id) > 0 THEN
                  ROUND((COUNT(js_inner.id) FILTER (WHERE js_inner.status = 'completed')::NUMERIC / COUNT(js_inner.id)) * 100, 2)
                ELSE 0
              END
          )
        )
        FROM journey_phases jp
        LEFT JOIN journey_steps js_inner ON js_inner.phase_id = jp.id
        WHERE jp.company_id = p_company_id
        GROUP BY jp.id, jp.name, jp.order
        ORDER BY jp.order
      )
    ) INTO result
  FROM journey_steps js
  WHERE js.company_id = p_company_id
  AND (p_journey_id IS NULL OR js.journey_id = p_journey_id)
  AND (p_start_date IS NULL OR js.updated_at >= p_start_date)
  AND (p_end_date IS NULL OR js.updated_at <= p_end_date);
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION get_team_assignments_stats(
  p_company_id UUID,
  p_user_id UUID DEFAULT NULL
) RETURNS JSONB AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT
    jsonb_build_object(
      'total_assignments', COUNT(ta.id),
      'pending_assignments', COUNT(ta.id) FILTER (WHERE ta.status = 'pending'),
      'in_progress_assignments', COUNT(ta.id) FILTER (WHERE ta.status = 'in_progress'),
      'completed_assignments', COUNT(ta.id) FILTER (WHERE ta.status = 'completed'),
      'blocked_assignments', COUNT(ta.id) FILTER (WHERE ta.status = 'blocked'),
      'users', (
        SELECT jsonb_agg(
          jsonb_build_object(
            'user_id', u.id,
            'user_name', u.raw_user_meta_data->>'full_name',
            'total_assignments', COUNT(ta_inner.id),
            'completed_assignments', COUNT(ta_inner.id) FILTER (WHERE ta_inner.status = 'completed'),
            'completion_percentage',
              CASE
                WHEN COUNT(ta_inner.id) > 0 THEN
                  ROUND((COUNT(ta_inner.id) FILTER (WHERE ta_inner.status = 'completed')::NUMERIC / COUNT(ta_inner.id)) * 100, 2)
                ELSE 0
              END
          )
        )
        FROM auth.users u
        LEFT JOIN team_assignments ta_inner ON ta_inner.assigned_to = u.id AND ta_inner.company_id = p_company_id
        JOIN company_members cm ON cm.user_id = u.id AND cm.company_id = p_company_id
        GROUP BY u.id, u.raw_user_meta_data->>'full_name'
      )
    ) INTO result
  FROM team_assignments ta
  WHERE ta.company_id = p_company_id
  AND (p_user_id IS NULL OR ta.assigned_to = p_user_id);
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

================
File: supabase/migrations/20250504000001_fix_sprint5_analytics_foundation.sql
================
CREATE OR REPLACE VIEW journey_steps_compatibility_view AS
SELECT
  jc.id,
  jc.name,
  jc.description,
  jc.phase_id,
  jc.difficulty_level,
  jc.estimated_time_min,
  jc.estimated_time_max,
  jc.key_outcomes,
  jc.prerequisite_challenges AS prerequisite_steps,
  jc.order_index,
  jc.created_at,
  jc.updated_at,
  companies.id AS company_id,
  false AS is_custom,
  'not_started' AS status
FROM journey_challenges jc
CROSS JOIN companies
WHERE companies.id IS NOT NULL
LIMIT 1;
CREATE OR REPLACE VIEW journey_phases_compatibility_view AS
SELECT * FROM journey_phases;
ALTER TABLE journey_challenges
ADD COLUMN IF NOT EXISTS collaboration_enabled BOOLEAN DEFAULT TRUE,
ADD COLUMN IF NOT EXISTS requires_approval BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS last_activity_at TIMESTAMPTZ;
CREATE OR REPLACE FUNCTION update_challenge_last_activity()
RETURNS TRIGGER AS $$
BEGIN
  NEW.last_activity_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
DROP TRIGGER IF EXISTS journey_challenges_activity_trigger ON journey_challenges;
CREATE TRIGGER journey_challenges_activity_trigger
BEFORE UPDATE ON journey_challenges
FOR EACH ROW
EXECUTE FUNCTION update_challenge_last_activity();
CREATE OR REPLACE FUNCTION record_journey_activity()
RETURNS TRIGGER AS $$
DECLARE
  activity_type VARCHAR;
  entity_type VARCHAR;
  metadata_json JSONB;
BEGIN
  IF TG_OP = 'INSERT' THEN
    activity_type := 'create_' || TG_TABLE_NAME;
  ELSIF TG_OP = 'UPDATE' THEN
    activity_type := 'update_' || TG_TABLE_NAME;
  ELSIF TG_OP = 'DELETE' THEN
    activity_type := 'delete_' || TG_TABLE_NAME;
  END IF;
  CASE TG_TABLE_NAME
    WHEN 'journey_challenges' THEN
      entity_type := 'challenge';
    WHEN 'journey_phases' THEN
      entity_type := 'phase';
    WHEN 'team_assignments' THEN
      entity_type := 'assignment';
    WHEN 'collaborative_notes' THEN
      entity_type := 'note';
    ELSE
      entity_type := TG_TABLE_NAME;
  END CASE;
  IF TG_OP = 'INSERT' THEN
    metadata_json := to_jsonb(NEW);
  ELSIF TG_OP = 'UPDATE' THEN
    metadata_json := jsonb_build_object(
      'old', to_jsonb(OLD),
      'new', to_jsonb(NEW),
      'changed_fields', (
        SELECT jsonb_object_agg(key, value)
        FROM jsonb_each(to_jsonb(NEW))
        WHERE to_jsonb(NEW) -> key <> to_jsonb(OLD) -> key
      )
    );
  ELSIF TG_OP = 'DELETE' THEN
    metadata_json := to_jsonb(OLD);
  END IF;
  INSERT INTO activity_logs (
    company_id,
    user_id,
    activity_type,
    entity_type,
    entity_id,
    metadata
  ) VALUES (
    CASE
      WHEN TG_TABLE_NAME = 'journey_challenges' OR TG_TABLE_NAME = 'journey_phases' THEN
        CASE
          WHEN TG_OP = 'DELETE' THEN
            (SELECT company_id FROM company_challenge_progress WHERE challenge_id = OLD.id LIMIT 1)
          ELSE
            (SELECT company_id FROM company_challenge_progress WHERE challenge_id = NEW.id LIMIT 1)
        END
      ELSE
        CASE
          WHEN TG_OP = 'DELETE' THEN OLD.company_id
          ELSE NEW.company_id
        END
    END,
    current_setting('request.jwt.claims', true)::jsonb->>'sub'::text,
    activity_type,
    entity_type,
    CASE
      WHEN TG_OP = 'DELETE' THEN OLD.id
      ELSE NEW.id
    END,
    metadata_json
  );
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
DROP TRIGGER IF EXISTS journey_challenges_activity_log_trigger ON journey_challenges;
CREATE TRIGGER journey_challenges_activity_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON journey_challenges
FOR EACH ROW EXECUTE FUNCTION record_journey_activity();
DROP TRIGGER IF EXISTS journey_phases_activity_log_trigger ON journey_phases;
CREATE TRIGGER journey_phases_activity_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON journey_phases
FOR EACH ROW EXECUTE FUNCTION record_journey_activity();
CREATE OR REPLACE FUNCTION get_journey_progress_stats(
  p_company_id UUID,
  p_journey_id UUID DEFAULT NULL,
  p_start_date DATE DEFAULT NULL,
  p_end_date DATE DEFAULT NULL
) RETURNS JSONB AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT
    jsonb_build_object(
      'total_steps', COUNT(jc.id),
      'completed_steps', COUNT(jc.id) FILTER (WHERE ccp.status = 'completed'),
      'in_progress_steps', COUNT(jc.id) FILTER (WHERE ccp.status = 'in_progress'),
      'not_started_steps', COUNT(jc.id) FILTER (WHERE ccp.status = 'not_started'),
      'blocked_steps', COUNT(jc.id) FILTER (WHERE ccp.status = 'skipped'),
      'completion_percentage',
        CASE
          WHEN COUNT(jc.id) > 0 THEN
            ROUND((COUNT(jc.id) FILTER (WHERE ccp.status = 'completed')::NUMERIC / COUNT(jc.id)) * 100, 2)
          ELSE 0
        END,
      'phases', (
        SELECT jsonb_agg(
          jsonb_build_object(
            'phase_id', jp.id,
            'phase_name', jp.name,
            'total_steps', COUNT(jc_inner.id),
            'completed_steps', COUNT(jc_inner.id) FILTER (WHERE ccp_inner.status = 'completed'),
            'completion_percentage',
              CASE
                WHEN COUNT(jc_inner.id) > 0 THEN
                  ROUND((COUNT(jc_inner.id) FILTER (WHERE ccp_inner.status = 'completed')::NUMERIC / COUNT(jc_inner.id)) * 100, 2)
                ELSE 0
              END
          )
        )
        FROM journey_phases jp
        LEFT JOIN journey_challenges jc_inner ON jc_inner.phase_id = jp.id
        LEFT JOIN company_challenge_progress ccp_inner ON ccp_inner.challenge_id = jc_inner.id AND ccp_inner.company_id = p_company_id
        GROUP BY jp.id, jp.name, jp.order_index
        ORDER BY jp.order_index
      )
    ) INTO result
  FROM journey_challenges jc
  LEFT JOIN company_challenge_progress ccp ON ccp.challenge_id = jc.id AND ccp.company_id = p_company_id
  WHERE (p_journey_id IS NULL OR true)
  AND (p_start_date IS NULL OR jc.updated_at >= p_start_date)
  AND (p_end_date IS NULL OR jc.updated_at <= p_end_date);
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
ALTER TABLE journey_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE journey_analytics_aggregations ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE company_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE team_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE collaborative_notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY journey_analytics_company_access ON journey_analytics
  FOR ALL USING (
    auth.uid() IN (
      SELECT user_id FROM company_members WHERE company_id = journey_analytics.company_id
    ) OR
    auth.uid() IN (
      SELECT id FROM auth.users WHERE auth.users.is_admin = true
    )
  );

================
File: supabase/migrations/20250505000000_journey_system_unification.sql
================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
DO $$
DECLARE
  tables_found text;
  cols_found text;
BEGIN
  SELECT string_agg(tablename, ', ') INTO tables_found
  FROM pg_tables
  WHERE schemaname = 'public';
  RAISE NOTICE 'Found tables: %', tables_found;
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'journey_step_tools') THEN
    RAISE NOTICE 'journey_step_tools exists, checking columns...';
    SELECT string_agg(column_name, ', ') INTO cols_found
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'journey_step_tools';
    RAISE NOTICE 'journey_step_tools columns: %', cols_found;
  END IF;
END
$$;
CREATE TABLE IF NOT EXISTS journey_phases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  order_index INTEGER NOT NULL,
  color VARCHAR(20) NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS journey_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  phase_id UUID NOT NULL REFERENCES journey_phases(id) ON DELETE CASCADE,
  order_index INTEGER NOT NULL,
  difficulty_level INTEGER NOT NULL DEFAULT 3,
  estimated_time_min INTEGER NOT NULL DEFAULT 30,
  estimated_time_max INTEGER NOT NULL DEFAULT 60,
  key_outcomes TEXT[] NULL DEFAULT '{}',
  prerequisite_steps UUID[] NULL DEFAULT '{}',
  is_custom BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'companies') THEN
    CREATE TABLE companies (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      name VARCHAR(255) NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  END IF;
END
$$;
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'tools') THEN
    CREATE TABLE tools (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      name VARCHAR(255) NOT NULL,
      description TEXT,
      type VARCHAR(50),
      is_premium BOOLEAN DEFAULT FALSE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  END IF;
END
$$;
CREATE TABLE IF NOT EXISTS step_tools (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  relevance_score DECIMAL(3,2) NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(step_id, tool_id)
);
CREATE TABLE IF NOT EXISTS company_step_tools (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  is_custom BOOLEAN NOT NULL DEFAULT FALSE,
  rating INTEGER NULL CHECK (rating BETWEEN 1 AND 5),
  notes TEXT NULL,
  selected_at TIMESTAMPTZ NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(company_id, step_id, tool_id)
);
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'company_journey_steps') THEN
    CREATE TABLE company_journey_steps (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
      step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
      status VARCHAR(20) NOT NULL CHECK (status IN ('not_started', 'in_progress', 'completed', 'skipped')),
      notes TEXT NULL,
      custom_difficulty INTEGER NULL CHECK (custom_difficulty BETWEEN 1 AND 5),
      custom_time_estimate INTEGER NULL,
      completion_percentage INTEGER NULL CHECK (completion_percentage BETWEEN 0 AND 100),
      order_index INTEGER NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      completed_at TIMESTAMPTZ NULL,
      UNIQUE(company_id, step_id)
    );
  END IF;
END
$$;
DROP VIEW IF EXISTS journey_challenges_view;
CREATE VIEW journey_challenges_view AS
SELECT
  id,
  name,
  description,
  phase_id,
  difficulty_level,
  estimated_time_min,
  estimated_time_max,
  key_outcomes,
  prerequisite_steps AS prerequisite_challenges,
  order_index,
  created_at,
  updated_at,
  is_custom
FROM
  journey_steps;
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'journey_step_tools') THEN
    RAISE NOTICE 'Found journey_step_tools table, migrating tool associations...';
    INSERT INTO step_tools (step_id, tool_id, relevance_score, created_at)
    SELECT
      step_id,
      tool_id,
      CASE
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='journey_step_tools' AND column_name='relevance_score')
        THEN (SELECT relevance_score FROM journey_step_tools WHERE id=jst.id)
        ELSE NULL
      END,
      COALESCE(jst.created_at, NOW())
    FROM journey_step_tools jst
    ON CONFLICT (step_id, tool_id) DO NOTHING;
    RAISE NOTICE 'Tool associations migration complete';
  END IF;
END
$$;
CREATE INDEX IF NOT EXISTS idx_journey_steps_phase_id ON journey_steps(phase_id);
CREATE INDEX IF NOT EXISTS idx_step_tools_step_id ON step_tools(step_id);
CREATE INDEX IF NOT EXISTS idx_step_tools_tool_id ON step_tools(tool_id);
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
DROP TRIGGER IF EXISTS update_step_tools_timestamp ON step_tools;
CREATE TRIGGER update_step_tools_timestamp
BEFORE UPDATE ON step_tools
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
DROP TRIGGER IF EXISTS update_company_step_tools_timestamp ON company_step_tools;
CREATE TRIGGER update_company_step_tools_timestamp
BEFORE UPDATE ON company_step_tools
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
CREATE INDEX IF NOT EXISTS idx_company_step_tools_company_id ON company_step_tools(company_id);
CREATE INDEX IF NOT EXISTS idx_company_step_tools_step_id ON company_step_tools(step_id);
CREATE INDEX IF NOT EXISTS idx_company_step_tools_tool_id ON company_step_tools(tool_id);

================
File: supabase/migrations/20250505010000_fix_tool_migration.sql
================
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'tools') THEN
    RAISE NOTICE 'Creating tools table...';
    CREATE TABLE tools (
      id UUID PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      description TEXT,
      url TEXT,
      logo_url TEXT,
      type VARCHAR(50) DEFAULT 'external',
      category VARCHAR(100),
      subcategory VARCHAR(100),
      is_premium BOOLEAN DEFAULT FALSE,
      pros TEXT,
      cons TEXT,
      customer_stage VARCHAR(100),
      source VARCHAR(50),
      status VARCHAR(50) DEFAULT 'approved',
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
    RAISE NOTICE 'Tools table created successfully';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'step_tools') THEN
    RAISE NOTICE 'Creating step_tools table...';
    CREATE TABLE step_tools (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
      tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
      relevance_score DECIMAL(3,2) DEFAULT 0.5,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(step_id, tool_id)
    );
    RAISE NOTICE 'Step tools table created successfully';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'journey_step_tools') THEN
    RAISE NOTICE 'Found journey_step_tools table, migrating tool data...';
    INSERT INTO tools (
      id,
      name,
      description,
      url,
      logo_url,
      type,
      category,
      subcategory,
      is_premium,
      pros,
      cons,
      customer_stage,
      source,
      status,
      created_at,
      updated_at
    )
    SELECT DISTINCT ON (id)
      id,
      name,
      description,
      url,
      logo_url,
      type,
      category,
      subcategory,
      is_premium,
      pros,
      cons,
      customer_stage,
      source,
      status,
      created_at,
      updated_at
    FROM journey_step_tools
    ON CONFLICT (id) DO NOTHING;
    INSERT INTO step_tools (step_id, tool_id, relevance_score, created_at)
    SELECT
      step_id,
      id,
      COALESCE(ranking / 5.0, 0.5),
      created_at
    FROM journey_step_tools
    ON CONFLICT (step_id, tool_id) DO NOTHING;
    RAISE NOTICE 'Migration complete: % unique tools migrated', (SELECT COUNT(*) FROM tools);
    RAISE NOTICE 'Migration complete: % step-tool associations created', (SELECT COUNT(*) FROM step_tools);
  ELSE
    RAISE NOTICE 'journey_step_tools table not found, no migration needed';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_step_tools_step_id') THEN
    CREATE INDEX idx_step_tools_step_id ON step_tools(step_id);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_step_tools_tool_id') THEN
    CREATE INDEX idx_step_tools_tool_id ON step_tools(tool_id);
  END IF;
END
$$;

================
File: supabase/migrations/20250505020000_fix_tool_migration_schema.sql
================
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'tools') THEN
    RAISE NOTICE 'Creating tools table with basic schema...';
    CREATE TABLE tools (
      id UUID PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      description TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
    RAISE NOTICE 'Tools table created successfully';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'step_tools') THEN
    RAISE NOTICE 'Creating step_tools table...';
    CREATE TABLE step_tools (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
      tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
      relevance_score DECIMAL(3,2) DEFAULT 0.5,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(step_id, tool_id)
    );
    RAISE NOTICE 'Step tools table created successfully';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'journey_step_tools') THEN
    RAISE NOTICE 'Found journey_step_tools table, migrating data...';
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'tools' AND column_name = 'name'
    ) THEN
      RAISE NOTICE 'Migrating core tool data...';
      INSERT INTO tools (
        id,
        name,
        description,
        created_at,
        updated_at
      )
      SELECT DISTINCT ON (id)
        id,
        name,
        description,
        created_at,
        updated_at
      FROM journey_step_tools
      ON CONFLICT (id) DO NOTHING;
      RAISE NOTICE 'Core tool data migrated';
    END IF;
    IF EXISTS (
      SELECT 1 FROM pg_tables WHERE tablename = 'step_tools'
    ) THEN
      RAISE NOTICE 'Creating step-tool associations...';
      INSERT INTO step_tools (step_id, tool_id, relevance_score, created_at)
      SELECT
        step_id,
        id,
        CASE
          WHEN ranking IS NOT NULL THEN ranking / 5.0
          ELSE 0.5
        END,
        created_at
      FROM journey_step_tools
      ON CONFLICT (step_id, tool_id) DO NOTHING;
      RAISE NOTICE 'Step-tool associations created';
    END IF;
    DECLARE
      tool_count INTEGER;
      mapping_count INTEGER;
    BEGIN
      SELECT COUNT(*) INTO tool_count FROM tools;
      SELECT COUNT(*) INTO mapping_count FROM step_tools;
      RAISE NOTICE 'Migration complete: % unique tools migrated', tool_count;
      RAISE NOTICE 'Migration complete: % step-tool associations created', mapping_count;
    END;
  ELSE
    RAISE NOTICE 'journey_step_tools table not found, no migration needed';
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'idx_step_tools_step_id'
  ) THEN
    CREATE INDEX idx_step_tools_step_id ON step_tools(step_id);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'idx_step_tools_tool_id'
  ) THEN
    CREATE INDEX idx_step_tools_tool_id ON step_tools(tool_id);
  END IF;
END
$$;

================
File: supabase/migrations/20250505030000_expand_tools_table.sql
================
DO $$
DECLARE
  col_exists boolean;
BEGIN
  RAISE NOTICE 'Starting tools table expansion...';
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'url'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding url column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS url TEXT;
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'logo_url'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding logo_url column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS logo_url TEXT;
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'type'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding type column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS type VARCHAR(50);
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'category'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding category column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS category VARCHAR(100);
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'subcategory'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding subcategory column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS subcategory VARCHAR(100);
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'is_premium'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding is_premium column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS is_premium BOOLEAN DEFAULT FALSE;
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'pros'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding pros column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS pros TEXT;
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'cons'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding cons column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS cons TEXT;
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'customer_stage'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding customer_stage column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS customer_stage VARCHAR(100);
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'source'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding source column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS source VARCHAR(50);
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'status'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding status column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS status VARCHAR(50) DEFAULT 'approved';
  END IF;
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'journey_step_tools' AND column_name = 'ranking'
  ) INTO col_exists;
  IF col_exists THEN
    RAISE NOTICE 'Adding ranking column to tools table...';
    ALTER TABLE tools ADD COLUMN IF NOT EXISTS ranking INTEGER;
  END IF;
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'journey_step_tools') THEN
    RAISE NOTICE 'Updating tools with additional data from journey_step_tools...';
    UPDATE tools t
    SET
      description = jst.description
    FROM journey_step_tools jst
    WHERE t.id = jst.id;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'url'
    ) THEN
      UPDATE tools t
      SET url = jst.url
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'logo_url'
    ) THEN
      UPDATE tools t
      SET logo_url = jst.logo_url
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'type'
    ) THEN
      UPDATE tools t
      SET type = jst.type
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'category'
    ) THEN
      UPDATE tools t
      SET category = jst.category
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'subcategory'
    ) THEN
      UPDATE tools t
      SET subcategory = jst.subcategory
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'is_premium'
    ) THEN
      UPDATE tools t
      SET is_premium = jst.is_premium
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'pros'
    ) THEN
      UPDATE tools t
      SET pros = jst.pros
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'cons'
    ) THEN
      UPDATE tools t
      SET cons = jst.cons
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'customer_stage'
    ) THEN
      UPDATE tools t
      SET customer_stage = jst.customer_stage
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'source'
    ) THEN
      UPDATE tools t
      SET source = jst.source
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'status'
    ) THEN
      UPDATE tools t
      SET status = jst.status
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_name = 'journey_step_tools' AND column_name = 'ranking'
    ) THEN
      UPDATE tools t
      SET ranking = jst.ranking
      FROM journey_step_tools jst
      WHERE t.id = jst.id;
    END IF;
  END IF;
  EXECUTE 'CREATE OR REPLACE VIEW journey_step_tools_view AS
  SELECT
    st.id AS relationship_id,
    st.step_id,
    st.tool_id,
    st.relevance_score,
    t.name AS tool_name,
    t.description AS tool_description,
    t.url AS tool_url,
    t.logo_url AS tool_logo_url,
    t.type AS tool_type,
    t.category AS tool_category,
    t.subcategory AS tool_subcategory,
    t.is_premium AS tool_is_premium,
    t.pros AS tool_pros,
    t.cons AS tool_cons,
    t.customer_stage AS tool_customer_stage,
    t.source AS tool_source,
    t.status AS tool_status,
    t.ranking AS tool_ranking,
    js.name AS step_name,
    js.phase_id,
    jp.name AS phase_name
  FROM
    step_tools st
  JOIN
    tools t ON st.tool_id = t.id
  JOIN
    journey_steps js ON st.step_id = js.id
  LEFT JOIN
    journey_phases jp ON js.phase_id = jp.id';
  RAISE NOTICE 'Tools table expansion complete. Created journey_step_tools_view for easy access to tool relationships.';
END;
$$;
DO $$
DECLARE
  tool_count INTEGER;
  column_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO tool_count FROM tools;
  SELECT COUNT(*) INTO column_count
  FROM information_schema.columns
  WHERE table_schema = 'public' AND table_name = 'tools';
  RAISE NOTICE 'Migration complete: % tools with % columns available', tool_count, column_count;
END;
$$;

================
File: supabase/migrations/20250505040000_add_compatibility_layer.sql
================
DROP VIEW IF EXISTS company_challenge_progress_view;
DO $$
DECLARE
  columns_found text;
  create_view_sql text;
BEGIN
  SELECT string_agg(column_name, ', ') INTO columns_found
  FROM information_schema.columns
  WHERE table_schema = 'public' AND table_name = 'company_journey_steps';
  RAISE NOTICE 'Found columns in company_journey_steps: %', columns_found;
  create_view_sql := 'CREATE VIEW company_challenge_progress_view AS SELECT id';
  IF columns_found LIKE '%company_id%' THEN
    create_view_sql := create_view_sql || ', company_id';
  ELSE
    IF columns_found LIKE '%user_id%' THEN
      create_view_sql := create_view_sql || ', user_id AS company_id';
    ELSE
      create_view_sql := create_view_sql || ', NULL::uuid AS company_id';
    END IF;
  END IF;
  IF columns_found LIKE '%step_id%' THEN
    create_view_sql := create_view_sql || ', step_id AS challenge_id';
  ELSE
    create_view_sql := create_view_sql || ', NULL::uuid AS challenge_id';
  END IF;
  IF columns_found LIKE '%status%' THEN
    create_view_sql := create_view_sql || ', status';
  ELSE
    create_view_sql := create_view_sql || ', ''not_started''::text AS status';
  END IF;
  IF columns_found LIKE '%notes%' THEN
    create_view_sql := create_view_sql || ', notes';
  ELSE
    create_view_sql := create_view_sql || ', NULL::text AS notes';
  END IF;
  IF columns_found LIKE '%completion_percentage%' THEN
    create_view_sql := create_view_sql || ', completion_percentage';
  ELSE
    create_view_sql := create_view_sql || ', 0 AS completion_percentage';
  END IF;
  IF columns_found LIKE '%order_index%' THEN
    create_view_sql := create_view_sql || ', order_index';
  ELSE
    create_view_sql := create_view_sql || ', 0 AS order_index';
  END IF;
  IF columns_found LIKE '%created_at%' THEN
    create_view_sql := create_view_sql || ', created_at';
  ELSE
    create_view_sql := create_view_sql || ', NOW() AS created_at';
  END IF;
  IF columns_found LIKE '%updated_at%' THEN
    create_view_sql := create_view_sql || ', updated_at';
  ELSE
    create_view_sql := create_view_sql || ', NOW() AS updated_at';
  END IF;
  IF columns_found LIKE '%completed_at%' THEN
    create_view_sql := create_view_sql || ', completed_at';
  ELSE
    create_view_sql := create_view_sql || ', NULL::timestamptz AS completed_at';
  END IF;
  create_view_sql := create_view_sql || ' FROM company_journey_steps';
  EXECUTE create_view_sql;
  RAISE NOTICE 'Created view with: %', create_view_sql;
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'Error creating view: %', SQLERRM;
    EXECUTE '
      CREATE VIEW company_challenge_progress_view AS
      SELECT
        id,
        NULL::uuid AS company_id,
        NULL::uuid AS challenge_id,
        ''not_started''::text AS status,
        NULL::text AS notes,
        0 AS completion_percentage,
        0 AS order_index,
        NOW() AS created_at,
        NOW() AS updated_at,
        NULL::timestamptz AS completed_at
      FROM
        company_journey_steps
      LIMIT 0';
    RAISE NOTICE 'Created fallback view instead.';
END
$$;
DROP VIEW IF EXISTS challenge_tool_recommendations_view;
CREATE VIEW challenge_tool_recommendations_view AS
SELECT
  st.id,
  st.step_id AS challenge_id,
  st.tool_id,
  st.relevance_score,
  st.created_at
FROM
  step_tools st;
CREATE OR REPLACE FUNCTION get_tool_evaluations_for_step(
  p_company_id UUID,
  p_step_id UUID
)
RETURNS TABLE (
  id UUID,
  company_id UUID,
  step_id UUID,
  tool_id UUID,
  tool_name TEXT,
  tool_description TEXT,
  tool_url TEXT,
  tool_logo_url TEXT,
  is_custom BOOLEAN,
  rating INTEGER,
  notes TEXT,
  selected_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cst.id,
    cst.company_id,
    cst.step_id,
    cst.tool_id,
    t.name AS tool_name,
    t.description AS tool_description,
    t.url AS tool_url,
    t.logo_url AS tool_logo_url,
    cst.is_custom,
    cst.rating,
    cst.notes,
    cst.selected_at,
    cst.created_at,
    cst.updated_at
  FROM
    company_step_tools cst
  JOIN
    tools t ON cst.tool_id = t.id
  WHERE
    cst.company_id = p_company_id
    AND cst.step_id = p_step_id
  ORDER BY
    cst.selected_at DESC NULLS LAST,
    cst.rating DESC NULLS LAST,
    cst.updated_at DESC;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_tool_comparison_data(
  p_tool_ids UUID[]
)
RETURNS TABLE (
  tool_id UUID,
  name TEXT,
  description TEXT,
  url TEXT,
  logo_url TEXT,
  type TEXT,
  category TEXT,
  subcategory TEXT,
  is_premium BOOLEAN,
  pricing_model TEXT,
  pros TEXT,
  cons TEXT,
  source TEXT,
  status TEXT,
  rating_avg FLOAT,
  usage_count INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    t.id AS tool_id,
    t.name,
    t.description,
    t.url,
    t.logo_url,
    t.type,
    t.category,
    t.subcategory,
    t.is_premium,
    t.pricing_model,
    t.pros,
    t.cons,
    t.source,
    t.status,
    (SELECT AVG(cst.rating)::FLOAT FROM company_step_tools cst WHERE cst.tool_id = t.id AND cst.rating IS NOT NULL) AS rating_avg,
    (SELECT COUNT(DISTINCT cst.company_id) FROM company_step_tools cst WHERE cst.tool_id = t.id) AS usage_count
  FROM
    tools t
  WHERE
    t.id = ANY(p_tool_ids)
  ORDER BY
    rating_avg DESC NULLS LAST,
    usage_count DESC;
END;
$$ LANGUAGE plpgsql;
COMMENT ON VIEW company_challenge_progress_view IS
  'Compatibility view mapping company_journey_steps to the previous company_challenge_progress model';
COMMENT ON VIEW challenge_tool_recommendations_view IS
  'Compatibility view mapping step_tools to the previous challenge_tool_recommendations model';
COMMENT ON FUNCTION get_tool_evaluations_for_step IS
  'Get tool evaluations for a specific step with tool details';
COMMENT ON FUNCTION get_tool_comparison_data IS
  'Get detailed information for tool comparison, including average ratings and usage';

================
File: supabase/sql/20250430_complete_recommendation_system_migration.sql
================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS tool_recommendations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  relevance_score NUMERIC(5,2) NOT NULL DEFAULT 5.0,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  UNIQUE(step_id, tool_id)
);
COMMENT ON TABLE tool_recommendations IS 'Stores tool recommendations for journey steps with relevance scores';
ALTER TABLE tool_recommendations ENABLE ROW LEVEL SECURITY;
CREATE POLICY IF NOT EXISTS tool_recommendations_select_policy ON tool_recommendations
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM journey_steps js
    JOIN company_members cm ON js.company_id = cm.company_id
    WHERE js.id = tool_recommendations.step_id
    AND cm.user_id = auth.uid()
  )
);
CREATE POLICY IF NOT EXISTS tool_recommendations_all_policy ON tool_recommendations
FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE id = auth.uid() AND role = 'admin'
  )
);
CREATE OR REPLACE FUNCTION get_steps_by_industry_popularity(
  p_industry_id UUID
)
RETURNS TABLE (
  step_id UUID,
  step_name TEXT,
  completion_count INTEGER,
  percentile NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH industry_companies AS (
    SELECT id FROM companies WHERE industry_id = p_industry_id
  ),
  step_completions AS (
    SELECT
      step_id,
      COUNT(*) as completion_count
    FROM company_progress
    WHERE
      company_id IN (SELECT id FROM industry_companies)
      AND status = 'completed'
    GROUP BY step_id
  ),
  step_ranks AS (
    SELECT
      step_id,
      completion_count,
      PERCENT_RANK() OVER (ORDER BY completion_count) * 100 as percentile
    FROM step_completions
  )
  SELECT
    sr.step_id,
    s.name as step_name,
    sr.completion_count,
    sr.percentile
  FROM step_ranks sr
  JOIN journey_steps s ON sr.step_id = s.id
  ORDER BY sr.percentile DESC;
END;
$$;
COMMENT ON FUNCTION get_steps_by_industry_popularity IS
  'Get journey steps ranked by popularity within a specific industry';
CREATE OR REPLACE FUNCTION get_common_step_sequences(
  p_completed_steps UUID[]
)
RETURNS TABLE (
  next_step_id UUID,
  next_step_name TEXT,
  frequency INTEGER,
  avg_time_to_completion INTERVAL
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH target_companies AS (
    SELECT DISTINCT cp.company_id
    FROM company_progress cp
    WHERE
      cp.step_id = ANY(p_completed_steps)
      AND cp.status = 'completed'
  ),
  next_steps AS (
    SELECT
      cp.step_id,
      cp.company_id,
      cp.completed_at,
      cp.created_at,
      ROW_NUMBER() OVER (
        PARTITION BY cp.company_id
        ORDER BY cp.completed_at
      ) as step_order
    FROM company_progress cp
    JOIN target_companies tc ON cp.company_id = tc.company_id
    WHERE
      cp.status = 'completed'
      AND NOT (cp.step_id = ANY(p_completed_steps))
  ),
  next_step_frequencies AS (
    SELECT
      ns.step_id,
      COUNT(DISTINCT ns.company_id) as frequency,
      AVG(ns.completed_at - ns.created_at) as avg_time_to_completion
    FROM next_steps ns
    WHERE ns.step_order = 1
    GROUP BY ns.step_id
  )
  SELECT
    nsf.step_id as next_step_id,
    js.name as next_step_name,
    nsf.frequency,
    nsf.avg_time_to_completion
  FROM next_step_frequencies nsf
  JOIN journey_steps js ON nsf.step_id = js.id
  ORDER BY nsf.frequency DESC;
END;
$$;
COMMENT ON FUNCTION get_common_step_sequences IS
  'Get steps commonly completed after a given set of steps, ranked by frequency';
CREATE OR REPLACE VIEW journey_step_relationships AS
WITH prerequisite_relationships AS (
  SELECT
    js.id as step_id,
    js.name as step_name,
    pre.prerequisite_id,
    'prerequisite' as relationship_type
  FROM journey_steps js
  CROSS JOIN LATERAL (
    SELECT jsonb_array_elements_text(js.prerequisite_steps::jsonb)::uuid as prerequisite_id
  ) pre
  WHERE js.prerequisite_steps IS NOT NULL AND js.prerequisite_steps != '{}'::jsonb
),
dependent_steps AS (
  SELECT
    pr.prerequisite_id as step_id,
    js.id as dependent_id,
    js.name as dependent_name,
    'dependent' as relationship_type
  FROM prerequisite_relationships pr
  JOIN journey_steps js ON js.id = pr.step_id
)
SELECT
  r.step_id,
  s1.name as step_name,
  r.prerequisite_id as related_id,
  s2.name as related_name,
  r.relationship_type
FROM prerequisite_relationships r
JOIN journey_steps s1 ON r.step_id = s1.id
JOIN journey_steps s2 ON r.prerequisite_id = s2.id
UNION ALL
SELECT
  d.step_id,
  s1.name as step_name,
  d.dependent_id as related_id,
  d.dependent_name as related_name,
  d.relationship_type
FROM dependent_steps d
JOIN journey_steps s1 ON d.step_id = s1.id;
COMMENT ON VIEW journey_step_relationships IS
  'View showing prerequisite and dependent relationships between journey steps';
CREATE OR REPLACE VIEW journey_step_recommendations AS
SELECT
  js.id,
  js.name,
  js.description,
  js.phase_id,
  jp.name as phase_name,
  js.difficulty_level,
  js.estimated_time_min,
  js.estimated_time_max,
  js.key_outcomes,
  js.prerequisite_steps,
  js.order_index,
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', t.id,
        'name', t.name,
        'description', t.description,
        'url', t.url,
        'logo_url', NULL,
        'relevance_score', tr.relevance_score
      )
    )
    FROM tools t
    JOIN tool_recommendations tr ON t.id = tr.tool_id
    WHERE tr.step_id = js.id
  ) as recommended_tools,
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', r.related_id,
        'name', r.related_name,
        'relationship_type', r.relationship_type
      )
    )
    FROM journey_step_relationships r
    WHERE r.step_id = js.id
  ) as related_steps
FROM journey_steps js
LEFT JOIN journey_phases jp ON js.phase_id = jp.id;
COMMENT ON VIEW journey_step_recommendations IS
  'View providing step recommendations with related tools and step relationships';
CREATE OR REPLACE FUNCTION get_recommended_tools_for_step(p_step_id UUID, p_limit INTEGER DEFAULT 5)
RETURNS TABLE (
  tool_id UUID,
  tool_name TEXT,
  tool_description TEXT,
  tool_url TEXT,
  tool_logo_url TEXT,
  relevance_score NUMERIC(5,2),
  category TEXT
)
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT
    t.id AS tool_id,
    t.name AS tool_name,
    t.description AS tool_description,
    t.url AS tool_url,
    NULL AS tool_logo_url,
    tr.relevance_score,
    t.category
  FROM tool_recommendations tr
  JOIN tools t ON tr.tool_id = t.id
  WHERE tr.step_id = p_step_id
  ORDER BY tr.relevance_score DESC
  LIMIT p_limit;
$$;
COMMENT ON FUNCTION get_recommended_tools_for_step IS
  'Get top recommended tools for a specific journey step with relevance scores';
CREATE OR REPLACE FUNCTION get_personalized_step_recommendations(
  p_company_id UUID,
  p_limit INTEGER DEFAULT 5,
  p_exclude_completed BOOLEAN DEFAULT true
)
RETURNS TABLE (
  step_id UUID,
  step_name TEXT,
  step_description TEXT,
  phase_name TEXT,
  estimated_min_minutes INTEGER,
  estimated_max_minutes INTEGER,
  difficulty_level INTEGER,
  relevance_score NUMERIC(5,2),
  reasoning TEXT[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  completed_steps UUID[];
  company_industry_id UUID;
BEGIN
  IF p_exclude_completed THEN
    SELECT array_agg(company_progress.step_id) INTO completed_steps
    FROM company_progress
    WHERE company_id = p_company_id AND status = 'completed';
    IF completed_steps IS NULL THEN
      completed_steps := ARRAY[]::UUID[];
    END IF;
  ELSE
    completed_steps := ARRAY[]::UUID[];
  END IF;
  SELECT industry_id INTO company_industry_id
  FROM companies
  WHERE id = p_company_id;
  RETURN QUERY
  WITH step_scores AS (
    SELECT
      js.id,
      js.name,
      js.description,
      jp.name AS phase_name,
      js.estimated_time_min,
      js.estimated_time_max,
      js.difficulty_level,
      5.0 AS base_score,
      CASE
        WHEN js.prerequisite_steps IS NULL OR js.prerequisite_steps = '{}' THEN 2.0
        WHEN (SELECT COUNT(*) FROM jsonb_array_elements_text(js.prerequisite_steps::jsonb) AS prereq_id
              WHERE prereq_id::UUID NOT IN (SELECT unnest(completed_steps))) = 0 THEN 2.0
        ELSE -5.0
      END AS prereq_score,
      COALESCE((
        SELECT (ip.percentile / 50) * 2
        FROM get_steps_by_industry_popularity(company_industry_id) ip
        WHERE ip.step_id = js.id
        LIMIT 1
      ), 0) AS industry_score,
      COALESCE((
        SELECT (cs.frequency / 10)
        FROM get_common_step_sequences(completed_steps) cs
        WHERE cs.next_step_id = js.id
        LIMIT 1
      ), 0) AS sequence_score,
      ARRAY[
        CASE WHEN js.prerequisite_steps IS NULL OR js.prerequisite_steps = '{}'
             THEN 'No prerequisites required'
             WHEN (SELECT COUNT(*) FROM jsonb_array_elements_text(js.prerequisite_steps::jsonb) AS prereq_id
                  WHERE prereq_id::UUID NOT IN (SELECT unnest(completed_steps))) = 0
             THEN 'All prerequisites are completed'
             ELSE 'Some prerequisites are not yet completed'
        END,
        COALESCE((
          SELECT 'Popular choice in your industry (' || ROUND(ip.percentile) || '% percentile)'
          FROM get_steps_by_industry_popularity(company_industry_id) ip
          WHERE ip.step_id = js.id
          LIMIT 1
        ), 'New option for your industry'),
        COALESCE((
          SELECT cs.frequency || ' companies completed this step next'
          FROM get_common_step_sequences(completed_steps) cs
          WHERE cs.next_step_id = js.id
          LIMIT 1
        ), 'Builds on your current progress')
      ] AS reasoning
    FROM journey_steps js
    LEFT JOIN journey_phases jp ON js.phase_id = jp.id
    WHERE (NOT p_exclude_completed OR js.id <> ALL(completed_steps))
  ),
  scored_steps AS (
    SELECT
      id,
      name,
      description,
      phase_name,
      estimated_time_min,
      estimated_time_max,
      difficulty_level,
      GREATEST(1.0, LEAST(10.0, (
        base_score +
        prereq_score +
        industry_score +
        sequence_score
      ))) AS relevance_score,
      reasoning
    FROM step_scores
  )
  SELECT * FROM scored_steps
  ORDER BY relevance_score DESC, name
  LIMIT p_limit;
END;
$$;
COMMENT ON FUNCTION get_personalized_step_recommendations IS
  'Get personalized step recommendations for a company based on their progress and industry';
CREATE OR REPLACE FUNCTION get_step_relationships(p_step_id UUID, p_depth INTEGER DEFAULT 1)
RETURNS TABLE (
  source_id UUID,
  source_name TEXT,
  target_id UUID,
  target_name TEXT,
  relationship_type TEXT,
  relationship_strength INTEGER
)
LANGUAGE sql
SECURITY DEFINER
AS $$
WITH RECURSIVE relationship_tree AS (
  SELECT
    r.step_id AS source_id,
    s1.name AS source_name,
    r.related_id AS target_id,
    r.related_name AS target_name,
    r.relationship_type,
    1 AS depth,
    CASE
      WHEN r.relationship_type = 'prerequisite' THEN 3
      WHEN r.relationship_type = 'dependent' THEN 2
      ELSE 1
    END AS relationship_strength
  FROM journey_step_relationships r
  JOIN journey_steps s1 ON r.step_id = s1.id
  WHERE r.step_id = p_step_id OR r.related_id = p_step_id
  UNION ALL
  SELECT
    r.step_id AS source_id,
    s1.name AS source_name,
    r.related_id AS target_id,
    r.related_name AS target_name,
    r.relationship_type,
    rt.depth + 1,
    CASE
      WHEN r.relationship_type = 'prerequisite' THEN 3
      WHEN r.relationship_type = 'dependent' THEN 2
      ELSE 1
    END AS relationship_strength
  FROM journey_step_relationships r
  JOIN journey_steps s1 ON r.step_id = s1.id
  JOIN relationship_tree rt ON r.step_id = rt.target_id
  WHERE rt.depth < p_depth
)
SELECT DISTINCT
  source_id,
  source_name,
  target_id,
  target_name,
  relationship_type,
  relationship_strength
FROM relationship_tree
ORDER BY relationship_strength DESC, source_name, target_name;
$$;
COMMENT ON FUNCTION get_step_relationships IS
  'Get relationships between steps for visualization with configurable depth';
CREATE OR REPLACE FUNCTION seed_tool_recommendations()
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    step_record RECORD;
    tool_record RECORD;
    num_tools INTEGER;
    category_tools UUID[];
    selected_tool UUID;
    relevance NUMERIC(5,2);
    step_counter INTEGER := 0;
    tool_counter INTEGER := 0;
BEGIN
    FOR step_record IN
        SELECT id, name, phase_id
        FROM journey_steps
        LIMIT 50
    LOOP
        step_counter := step_counter + 1;
        RAISE NOTICE 'Processing step % of 50: %', step_counter, step_record.name;
        num_tools := 2 + floor(random() * 4)::INTEGER;
        FOR tool_record IN
            SELECT category FROM tools WHERE category IS NOT NULL
            GROUP BY category
            ORDER BY random()
            LIMIT 2
        LOOP
            category_tools := ARRAY(
                SELECT id FROM tools
                WHERE category = tool_record.category
                ORDER BY random()
                LIMIT ceil(num_tools/2)::INTEGER
            );
            FOREACH selected_tool IN ARRAY category_tools
            LOOP
                IF tool_counter % 2 = 0 THEN
                    relevance := 7.0 + random() * 2.0;
                ELSE
                    relevance := 5.0 + random() * 2.0;
                END IF;
                relevance := round(relevance * 100) / 100;
                INSERT INTO tool_recommendations (step_id, tool_id, relevance_score)
                VALUES (step_record.id, selected_tool, relevance)
                ON CONFLICT (step_id, tool_id) DO UPDATE
                SET relevance_score = EXCLUDED.relevance_score,
                    updated_at = NOW();
                tool_counter := tool_counter + 1;
            END LOOP;
        END LOOP;
        IF (SELECT COUNT(*) FROM tool_recommendations WHERE step_id = step_record.id) < num_tools THEN
            INSERT INTO tool_recommendations (step_id, tool_id, relevance_score)
            SELECT
                step_record.id,
                t.id,
                round((4.0 + random() * 3.0)::numeric, 2) as relevance
            FROM tools t
            WHERE t.id NOT IN (SELECT tool_id FROM tool_recommendations WHERE step_id = step_record.id)
            ORDER BY random()
            LIMIT num_tools - (SELECT COUNT(*) FROM tool_recommendations WHERE step_id = step_record.id);
        END IF;
    END LOOP;
    RAISE NOTICE 'Seeding complete. Added recommendations for % steps and % tools', step_counter, tool_counter;
END;
$$;
COMMENT ON FUNCTION seed_tool_recommendations IS
  'Function to seed sample tool recommendations for journey steps';
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_step_id ON tool_recommendations(step_id);
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_tool_id ON tool_recommendations(tool_id);
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_relevance ON tool_recommendations(relevance_score DESC);
DO $$
DECLARE
  missing_objects TEXT := '';
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'tool_recommendations') THEN
    missing_objects := missing_objects || 'tool_recommendations table is missing. ';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = 'journey_step_relationships') THEN
    missing_objects := missing_objects || 'journey_step_relationships view is missing. ';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = 'journey_step_recommendations') THEN
    missing_objects := missing_objects || 'journey_step_recommendations view is missing. ';
  END IF;
  IF LENGTH(missing_objects) > 0 THEN
    RAISE WARNING 'Migration verification failed: %', missing_objects;
  ELSE
    RAISE NOTICE 'Migration verification successful! All expected objects were created.';
  END IF;
END
$$;
DO $$
DECLARE
  policy_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO policy_count
  FROM pg_policies
  WHERE tablename = 'tool_recommendations';
  RAISE NOTICE 'RLS policies for tool_recommendations: %', policy_count;
  IF policy_count < 2 THEN
    RAISE WARNING 'Expected at least 2 RLS policies for tool_recommendations table.';
  END IF;
END
$$;
/*
SELECT * FROM get_recommended_tools_for_step(
  (SELECT id FROM journey_steps LIMIT 1),
  5
);
SELECT * FROM get_personalized_step_recommendations(
  (SELECT id FROM companies LIMIT 1),
  5,
  true
);
*/
RAISE NOTICE 'Recommendation system migration completed successfully!';

================
File: supabase/sql/20250430_query_recommendation_functions.sql
================
CREATE OR REPLACE FUNCTION get_recommended_tools_for_step(p_step_id UUID, p_limit INTEGER DEFAULT 5)
RETURNS TABLE (
  tool_id UUID,
  tool_name TEXT,
  tool_description TEXT,
  tool_url TEXT,
  tool_logo_url TEXT,
  relevance_score NUMERIC(5,2),
  category TEXT
)
LANGUAGE sql
AS $$
  SELECT
    t.id AS tool_id,
    t.name AS tool_name,
    t.description AS tool_description,
    t.url AS tool_url,
    NULL AS tool_logo_url,
    tr.relevance_score,
    t.category
  FROM tool_recommendations tr
  JOIN tools t ON tr.tool_id = t.id
  WHERE tr.step_id = p_step_id
  ORDER BY tr.relevance_score DESC
  LIMIT p_limit;
$$;
CREATE OR REPLACE FUNCTION get_personalized_step_recommendations(
  p_company_id UUID,
  p_limit INTEGER DEFAULT 5,
  p_exclude_completed BOOLEAN DEFAULT true
)
RETURNS TABLE (
  step_id UUID,
  step_name TEXT,
  step_description TEXT,
  phase_name TEXT,
  estimated_min_minutes INTEGER,
  estimated_max_minutes INTEGER,
  difficulty_level INTEGER,
  relevance_score NUMERIC(5,2),
  reasoning TEXT[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  completed_steps UUID[];
  company_industry_id UUID;
BEGIN
  IF p_exclude_completed THEN
    SELECT array_agg(company_progress.step_id) INTO completed_steps
    FROM company_progress
    WHERE company_id = p_company_id AND status = 'completed';
    IF completed_steps IS NULL THEN
      completed_steps := ARRAY[]::UUID[];
    END IF;
  ELSE
    completed_steps := ARRAY[]::UUID[];
  END IF;
  SELECT industry_id INTO company_industry_id
  FROM companies
  WHERE id = p_company_id;
  RETURN QUERY
  WITH step_scores AS (
    SELECT
      js.id,
      js.name,
      js.description,
      jp.name AS phase_name,
      js.estimated_time_min,
      js.estimated_time_max,
      js.difficulty_level,
      5.0 AS base_score,
      CASE
        WHEN js.prerequisite_steps IS NULL OR js.prerequisite_steps = '{}' THEN 2.0
        WHEN (SELECT COUNT(*) FROM jsonb_array_elements_text(js.prerequisite_steps::jsonb) AS prereq_id
              WHERE prereq_id::UUID NOT IN (SELECT unnest(completed_steps))) = 0 THEN 2.0
        ELSE -5.0
      END AS prereq_score,
      COALESCE((
        SELECT (ip.percentile / 50) * 2
        FROM get_steps_by_industry_popularity(company_industry_id) ip
        WHERE ip.step_id = js.id
        LIMIT 1
      ), 0) AS industry_score,
      COALESCE((
        SELECT (cs.frequency / 10)
        FROM get_common_step_sequences(completed_steps) cs
        WHERE cs.next_step_id = js.id
        LIMIT 1
      ), 0) AS sequence_score,
      ARRAY[
        CASE WHEN js.prerequisite_steps IS NULL OR js.prerequisite_steps = '{}'
             THEN 'No prerequisites required'
             WHEN (SELECT COUNT(*) FROM jsonb_array_elements_text(js.prerequisite_steps::jsonb) AS prereq_id
                  WHERE prereq_id::UUID NOT IN (SELECT unnest(completed_steps))) = 0
             THEN 'All prerequisites are completed'
             ELSE 'Some prerequisites are not yet completed'
        END,
        COALESCE((
          SELECT 'Popular choice in your industry (' || ROUND(ip.percentile) || '% percentile)'
          FROM get_steps_by_industry_popularity(company_industry_id) ip
          WHERE ip.step_id = js.id
          LIMIT 1
        ), 'New option for your industry'),
        COALESCE((
          SELECT cs.frequency || ' companies completed this step next'
          FROM get_common_step_sequences(completed_steps) cs
          WHERE cs.next_step_id = js.id
          LIMIT 1
        ), 'Builds on your current progress')
      ] AS reasoning
    FROM journey_steps js
    LEFT JOIN journey_phases jp ON js.phase_id = jp.id
    WHERE (NOT p_exclude_completed OR js.id <> ALL(completed_steps))
  ),
  scored_steps AS (
    SELECT
      id,
      name,
      description,
      phase_name,
      estimated_time_min,
      estimated_time_max,
      difficulty_level,
      GREATEST(1.0, LEAST(10.0, (
        base_score +
        prereq_score +
        industry_score +
        sequence_score
      ))) AS relevance_score,
      reasoning
    FROM step_scores
  )
  SELECT * FROM scored_steps
  ORDER BY relevance_score DESC, name
  LIMIT p_limit;
END;
$$;
CREATE OR REPLACE FUNCTION get_step_relationships(p_step_id UUID, p_depth INTEGER DEFAULT 1)
RETURNS TABLE (
  source_id UUID,
  source_name TEXT,
  target_id UUID,
  target_name TEXT,
  relationship_type TEXT,
  relationship_strength INTEGER
)
LANGUAGE sql
AS $$
WITH RECURSIVE relationship_tree AS (
  SELECT
    r.step_id AS source_id,
    s1.name AS source_name,
    r.related_id AS target_id,
    r.related_name AS target_name,
    r.relationship_type,
    1 AS depth,
    CASE
      WHEN r.relationship_type = 'prerequisite' THEN 3
      WHEN r.relationship_type = 'dependent' THEN 2
      ELSE 1
    END AS relationship_strength
  FROM journey_step_relationships r
  JOIN journey_steps s1 ON r.step_id = s1.id
  WHERE r.step_id = p_step_id OR r.related_id = p_step_id
  UNION ALL
  SELECT
    r.step_id AS source_id,
    s1.name AS source_name,
    r.related_id AS target_id,
    r.related_name AS target_name,
    r.relationship_type,
    rt.depth + 1,
    CASE
      WHEN r.relationship_type = 'prerequisite' THEN 3
      WHEN r.relationship_type = 'dependent' THEN 2
      ELSE 1
    END AS relationship_strength
  FROM journey_step_relationships r
  JOIN journey_steps s1 ON r.step_id = s1.id
  JOIN relationship_tree rt ON r.step_id = rt.target_id
  WHERE rt.depth < p_depth
)
SELECT DISTINCT
  source_id,
  source_name,
  target_id,
  target_name,
  relationship_type,
  relationship_strength
FROM relationship_tree
ORDER BY relationship_strength DESC, source_name, target_name;
$$;
COMMENT ON FUNCTION get_recommended_tools_for_step IS
  'Get top recommended tools for a specific journey step with relevance scores';
COMMENT ON FUNCTION get_personalized_step_recommendations IS
  'Get personalized step recommendations for a company based on their progress and industry';
COMMENT ON FUNCTION get_step_relationships IS
  'Get relationships between steps for visualization with configurable depth';
SELECT * FROM get_recommended_tools_for_step(
  (SELECT id FROM journey_steps LIMIT 1),
  5
);
SELECT * FROM get_personalized_step_recommendations(
  (SELECT id FROM companies LIMIT 1),
  5,
  true
);
SELECT * FROM get_step_relationships(
  (SELECT id FROM journey_steps LIMIT 1),
  1
);

================
File: supabase/sql/20250430_seed_tool_recommendations.sql
================
DROP TABLE IF EXISTS tool_recommendations CASCADE;
CREATE TABLE tool_recommendations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  step_id UUID NOT NULL REFERENCES journey_steps(id) ON DELETE CASCADE,
  tool_id UUID NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  relevance_score NUMERIC(5,2) NOT NULL DEFAULT 5.0,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  UNIQUE(step_id, tool_id)
);
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_step_id ON tool_recommendations(step_id);
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_tool_id ON tool_recommendations(tool_id);
CREATE INDEX IF NOT EXISTS idx_tool_recommendations_relevance ON tool_recommendations(relevance_score DESC);
ALTER TABLE tool_recommendations ENABLE ROW LEVEL SECURITY;
CREATE POLICY IF NOT EXISTS tool_recommendations_select_policy ON tool_recommendations
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM journey_steps js
    JOIN company_members cm ON js.company_id = cm.company_id
    WHERE js.id = tool_recommendations.step_id
    AND cm.user_id = auth.uid()
  )
);
CREATE POLICY IF NOT EXISTS tool_recommendations_all_policy ON tool_recommendations
FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE id = auth.uid() AND role = 'admin'
  )
);
CREATE OR REPLACE FUNCTION seed_tool_recommendations()
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    step_record RECORD;
    tool_record RECORD;
    num_tools INTEGER;
    category_tools UUID[];
    selected_tool UUID;
    relevance NUMERIC(5,2);
    step_counter INTEGER := 0;
    tool_counter INTEGER := 0;
BEGIN
    FOR step_record IN
        SELECT id, name, phase_id
        FROM journey_steps
        LIMIT 50
    LOOP
        step_counter := step_counter + 1;
        RAISE NOTICE 'Processing step % of 50: %', step_counter, step_record.name;
        num_tools := 2 + floor(random() * 4)::INTEGER;
        FOR tool_record IN
            SELECT category FROM tools WHERE category IS NOT NULL
            GROUP BY category
            ORDER BY random()
            LIMIT 2
        LOOP
            category_tools := ARRAY(
                SELECT id FROM tools
                WHERE category = tool_record.category
                ORDER BY random()
                LIMIT ceil(num_tools/2)::INTEGER
            );
            FOREACH selected_tool IN ARRAY category_tools
            LOOP
                IF tool_counter % 2 = 0 THEN
                    relevance := 7.0 + random() * 2.0;
                ELSE
                    relevance := 5.0 + random() * 2.0;
                END IF;
                relevance := round(relevance * 100) / 100;
                INSERT INTO tool_recommendations (step_id, tool_id, relevance_score)
                VALUES (step_record.id, selected_tool, relevance)
                ON CONFLICT (step_id, tool_id) DO UPDATE
                SET relevance_score = EXCLUDED.relevance_score,
                    updated_at = NOW();
                tool_counter := tool_counter + 1;
            END LOOP;
        END LOOP;
        IF (SELECT COUNT(*) FROM tool_recommendations WHERE step_id = step_record.id) < num_tools THEN
            INSERT INTO tool_recommendations (step_id, tool_id, relevance_score)
            SELECT
                step_record.id,
                t.id,
                round((4.0 + random() * 3.0)::numeric, 2) as relevance
            FROM tools t
            WHERE t.id NOT IN (SELECT tool_id FROM tool_recommendations WHERE step_id = step_record.id)
            ORDER BY random()
            LIMIT num_tools - (SELECT COUNT(*) FROM tool_recommendations WHERE step_id = step_record.id);
        END IF;
    END LOOP;
    RAISE NOTICE 'Seeding complete. Added recommendations for % steps and % tools', step_counter, tool_counter;
END;
$$;
SELECT seed_tool_recommendations();
SELECT COUNT(*) AS total_recommendations FROM tool_recommendations;
SELECT
    js.name AS step_name,
    t.name AS tool_name,
    t.category,
    tr.relevance_score
FROM tool_recommendations tr
JOIN journey_steps js ON tr.step_id = js.id
JOIN tools t ON tr.tool_id = t.id
ORDER BY js.name, tr.relevance_score DESC
LIMIT 20;

================
File: supabase/schema.sql
================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  full_name TEXT,
  company_id UUID REFERENCES public.companies(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.companies (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  industry TEXT,
  size TEXT,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.app_settings (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.idea_playground_canvases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  company_id UUID REFERENCES public.companies(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  description TEXT,
  is_archived BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.idea_playground_ideas (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  canvas_id UUID NOT NULL REFERENCES public.idea_playground_canvases(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  problem_statement TEXT NOT NULL,
  solution_concept TEXT NOT NULL,
  target_audience TEXT NOT NULL,
  unique_value TEXT NOT NULL,
  business_model TEXT NOT NULL,
  marketing_strategy TEXT NOT NULL,
  revenue_model TEXT NOT NULL,
  go_to_market TEXT NOT NULL,
  market_size TEXT NOT NULL,
  used_company_context BOOLEAN NOT NULL DEFAULT false,
  company_relevance JSONB,
  is_archived BOOLEAN NOT NULL DEFAULT false,
  version INTEGER NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.idea_playground_components (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  idea_id UUID NOT NULL REFERENCES public.idea_playground_ideas(id) ON DELETE CASCADE,
  component_type TEXT NOT NULL,
  content TEXT NOT NULL,
  is_selected BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.idea_playground_tags (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  idea_id UUID NOT NULL REFERENCES public.idea_playground_ideas(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.idea_playground_feedback (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  idea_id UUID NOT NULL REFERENCES public.idea_playground_ideas(id) ON DELETE CASCADE,
  feedback_type TEXT NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.llm_query_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  company_id UUID REFERENCES public.companies(id) ON DELETE SET NULL,
  query_text TEXT NOT NULL,
  response_length INTEGER NOT NULL,
  duration_ms INTEGER NOT NULL,
  models_used JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE OR REPLACE FUNCTION public.create_idea_playground_canvas(
  p_user_id UUID,
  p_company_id UUID DEFAULT NULL,
  p_name TEXT,
  p_description TEXT DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
  v_canvas_id UUID;
BEGIN
  INSERT INTO public.idea_playground_canvases (
    user_id,
    company_id,
    name,
    description
  ) VALUES (
    p_user_id,
    p_company_id,
    p_name,
    p_description
  ) RETURNING id INTO v_canvas_id;
  RETURN v_canvas_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION public.archive_idea_playground_canvas(
  p_canvas_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
  UPDATE public.idea_playground_canvases
  SET is_archived = true,
      updated_at = NOW()
  WHERE id = p_canvas_id;
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION public.duplicate_idea_playground_idea(
  p_idea_id UUID,
  p_new_title TEXT DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
  v_original_idea public.idea_playground_ideas%ROWTYPE;
  v_new_idea_id UUID;
  v_component public.idea_playground_components%ROWTYPE;
  v_tag public.idea_playground_tags%ROWTYPE;
BEGIN
  SELECT * INTO v_original_idea
  FROM public.idea_playground_ideas
  WHERE id = p_idea_id;
  INSERT INTO public.idea_playground_ideas (
    canvas_id,
    title,
    description,
    problem_statement,
    solution_concept,
    target_audience,
    unique_value,
    business_model,
    marketing_strategy,
    revenue_model,
    go_to_market,
    market_size,
    used_company_context,
    company_relevance,
    version
  ) VALUES (
    v_original_idea.canvas_id,
    COALESCE(p_new_title, v_original_idea.title || ' (Copy)'),
    v_original_idea.description,
    v_original_idea.problem_statement,
    v_original_idea.solution_concept,
    v_original_idea.target_audience,
    v_original_idea.unique_value,
    v_original_idea.business_model,
    v_original_idea.marketing_strategy,
    v_original_idea.revenue_model,
    v_original_idea.go_to_market,
    v_original_idea.market_size,
    v_original_idea.used_company_context,
    v_original_idea.company_relevance,
    v_original_idea.version
  ) RETURNING id INTO v_new_idea_id;
  FOR v_component IN
    SELECT * FROM public.idea_playground_components
    WHERE idea_id = p_idea_id
  LOOP
    INSERT INTO public.idea_playground_components (
      idea_id,
      component_type,
      content,
      is_selected
    ) VALUES (
      v_new_idea_id,
      v_component.component_type,
      v_component.content,
      v_component.is_selected
    );
  END LOOP;
  FOR v_tag IN
    SELECT * FROM public.idea_playground_tags
    WHERE idea_id = p_idea_id
  LOOP
    INSERT INTO public.idea_playground_tags (
      idea_id,
      name
    ) VALUES (
      v_new_idea_id,
      v_tag.name
    );
  END LOOP;
  RETURN v_new_idea_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION public.move_idea_to_canvas(
  p_idea_id UUID,
  p_target_canvas_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
  UPDATE public.idea_playground_ideas
  SET canvas_id = p_target_canvas_id,
      updated_at = NOW()
  WHERE id = p_idea_id;
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION public.archive_idea_playground_idea(
  p_idea_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
  UPDATE public.idea_playground_ideas
  SET is_archived = true,
      updated_at = NOW()
  WHERE id = p_idea_id;
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.idea_playground_canvases ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.idea_playground_ideas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.idea_playground_components ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.idea_playground_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.idea_playground_feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.llm_query_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own profile"
  ON public.profiles
  FOR SELECT
  USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile"
  ON public.profiles
  FOR UPDATE
  USING (auth.uid() = id);
CREATE POLICY "Users can view companies"
  ON public.companies
  FOR SELECT
  USING (true);
CREATE POLICY "Users can create companies"
  ON public.companies
  FOR INSERT
  WITH CHECK (true);
CREATE POLICY "Users can update companies they created"
  ON public.companies
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE company_id = id AND profiles.id = auth.uid()
    )
  );
CREATE POLICY "Admin users can view app settings"
  ON public.app_settings
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND is_admin = true
    )
  );
CREATE POLICY "Admin users can update app settings"
  ON public.app_settings
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND is_admin = true
    )
  );
CREATE POLICY "Users can view their own canvases"
  ON public.idea_playground_canvases
  FOR SELECT
  USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own canvases"
  ON public.idea_playground_canvases
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own canvases"
  ON public.idea_playground_canvases
  FOR UPDATE
  USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own canvases"
  ON public.idea_playground_canvases
  FOR DELETE
  USING (auth.uid() = user_id);
CREATE POLICY "Users can view ideas in their canvases"
  ON public.idea_playground_ideas
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_canvases
      WHERE id = canvas_id AND user_id = auth.uid()
    )
  );
CREATE POLICY "Users can create ideas in their canvases"
  ON public.idea_playground_ideas
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.idea_playground_canvases
      WHERE id = canvas_id AND user_id = auth.uid()
    )
  );
CREATE POLICY "Users can update ideas in their canvases"
  ON public.idea_playground_ideas
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_canvases
      WHERE id = canvas_id AND user_id = auth.uid()
    )
  );
CREATE POLICY "Users can delete ideas in their canvases"
  ON public.idea_playground_ideas
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_canvases
      WHERE id = canvas_id AND user_id = auth.uid()
    )
  );
CREATE POLICY "Users can view components of ideas in their canvases"
  ON public.idea_playground_components
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can create components for ideas in their canvases"
  ON public.idea_playground_components
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can update components of ideas in their canvases"
  ON public.idea_playground_components
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can delete components of ideas in their canvases"
  ON public.idea_playground_components
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can view tags of ideas in their canvases"
  ON public.idea_playground_tags
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can create tags for ideas in their canvases"
  ON public.idea_playground_tags
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can delete tags of ideas in their canvases"
  ON public.idea_playground_tags
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can view feedback on ideas in their canvases"
  ON public.idea_playground_feedback
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can create feedback for ideas in their canvases"
  ON public.idea_playground_feedback
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.idea_playground_ideas
      JOIN public.idea_playground_canvases ON idea_playground_ideas.canvas_id = idea_playground_canvases.id
      WHERE idea_playground_ideas.id = idea_id AND idea_playground_canvases.user_id = auth.uid()
    )
  );
CREATE POLICY "Users can view their own query logs"
  ON public.llm_query_logs
  FOR SELECT
  USING (auth.uid() = user_id);
CREATE POLICY "System can insert query logs"
  ON public.llm_query_logs
  FOR INSERT
  WITH CHECK (true);
CREATE INDEX IF NOT EXISTS profiles_company_id_idx ON public.profiles (company_id);
CREATE INDEX IF NOT EXISTS idea_playground_canvases_user_id_idx ON public.idea_playground_canvases (user_id);
CREATE INDEX IF NOT EXISTS idea_playground_canvases_company_id_idx ON public.idea_playground_canvases (company_id);
CREATE INDEX IF NOT EXISTS idea_playground_canvases_is_archived_idx ON public.idea_playground_canvases (is_archived);
CREATE INDEX IF NOT EXISTS idea_playground_ideas_canvas_id_idx ON public.idea_playground_ideas (canvas_id);
CREATE INDEX IF NOT EXISTS idea_playground_ideas_is_archived_idx ON public.idea_playground_ideas (is_archived);
CREATE INDEX IF NOT EXISTS idea_playground_ideas_used_company_context_idx ON public.idea_playground_ideas (used_company_context);
CREATE INDEX IF NOT EXISTS idea_playground_components_idea_id_idx ON public.idea_playground_components (idea_id);
CREATE INDEX IF NOT EXISTS idea_playground_components_component_type_idx ON public.idea_playground_components (component_type);
CREATE INDEX IF NOT EXISTS idea_playground_tags_idea_id_idx ON public.idea_playground_tags (idea_id);
CREATE INDEX IF NOT EXISTS idea_playground_tags_name_idx ON public.idea_playground_tags (name);
CREATE INDEX IF NOT EXISTS idea_playground_feedback_idea_id_idx ON public.idea_playground_feedback (idea_id);
CREATE INDEX IF NOT EXISTS idea_playground_feedback_feedback_type_idx ON public.idea_playground_feedback (feedback_type);
CREATE INDEX IF NOT EXISTS llm_query_logs_user_id_idx ON public.llm_query_logs (user_id);
CREATE INDEX IF NOT EXISTS llm_query_logs_company_id_idx ON public.llm_query_logs (company_id);
CREATE INDEX IF NOT EXISTS llm_query_logs_created_at_idx ON public.llm_query_logs (created_at);

================
File: .gitignore
================
# Dependencies
/node_modules
/.pnp
.pnp.js

# Testing
/coverage

# Production
/build
/dist

# Misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local
.env

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
*.log

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Backup and archive directories
/archive/
/backup/
/backup_20250316095214/
/.bolt/

# Fix scripts and utility scripts
fix-*.js
fix-*.sh
run-*.sh
restart-*.sh

# Temporary files
.tmp
.temp

================
File: CLOUD-INTEGRATION-GUIDE.md
================
# Cloud LLM Microservice Integration Guide

This guide explains how to configure your Wheel99 application to use the Hugging Face LLM microservice deployed to Google Cloud Platform.

## 1. Update Environment Variables

After deploying the LLM microservice to GCP Cloud Run, you'll receive a service URL. Add this URL to your `.env` file:

```
# LLM Microservice URL (replace with your actual Cloud Run URL)
VITE_LLM_SERVICE_URL=https://llm-service-abcd1234-uc.a.run.app/api
```

## 2. Enable Hugging Face Feature Flags

You can enable the Hugging Face integration in two ways:

### Option 1: Via Environment Variables

Add these variables to your `.env` file:

```
# Enable Hugging Face integration
VITE_USE_HUGGINGFACE=true

# Optionally enable specific models
VITE_USE_HF_COMPANY_MODEL=true
VITE_USE_HF_ABSTRACTION_MODEL=true
```

### Option 2: Via Settings UI

1. Navigate to your application settings
2. Find the LLM Provider Settings section
3. Toggle "Use Hugging Face" to ON
4. Optionally, toggle specific models:
   - "Use Company-Specific Model" 
   - "Use Abstraction Model"

## 3. Test the Integration

You can test the integration using the following methods:

### Using the Test Component

1. Navigate to the LLM Provider Test page in your application
2. Ensure "Hugging Face" is selected as the provider
3. Enter a test prompt and click "Generate Response"
4. Verify the response comes from the cloud-deployed service

### Using the API Directly

Execute a test API call:

```javascript
import { generalLLMService } from '../lib/services/general-llm.service';

// Test the service
async function testService() {
  try {
    const response = await generalLLMService.query(
      'Write a brief introduction about artificial intelligence',
      {
        userId: 'test-user-id',
        useCompanyModel: true
      }
    );
    console.log('Response:', response.content);
  } catch (error) {
    console.error('Error:', error);
  }
}
```

## 4. Verify Connection

Check the connection with the deployed service:

1. Open your browser console
2. Look for network requests to your Cloud Run URL
3. Verify the responses have status code 200
4. Check for any CORS errors in the console

## 5. Managing Cloud Service Environment Variables

If you need to update the LLM microservice configuration after deployment (such as CORS settings), you can do so directly in the Google Cloud Console:

### Updating CORS Configuration

1. **Navigate to the Cloud Run service:**
   - Go to [Google Cloud Console](https://console.cloud.google.com/)
   - Select your project
   - Go to Cloud Run in the left sidebar
   - Click on your "llm-service" deployment

2. **Update environment variables:**
   - Click on the "Variables & Secrets" tab
   - Click the "Edit" button
   - Find the `ALLOWED_ORIGINS` variable
   - Update its value to include your domain(s), such as:
     ```
     https://yourdomain.com,https://app.yourdomain.com
     ```
   - Click "Deploy" to apply changes

3. **Verify your changes:**
   - A new revision will be created with the updated settings
   - Cloud Run will automatically route traffic to the new revision
   - Test your application again to ensure CORS issues are resolved

### Managing API Keys

You can update the Hugging Face API key and other sensitive variables:

1. **Via direct environment variables:**
   - Navigate to the service as described above
   - Edit the `HUGGINGFACE_API_KEY` variable
   - Enter the new API key value
   - Deploy the changes

2. **Using Secret Manager (recommended):**
   - First, store your API key in Secret Manager:
     ```bash
     gcloud secrets create HUGGINGFACE_API_KEY --replication-policy="automatic"
     echo -n "your-api-key-here" | gcloud secrets versions add HUGGINGFACE_API_KEY --data-file=-
     ```
   - In the Cloud Run console, go to Variables & Secrets
   - Click "Edit" and then "Add Reference to Secret"
   - Configure the reference to use your HUGGINGFACE_API_KEY secret
   - Deploy the changes

## 6. CI/CD Integration for Production

For production deployments, consider setting up CI/CD pipelines to automate updates to both your Wheel99 application and the LLM microservice:

### GitHub Actions Integration

Add a GitHub Actions workflow for your Wheel99 application:

```yaml
name: Deploy Wheel99 to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build application
        run: |
          npm run build
          # Set the LLM service URL and enable Hugging Face
          echo "VITE_LLM_SERVICE_URL=${{ secrets.LLM_SERVICE_URL }}" >> .env.production
          echo "VITE_USE_HUGGINGFACE=true" >> .env.production
          echo "VITE_USE_HF_COMPANY_MODEL=true" >> .env.production
          
      - name: Deploy to hosting provider
        # Add your deployment steps here (Firebase, Netlify, etc.)
```

### Automated End-to-End Testing

Add comprehensive testing to your CI/CD pipeline:

```yaml
  test_integration:
    needs: build_and_deploy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run integration tests
        run: |
          # Set the environment variables for testing
          echo "VITE_LLM_SERVICE_URL=${{ secrets.LLM_SERVICE_URL }}" >> .env.test
          echo "VITE_USE_HUGGINGFACE=true" >> .env.test
          npm run test:integration
```

## 7. Troubleshooting

### Connection Issues

If you can't connect to the microservice:

1. Verify the VITE_LLM_SERVICE_URL is correct
2. Check that the Cloud Run service is running
3. Ensure your domain is in the allowed CORS origins
4. Try accessing the service health endpoint directly: `https://your-service-url/health`

### CORS Errors

If you see CORS errors:

1. Make sure your domain is included in the ALLOWED_ORIGINS environment variable on the Cloud Run service
2. Update the environment variable in the Cloud Run console as described in Section 5
3. Check that your application is making requests from the expected domain
4. For local development, you may need to add `http://localhost:3000` or similar to ALLOWED_ORIGINS

### Authentication Errors

If you receive authentication errors:

1. Verify that the Hugging Face API key is correctly set in the Cloud Run service
2. Check the Cloud Run logs for detailed error messages
3. Update the API key using the Cloud Run console if needed

### Feature Flag Issues

If the feature flags aren't working:

1. Restart your application after changing environment variables
2. Check that the variables are correctly named and formatted
3. Try toggling the flags in the UI instead of using environment variables

## 8. Costs and Scaling

Keep in mind:

1. Cloud Run charges based on usage (requests and compute time)
2. Set up budget alerts in Google Cloud to monitor spending
3. Consider adjusting the memory/CPU allocation if needed
4. For production, consider setting up autoscaling with minimum instances = 1 to avoid cold starts

## Need Help?

If you encounter any issues deploying or connecting to the LLM microservice, refer to:

1. GCP-DEPLOYMENT-GUIDE.md in the llm-service directory
2. Cloud Run documentation: https://cloud.google.com/run/docs
3. Hugging Face documentation: https://huggingface.co/docs

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: eslint.config.js
================
export default tseslint.config(

================
File: index.html
================
<!doctype html>
<html lang="en" data-theme="corporate">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wheel99 - Startup Platform</title>
    <script>
      // Add a global error handler to catch initialization errors
      window.addEventListener('error', function(event) {
        console.error('Global error caught:', event.message);
        // Show recovery UI if the app fails to load after 10 seconds
        setTimeout(function() {
          if (!window.appLoaded) {
            var recoveryDiv = document.createElement('div');
            recoveryDiv.id = 'recovery-ui';
            recoveryDiv.style.position = 'fixed';
            recoveryDiv.style.bottom = '20px';
            recoveryDiv.style.right = '20px';
            recoveryDiv.style.backgroundColor = '#f8d7da';
            recoveryDiv.style.color = '#721c24';
            recoveryDiv.style.padding = '10px 15px';
            recoveryDiv.style.borderRadius = '4px';
            recoveryDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            recoveryDiv.style.zIndex = '9999';
            recoveryDiv.innerHTML = '<h3 style="margin: 0 0 10px 0">Dashboard Recovery</h3>' +
              '<p style="margin: 0 0 10px 0">If the dashboard is not loading properly, click the button below to fix common issues:</p>' +
              '<button id="fix-dashboard-btn" style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer">Fix Dashboard</button>';
            document.body.appendChild(recoveryDiv);
            document.getElementById('fix-dashboard-btn').addEventListener('click', function() {
              var script = document.createElement('script');
              script.src = '/scripts/fix-dashboard-loading.js';
              document.head.appendChild(script);
              this.disabled = true;
              this.textContent = 'Fixing...';
              setTimeout(() => {
                this.textContent = 'Reloading...';
                window.location.reload();
              }, 2000);
            });
          }
        }, 10000);
      });
      // Set a flag when the app has loaded successfully
      window.addEventListener('load', function() {
        setTimeout(function() {
          window.appLoaded = true;
        }, 1000);
      });
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: jest.config.js
================


================
File: journey_map_implementation_plan.md
================
# Journey Map Implementation Plan

## Overview

This document outlines the implementation plan for enhancing the Journey Map functionality in The Wheel platform. The Journey Map is a core feature that guides founders through the startup process with personalized recommendations, tools, and resources.

## Database Enhancements

We've implemented the following database enhancements in `supabase/migrations/20250428123000_enhance_journey_map_and_tools.sql`:

1. **Company Profile Fields for Tool Personalization**
   - Added fields to the `companies` table: `industry`, `company_size`, `funding_stage`, and `tech_stack`
   - These fields will be used to personalize tool recommendations

2. **Tool Ranking System**
   - Created `journey_step_tool_rankings` table to store personalized tool rankings based on company profile
   - Added `default_ranking` column to `journey_step_tools` table

3. **Step-Tool Association**
   - Added `step_id` to `company_tool_evaluations` to track which step a tool is being evaluated for

4. **AI Review for Custom Tools**
   - Added `ai_review_status` and `user_edited_description` to `tool_submissions` table

5. **Database Functions**
   - Created `get_personalized_tool_rankings` function to retrieve personalized tool recommendations
   - Created `has_sufficient_profile_data` function to check if a company has enough profile data for personalization

## Service Layer Enhancements

We've enhanced the `companyJourney.service.ts` with the following functionality:

1. **Step Management**
   - `skipStep`: Allow users to skip steps they don't need
   - `markStepComplete`: Mark steps as completed
   - `addFocusArea` and `removeFocusArea`: Manage focus areas

2. **Tool Recommendations**
   - `getPersonalizedToolRecommendations`: Get personalized tool recommendations based on company profile
   - `hasSufficientProfileData`: Check if company has enough profile data for personalization
   - `getStepTools`: Get all tools for a step

3. **Custom Tool Management**
   - `submitCustomTool`: Submit a custom tool for a journey step
   - `updateCustomToolDescription`: Update AI-generated description
   - `addCustomToolToCompany`: Add a custom tool to the company's toolset

## UI Enhancements

We've enhanced the `JourneyStepDetails.tsx` component with the following features:

1. **Step Management**
   - Skip step functionality
   - Mark step as complete
   - Toggle focus area

2. **Step Content Display**
   - Guidance section with detailed explanation
   - Checklists for step completion requirements
   - Options for different approaches to the step
   - Tips for best practices
   - Resources (links, documents) for additional information
   - User notes for personal observations and planning

3. **Tool Recommendations**
   - Display personalized tool recommendations
   - Show/hide additional tools
   - Alert for incomplete company profile

4. **Custom Tool Submission**
   - Form for submitting custom tools
   - AI-generated description review
   - Accept/edit/reject AI-generated descriptions

5. **Feedback Collection**
   - Rating and comment submission for steps
   - Success confirmation

## Next Steps

1. **Journey Map UI Improvements**
   - Update the main Journey Map view to show step completion status
   - Add visual indicators for focus areas
   - Improve navigation between steps and phases
   - Ensure proper layout of step details with content before action choices

2. **User Notes Feature**
   - Add a dedicated notes section to the step details page
   - Implement save/load functionality for notes using the company_progress.notes field
   - Add auto-save functionality for notes

3. **Company Profile Enhancement**
   - Create or update the company profile page to collect industry, size, and funding stage
   - Implement profile completeness indicator

4. **Admin Tool Management**
   - Complete the tool submission moderation interface
   - Implement the tool ranking management interface

5. **AI Integration**
   - Implement the AI enrichment service for custom tool descriptions
   - Set up webhooks for AI processing notifications

6. **Analytics**
   - Track step completion rates
   - Monitor tool usage and effectiveness
   - Analyze feedback for continuous improvement

7. **Testing**
   - Unit tests for new service methods
   - Integration tests for the personalization algorithm
   - User acceptance testing for the enhanced UI

## Implementation Timeline

1. **Phase 1: Database & Service Layer (Completed)**
   - Database schema updates
   - Core service methods

2. **Phase 2: UI Implementation (In Progress)**
   - Journey step details enhancements
   - Tool recommendation UI
   - Custom tool submission flow

3. **Phase 3: AI Integration (Next)**
   - Custom tool description generation
   - Personalization algorithm refinement

4. **Phase 4: Admin Tools & Analytics (Future)**
   - Tool moderation interface
   - Analytics dashboard
   - Feedback analysis tools

================
File: journey_map_mvp_status.md
================
# Journey Map MVP Status Assessment

## Overview

This document assesses the current status of the Journey Map functionality against the MVP requirements outlined in the feature review. It identifies completed items, work in progress, and remaining tasks.

## Status Key

- [] Functionally Complete: Meets the MVP requirement; ready for integration testing/final QA.
- [+/-] Partially Built: Some relevant code exists, but it's incomplete or not functional.
- [~] Built - Needs Cleanup/Refactor: Functionality broadly exists but needs significant rework.
- [ ] Not Started: No significant work done on this specific feature.

## Backend Requirements

### Data Model (Phases, Steps, Guidance, Tools, Options, Action Flags)

**Status: [] Functionally Complete**

- Database schema for journey phases, steps, guidance, tools, options, and action flags is in place
- Relationships between entities are properly defined
- Action flags for conditional features (Ask Wheel, Ask Expert) are implemented

### Content Loading Mechanism

**Status: [+/-] Partially Built**

- Basic import script exists (`scripts/import-journey-excel.cjs`)
- Need to enhance with support for new fields like tool rankings
- Admin UI for content management is still in development

### Tool Database Model/Loading

**Status: [+/-] Partially Built**

- Database schema for tools is in place
- Tool ranking system has been implemented
- Need to complete the loading mechanism for tool data with rankings

## Frontend Requirements

### UI for Browsing Full Map

**Status: [+/-] Partially Built**

- Basic map view is implemented
- Need to integrate step completion status and focus area indicators
- Need to enhance navigation between steps/phases

### UI for Viewing Step Details

**Status: [] Functionally Complete**

- Step details view shows title, goal, guidance, and options
- UI displays structured options for approaching steps
- Navigation between steps is functional
- Content is properly organized before action choices
- User notes section for personal observations is implemented

### UI for User Notes

**Status: [] Functionally Complete**

- Notes section implemented in step details
- Save/load functionality using company_progress.notes field implemented
- Auto-save functionality implemented with 2-second delay

### UI for Step Feedback Input

**Status: [] Functionally Complete**

- Feedback form with rating and comments is implemented
- Submission confirmation is displayed
- Backend storage for feedback is in place
- Note: This is for platform improvement feedback, not user notes

### UI Displaying Action Choices (Conditional)

**Status: [+/-] Partially Built**

- Basic action choices UI is implemented
- Conditional display based on step flags is working
- Need to complete integration with the tool recommendation system

## Action Choice: "Use a Tool"

### Personalized Tool Recommendation Logic

**Status: [] Functionally Complete**

- Backend logic for personalized recommendations is implemented
- Company profile data is used for personalization
- Default ranking fallback is in place

### Display Recommended Tools

**Status: [] Functionally Complete**

- Top 3 recommended tools are displayed
- Option to view all tools is available
- Tool cards show name, description, and actions

### Custom Tool Input UI

**Status: [] Functionally Complete**

- Form for adding custom tools is implemented
- Fields for name, URL, and functionality are available
- Submission process is working

### Trigger Custom Tool Card Generation

**Status: [+/-] Partially Built**

- Backend structure for AI generation is in place
- Need to implement the actual AI service integration
- Placeholder simulation is currently used

### Card Generation Logic (Public Info Only)

**Status: [+/-] Partially Built**

- Structure for AI-generated descriptions is in place
- Need to implement the actual AI service that respects public info constraint
- Placeholder generation is currently used

### Present AI-Generated Card for Review

**Status: [] Functionally Complete**

- UI for reviewing AI-generated descriptions is implemented
- Clear indication that content is AI-generated
- Handling for generation failure is in place

### User Actions on Generated Card

**Status: [] Functionally Complete**

- Accept/Reject/Regenerate options are implemented
- Editing capability for AI-generated content is available
- Success/failure states are properly handled

### Store Accepted Custom Tool Data

**Status: [] Functionally Complete**

- Backend storage for custom tools is implemented
- Association with user/venture/step is working
- Retrieval of saved custom tools is functional

## Action Choice: "I'll Do This Myself"

**Status: [] Functionally Complete**

- UI button is implemented with proper styling and icon
- State tracking is implemented with 'diy' status in company_progress
- Button is conditionally displayed based on step status and diy_enabled flag
- Visual indication when the step is in 'diy' status

## Action Choice: "Ask an Expert"

**Status: [] Functionally Complete**

- Conditional display based on step flags is working
- Button is properly styled with appropriate icon
- Modal with "Coming Soon" message is implemented
- Button is hidden when not applicable based on step status and ask_expert_enabled flag

## Action Choice: "Ask The Wheel"

### UI for Submitting Request

**Status: [] Functionally Complete**

- Modal with form for submitting questions is implemented
- Success message is displayed after submission
- Placeholder implementation for MVP is in place
- Clearly labeled as a demo feature

### Capture & Route Request

**Status: [+/-] Partially Built**

- Placeholder implementation for MVP is in place
- Backend service for actual request capture and routing will be implemented in the next phase

## Step Completion

### UI for Manual Step Completion

**Status: [] Functionally Complete**

- Button for marking steps as complete is implemented
- Visual indication of completion status is in place
- Special handling for company formation step is working

## Main Journey Map View

### UI for Browsing Full Map with Status Indicators

**Status: [+/-] Partially Built**

- Basic map view is implemented
- **Missing**: Visual indicators for step completion status
- **Missing**: Visual indicators for focus areas
- **Missing**: Enhanced navigation between steps/phases

## Next Steps

1. **Enhance Main Journey Map View**
   - Add visual indicators for step completion status
   - Add visual indicators for focus areas
   - Improve navigation between steps/phases

4. **Complete Content Loading Mechanism**
   - Enhance import script to support new fields
   - Develop admin UI for content management

5. **Finish Tool Recommendation System**
   - Complete the AI integration for custom tool descriptions
   - Implement the tool ranking management interface

6. **Future Enhancements**
   - Implement actual backend service for "Ask The Wheel" request capture and routing

7. **Testing and QA**
   - Conduct integration testing for the entire journey flow
   - Perform user acceptance testing for the enhanced UI

================
File: journey_map_task_integration_plan.md
================
# Journey Map & Task Integration: Detailed Implementation Plan

---

## 0. Excel File Analysis & Import

**0.1. Analyze the Excel File**
- Review `tools and steps (1).xlsx` to understand its structure: sheets, columns, data types, and relationships (phases, steps, options, tools, resources, tips, checklists).
- Map Excel columns to the database schema, identifying any schema gaps or mismatches.

### 0.1.a. Excel-to-Database Mapping

#### Sheet: PhasesandSteps
| Excel Column                  | Target Table      | Target Field                | Notes                                                      |
|-------------------------------|-------------------|-----------------------------|------------------------------------------------------------|
| Phase                         | phases            | id / order                  | Integer, phase order or ID                                 |
| Phase Name                    | phases            | name                        | Name of the phase                                          |
| Step                          | steps             | id / order                  | Integer, step order or ID                                  |
| Task                          | steps             | name / description          | Name or description of the step                            |
| Need to Do? (Yes/No)          | steps             | required                    | Boolean or enum                                            |
| Explanation for Need          | steps             | need_explanation            | Text                                                       |
| Dedicated Tool? (Yes/No)      | steps             | has_tool                    | Boolean or enum                                            |
| Explanation for Tool Need     | steps             | tool_explanation            | Text                                                       |
| Steps w/o Tool                | steps             | steps_without_tool          | Text or array                                              |
| Effort/Difficulty             | steps             | effort_difficulty           | Enum or text                                               |
| Staff/Freelancers (Optional)  | steps             | staff_freelancers           | Text                                                       |
| Key Considerations            | steps             | key_considerations          | Text                                                       |
| Bootstrap Mindset             | steps             | bootstrap_mindset           | Text                                                       |
| Founder Skills Needed         | steps             | founder_skills_needed       | Text                                                       |

#### Sheet: toolsbystep
| Excel Column                  | Target Table      | Target Field                | Notes                                                      |
|-------------------------------|-------------------|-----------------------------|------------------------------------------------------------|
| Step                          | step_tools        | step_id                     | Foreign key to steps                                       |
| Tool (Name)                   | tools             | name                        | Name of the tool                                           |
| Category                      | tools             | category                    | Tool category                                              |
| Subcategory                   | tools             | subcategory                 | Tool subcategory                                           |
| Website                       | tools             | website                     | Tool website URL                                           |
| Summary                       | tools             | summary                     | Short description                                          |
| Pros                          | tools             | pros                        | Text                                                       |
| Cons                          | tools             | cons                        | Text                                                       |
| Usual Customer Stage          | tools             | customer_stage              | Text                                                       |
| Founded                       | tools             | founded                     | Year or text                                               |
| Last Funding Round            | tools             | last_funding_round          | Text                                                       |
| Comp. Svc. Pkg. (1-3)         | tools             | comp_svc_pkg                | Integer rating                                             |
| Ease of Use (1-3)             | tools             | ease_of_use                 | Integer rating                                             |
| Affordability (1-3)           | tools             | affordability               | Integer rating                                             |
| Customer Support (1-3)        | tools             | customer_support            | Integer rating                                             |
| Speed of Setup (1-3)          | tools             | speed_of_setup              | Integer rating                                             |
| Customization (1-3)           | tools             | customization               | Integer rating                                             |
| Range of Services (1-3)       | tools             | range_of_services           | Integer rating                                             |
| Integration (1-3)             | tools             | integration                 | Integer rating                                             |
| Pro. Assistance (1-3)         | tools             | pro_assistance              | Integer rating                                             |
| Reputation (1-3)              | tools             | reputation                  | Integer rating                                             |
| Reasoning: ...                | tools             | reasoning_*                 | Reasoning for each rating, text fields                     |

- Relationships:
  - Each phase has multiple steps.
  - Each step may have multiple tools (many-to-many via step_tools).
  - Additional fields may be needed for options, resources, tips, checklists (not shown in sample rows).

- **Schema Gaps:** Review for missing fields in the current DB schema, especially for reasoning fields, staff/freelancers, and any checklist/resource/tip columns not shown in the sample.

**0.2. Build Import Functionality**
- Implement a backend service or script to parse the Excel file and import its data into the database.
  - Use a library such as `xlsx` (Node.js) or equivalent.
  - Validate data during import (required fields, referential integrity, duplicates).
  - Support both initial import and updates (idempotency/versioning as needed).

**0.3. Admin UI for Import/Export**
- In the admin content management tool, provide:
  - "Import from Excel/CSV" feature for uploading and importing journey content.
  - "Export to Excel/CSV" feature for backup and offline editing.

**0.4. Testing & Validation**
- After import, verify that all data from the Excel file is present and correctly mapped in the admin UI.
- Ensure imported data is editable and relationships (e.g., prerequisites, tool associations) are preserved.

---

### Progress Log

- [x] Implementation plan documented and saved.
- [x] Excel file structure analyzed and mapped to schema.
- [x] Schema migration SQL written for missing fields (supabase/migrations/20250427_add_journey_excel_fields.sql).
- [x] Import script scaffolded (scripts/import-journey-excel.cjs).
- [x] Admin content management UI: Scaffold CRUD, import/export, and inline editing for journey content.
- [ ] Backend endpoints for CRUD, import/export, and linking logic.
- [ ] Frontend integration and state management.
- [ ] Testing and QA.

---

## 1. Schema & Backend Preparation

- Add `prerequisite_steps` column to `journey_steps`.
- Ensure `company_progress` (or equivalent) can record "DIY" actions.
- Update task and journey step tables to support linking.
- Ensure all necessary fields for admin content management are present.
- Write and apply SQL migrations for all schema changes.

---

## 2. Backend Services

- Add/extend endpoints for task linking/unlinking, listing, and filtering.
- Endpoints for AI task review and marking as reviewed/linked.
- Endpoints for recording "DIY" actions and logging.
- Endpoint to fetch prerequisite/related steps.
- CRUD endpoints for all journey content, import/export, inline editing, and (optionally) versioning.

---

## 3. Frontend Components

- Task Manager: Link/unlink tasks, AI task review prompt, context indicators, "Review AI Tasks" filter.
- Journey Step View: "Attach Existing Task" button, linked tasks list, DIY action button.
- Step Card: Display prerequisites/related steps.
- Admin Content Management: Full CRUD UI, import/export, inline editing, (optional) versioning.

---

## 4. Integration & State Management

- Update global state/store for task-step associations, AI task review, DIY actions, prerequisites.
- Connect frontend components to backend endpoints with optimistic UI and error handling.

---

## 5. Testing & QA

- Unit/integration tests for backend endpoints and frontend flows.
- End-to-end testing of user flows, import/export, and data validation.
- Ensure all journey content from Excel is present and editable via the admin tool.

---

## 6. Launch & Iteration

- Prioritize admin tool for launch or immediate post-launch.
- Monitor usage and collect feedback for improvements.

---

### Visual Overview

```mermaid
flowchart TD
    subgraph Excel[Excel Import]
        X1[Analyze Excel File]
        X2[Build Import Functionality]
        X3[Admin Import/Export UI]
        X4[Testing & Validation]
    end
    subgraph DB[Database]
        A1[Update Schema: prerequisite_steps, task links, DIY]
    end
    subgraph Backend
        B1[Task Linking Endpoints]
        B2[AI Task Review Endpoints]
        B3[DIY Action Endpoints]
        B4[Prerequisite Steps Endpoint]
        B5[Admin Content CRUD]
    end
    subgraph Frontend
        F1[Task Manager: Link/Unlink, AI Review]
        F2[Journey Step View: Attach Task, DIY, Linked Tasks]
        F3[Step Card: Prerequisites]
        F4[Admin Content Management UI]
    end
    subgraph Integration
        I1[State Management]
        I2[API Integration]
    end
    subgraph QA
        Q1[Unit/Integration Tests]
        Q2[E2E Testing]
        Q3[Data Validation]
    end

    X1 --> X2 --> X3 --> X4 --> A1
    A1 --> B1
    A1 --> B2
    A1 --> B3
    A1 --> B4
    A1 --> B5
    B1 --> F1
    B2 --> F1
    B3 --> F2
    B4 --> F3
    B5 --> F4
    F1 --> I1
    F2 --> I1
    F3 --> I1
    F4 --> I1
    I1 --> I2
    I2 --> Q1
    I2 --> Q2
    I2 --> Q3
```

---

**Summary:**  
This plan covers all steps for journey map and task integration, including Excel import, schema, backend, frontend, integration, testing, and launch.

================
File: journey_map_track_manually_implementation.md
================
# Track Manually Implementation

This document outlines the changes made to replace the "I'll Do This Myself" button with a "Track Manually" button in the Journey Map module, as per the MVP requirements.

## Overview

The key difference between the old "I'll Do This Myself" and the new "Track Manually" functionality is:

- **I'll Do This Myself (Old)**: Was intended to change the step status to 'diy' in the database (though it appears this status may not have been properly implemented in the database schema)
- **Track Manually (New)**: Does not change the step status, but provides a UI element for users to indicate they're handling the step manually

## Changes Made

### 1. Frontend Component Updates

**File: `src/components/company/journey/JourneyStepDetails.tsx`**
- Removed the `handleMarkDiy` function
- Replaced the "I'll Do This Myself" button with a "Track Manually" button
- The new button doesn't change the step status in the database
- The button is still visible only when the step is not completed or skipped

### 2. Type Definition Updates

**File: `src/lib/types/journey.types.ts`**
- Removed 'diy' from the `journey_step_status` type:
```typescript
// Old
export type journey_step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped' | 'diy';

// New
export type journey_step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped';
```

### 3. Service Updates

**File: `src/lib/services/companyJourney.service.ts`**
- Removed the `markStepDiy` method that was previously used to update the step status to 'diy'
- Updated the local type definition to match the changes in journey.types.ts:
```typescript
// Old
type journey_step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped' | 'diy';

// New
type journey_step_status = 'not_started' | 'in_progress' | 'completed' | 'skipped';
```

### 4. Database Schema Updates

**File: `supabase/migrations/20250428155000_remove_diy_status.sql`**
- Created a migration to update the database schema if needed:
  - Checks if 'diy' exists in the journey_step_status enum
  - If it exists:
    - Creates a new enum type without 'diy'
    - Updates existing records with 'diy' status to 'in_progress'
    - Alters tables to use the new enum type
    - Drops the old enum type
    - Renames the new type to the original name
  - If it doesn't exist:
    - Simply adds a comment to the existing enum type

## Implementation Notes

- The "Track Manually" button is now a UI-only element that doesn't change the database state
- This aligns with the MVP requirements to simplify the journey step status tracking
- Any existing steps that were previously marked as 'diy' will now show as 'in_progress' (if the 'diy' status was actually used in the database)
- The button is still conditionally displayed based on the step's current status
- It appears that there may have been a discrepancy between the TypeScript types and the actual database schema, where 'diy' was defined in the TypeScript types but may not have been properly implemented in the database

## Future Considerations

- If tracking of manually handled steps becomes a requirement, we could add a separate boolean flag in the company_progress table
- This would allow tracking which steps are being handled manually without affecting the main status flow

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Alie

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: mvp-feature-review.md
================
# The Wheel - MVP Feature Review

This document provides a comprehensive review of the codebase against the MVP requirements, identifying the status of each feature and any gaps that need to be addressed.

## Status Key
- [ ] **Not Started**: No significant work done on this specific feature.
- [+/-] **Partially Built**: Some relevant code exists, but it's incomplete or not functional.
- [~] **Built - Needs Cleanup/Refactor**: The functionality broadly exists but is known to be messy, inefficient, buggy, or needs significant rework for the MVP integration.
- [] **Functionally Complete**: Believed to meet the MVP requirement; ready for integration testing/final QA.
- [>>] **Exceeds MVP**: Functionality exists and offers significantly more than the basic MVP requirement described.
- [?] **Status Unknown / Needs Verification**: Uncertainty exists about the feature's status or implementation details.

---

## 1. Identity & Authentication

### Secure User Signup
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- Signup is implemented in Login.tsx (toggle between login/signup).  
- No password confirmation field; mismatched password scenario is not handled.  
- Error messages are generic; no specific handling for "email already exists".  
- No explicit email verification UI; relies on Supabase defaults.  
- No UI indication of "unverified email" state.

### Secure User Login
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Login with email/password is implemented with error handling.  
- Error messages could be more user-friendly (currently generic).  
- Redirects to dashboard on success.

### Password Reset
**Status:** [ ] Not Started  
**Gap / Required Work:**  
- No password reset or "forgot password" UI or logic present anywhere in the codebase.

---

## 2. Basic Profile Data Storage (Name, Company)

**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- ProfileSetup.tsx collects and stores user name and company (as part of professional background, not necessarily the venture context).  
- CompanySetup.tsx handles venture/company creation and associates it with the user.  
- Data is stored in "profiles" and "companies" tables.  
- UI for profile/venture setup is present and functional.  
- Retrieval and display of names/venture in UI is present in Layout.tsx and profile menus.  
- Some profile fields may be optional or not enforced; validation could be improved.

---

## 3. Enforce Single 'Venture' Context Logic

**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- CompanySetup.tsx checks if user already owns/is a member of a company and redirects to dashboard, enforcing single venture context in UI.  
- No UI for switching/creating multiple ventures.  
- Backend service (company.service.ts) allows querying multiple companies, but UI prevents creation/joining of more than one.  
- No explicit backend API enforcement of single venture context, but can be added if needed for security.

---

## 4. Core Application Framework

### Basic UI Shell / Container
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Layout.tsx provides a consistent shell with top nav, sidebar, and main content area.  
- Responsive design for desktop/mobile.  
- Main content area uses <Outlet /> for routed views.

### Main Navigation Structure (Sidebar/Tabs)
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Sidebar and mobile nav implemented in Layout.tsx.  
- Navigation links are conditionally rendered (e.g., company page only if company exists).  
- "Company Page" link is shown/hidden based on company status.

### Foundational UI Components/Styling
**Status:** [~] Built - Needs Cleanup/Refactor  
**Gap / Required Work:**  
- Most forms use consistent Tailwind CSS classes for inputs/buttons.  
- No evidence of a shared foundational UI component library (e.g., Button, Input, Select).  
- Some specialized AI-assisted input components exist.  
- Consider abstracting common form elements for maintainability and consistency.

---

## 5. Company/Venture Profile

### Store/Retrieve Completed Journey Steps List
**Status:** [ ] Not Started  
**Gap / Required Work:**  
- No evidence of journey step completion tracking in company or user profile data.
- No UI or backend logic for marking steps complete or displaying progress on a journey map.

### Store/Retrieve User-Defined "Current Focus Areas/Steps"
**Status:** [ ] Not Started  
**Gap / Required Work:**  
- No UI or backend logic for setting or displaying current focus areas/steps for a venture.

### Store/Retrieve "Company Formed" Status Flag
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- Company creation and setup is implemented (CompanySetup.tsx, companies table).
- No explicit "company formed" flag; inferred from company existence.
- No UI logic for toggling or displaying a "formed" status.

### Store/Retrieve Basic Company Details (Post-Setup)
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Company details (name, industry, website, etc.) are collected and stored.
- Company profile is associated with the user and can be displayed in the UI.
- Graceful handling of missing details may need review.

---

## 6. Idea Hub

### Backend: Lean Canvas Logic
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- ideas table and types support Lean Canvas fields (problem_statement, solution_concept, etc.).
- IdeaCanvas.tsx provides a Lean Canvas UI, but uses a separate idea_canvases table.
- Integration between Lean Canvas UI and main ideas list is unclear; may need consolidation.

### Backend: Status Tracking Logic
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- IdeaStatus enum and status field exist in types, but not surfaced in UI or migrations.
- No evidence of status field in ideas table or status update logic in UI.

### Backend: Other "Enhanced" Features Verification
**Status:** [?] Needs Verification  
**Gap / Required Work:**  
- Tagging, relationships, and other enhanced features not clearly documented or surfaced in UI.
- Code review and documentation needed to confirm any additional backend features.

### UI Integration: Idea List/Dashboard View
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- SavedIdeasPage.tsx lists ideas with filtering, sorting, and company association.
- "No ideas yet" and empty state handling present.
- Edit, refine, and delete actions available.

### UI Integration: View/Edit Lean Canvas
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- IdeaCanvas.tsx provides Lean Canvas editing, but may not be fully integrated with main ideas.
- UI for editing and saving Lean Canvas fields is present, but linkage to main idea entity may need improvement.

### UI Integration: Update Status via UI
**Status:** [ ] Not Started  
**Gap / Required Work:**  
- No UI for displaying or updating idea status (e.g., Draft, Validating).
- Status field not surfaced in idea list or detail views.

---

## 7. Startup Journey Map Module

### Backend: Data Model (Phases, Steps, Guidance, Tools, Options, Action Flags)
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- company_stages and company_stage_steps tables store phases and steps, with guidance, tools, resources, and options.
- company_progress table tracks per-company, per-step progress and status.
- Data model supports all required fields for journey map functionality.

### Backend: Content Loading Mechanism
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- Stages and steps are loaded from the database.
- No evidence of a script or admin UI for bulk loading/updating content from external sources (e.g., spreadsheets).
- Error handling for content loading is present in the UI.

### Backend: Tool Database Model/Loading
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- Tools are associated with steps and loaded/displayed in the UI.
- No evidence of a dedicated tool ranking or advanced recommendation logic.

### Frontend: UI for Browse Full Map
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- CompanyStages.tsx provides a visual, interactive journey map with expandable stages and steps.
- Users can browse all phases and steps, view details, and see progress.

### Frontend: UI for Viewing Step Details (Enhanced)
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Step details include guidance, checklist, tools, resources, and tips.
- UI is clear and well-structured.

### Frontend: UI for Step Feedback Input
**Status:** [ ] Not Started  
**Gap / Required Work:**  
- No UI for submitting feedback (rating/comment) on journey steps.

### Backend: Step Feedback Storage
**Status:** [ ] Not Started  
**Gap / Required Work:**  
- No backend logic or table for storing user feedback on steps.

### Frontend: UI Displaying Action Choices (Conditional)
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- Tools and resources are displayed per step.
- No explicit UI for "Use a Tool", "DIY", "Ask Expert", "Ask The Wheel" action choices with conditional logic.

---

## 8. Progress Tracker (Task Management)

### Backend: Rework/Build Task Storage (Dual Context - General/Journey)
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Tasks are stored with category and type, supporting both general and contextual (journey-linked) tasks.
- Data model supports required fields for MVP.

### Backend: Flexible Task Association Logic
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Tasks can be associated with categories/contexts.
- UI and backend support linking/unlinking tasks to journey steps or general backlog.

### Frontend: UI for General Task List
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- TaskManager and TaskList provide a dedicated view for general tasks.
- Basic actions (mark complete, edit, delete) are supported.

### Frontend: UI for Journey Step Task List
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- TaskManager supports category/context, but explicit journey step task list UI may need refinement.
- Linking tasks to specific journey steps is possible via category/context, but UI integration with journey map may need improvement.

### Frontend: UI for Associating General Task -> Journey Step
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- Tasks can be linked to contexts, but UI for associating a general task to a journey step may need enhancement.

### Frontend: UI for Manual Task Creation (General/Contextual)
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Manual task creation is supported via CreateTaskDialog and ManualTaskCreation.

### Frontend: UI for Task Completion
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Tasks can be marked complete/incomplete in the UI.
- Visual consistency is maintained across views.

### Integration: AI Task Ingestion into General Tasks
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- AITaskGenerator and related components suggest AI task ingestion is supported.
- Duplicate/similar task handling may need improvement.

---

## 9. AI Cofounder Integration

### UI Integration: Standup Input Section
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- StandupTestPage.tsx provides labeled text areas for standup input (yesterday, today, blockers, goals).
- Submit actions trigger AI feedback and task generation.

### UI Integration: AI Feedback Display
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- AI-generated feedback is displayed in a dedicated area.
- Loading/processing state is indicated.
- Error handling is present.

### Data Flow: AI Task Output -> Progress Tracker Ingestion
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- AI-generated tasks are displayed, but direct ingestion into the Progress Tracker is not shown in the UI.
- Integration may exist in services/hooks, but needs verification for seamless task ingestion.

### Context Awareness: AI Backend Aware of Current Journey Step/Focus
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- Standup entry includes goals and context, but explicit journey step/focus context passing is not shown.
- Backend may support context, but UI does not expose focus step selection.

---

## 10. Knowledge Hub Integration

### UI Integration: Read-Only Browse/Search Interface
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- ResourceLibrary.tsx provides a searchable, filterable interface for templates, guides, and educational content.
- Resources are displayed as cards with title, description, tags, and type.
- Users can view and download resources.
- No explicit article content display or full article reading experience; focus is on downloadable resources.
- No editing capability, as required for MVP.

---

## 11. Community Integration

### UI Integration: Forum Browse/Post/Reply Interface
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- CommunityPage.tsx provides a tabbed interface for discussions, events, members, and documents.
- Users can view topics, create new discussions, and reply to posts (via Post.tsx, not shown here but implied).
- Threaded replies and topic view are supported.
- Empty states and membership logic are handled.
- No major gaps for MVP forum functionality.

---

## 12. Messaging Integration

### UI Integration: Basic Inbox/Chat Interface
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- Messages.tsx provides a sidebar for conversations and a main area for chat.
- Users can search, start new conversations, and send/receive messages.
- Conversation history is displayed, and messages are marked as read.
- Error handling and empty states are present.
- No major gaps for MVP messaging functionality.

---

## 13. Platform Administration

### UI Integration: User Lookup
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- UserManagement.tsx (in AdminPanel) provides user search and profile viewing.
- Admins can search by email/name and view basic profile info.
- Handles user not found and access control.

### UI Integration: Feature Flag Management
**Status:** [] Functionally Complete  
**Gap / Required Work:**  
- FeatureFlagsSettings.tsx provides a UI for viewing and toggling feature flags.
- Changes are reflected in the backend and UI.
- Feature flags control platform/user segment features.

### Build: Journey Map & Tool Content Management Interface
**Status:** [+/-] Partially Built  
**Gap / Required Work:**  
- No dedicated admin UI for creating/updating journey map phases, steps, guidance, or curated tools.
- Content is managed via database/scripts, not a user-friendly admin interface.

---

## Summary of MVP Status

### Fully Implemented Features ()
- Secure User Login
- Enforce Single 'Venture' Context Logic
- Basic UI Shell / Container
- Main Navigation Structure (Sidebar/Tabs)
- Store/Retrieve Basic Company Details (Post-Setup)
- UI Integration: Idea List/Dashboard View
- Backend: Data Model (Phases, Steps, Guidance, Tools, Options, Action Flags)
- Frontend: UI for Browse Full Map
- Frontend: UI for Viewing Step Details (Enhanced)
- Backend: Rework/Build Task Storage (Dual Context - General/Journey)
- Backend: Flexible Task Association Logic
- Frontend: UI for General Task List
- Frontend: UI for Manual Task Creation (General/Contextual)
- Frontend: UI for Task Completion
- UI Integration: Standup Input Section
- UI Integration: AI Feedback Display
- UI Integration: Forum Browse/Post/Reply Interface
- UI Integration: Basic Inbox/Chat Interface
- UI Integration: User Lookup
- UI Integration: Feature Flag Management

### Partially Implemented Features (+/-)
- Secure User Signup
- Basic Profile Data Storage (Name, Company)
- Store/Retrieve "Company Formed" Status Flag
- Backend: Lean Canvas Logic
- Backend: Status Tracking Logic
- Backend: Content Loading Mechanism
- Backend: Tool Database Model/Loading
- Frontend: UI Displaying Action Choices (Conditional)
- Frontend: UI for Journey Step Task List
- Frontend: UI for Associating General Task -> Journey Step
- Integration: AI Task Ingestion into General Tasks
- Data Flow: AI Task Output -> Progress Tracker Ingestion
- Context Awareness: AI Backend Aware of Current Journey Step/Focus
- UI Integration: Read-Only Browse/Search Interface
- Build: Journey Map & Tool Content Management Interface

### Needs Cleanup/Refactor (~)
- Foundational UI Components/Styling

### Not Started ( )
- Password Reset
- Store/Retrieve Completed Journey Steps List
- Store/Retrieve User-Defined "Current Focus Areas/Steps"
- UI Integration: Update Status via UI
- Frontend: UI for Step Feedback Input
- Backend: Step Feedback Storage

### Needs Verification (?)
- Backend: Other "Enhanced" Features Verification

## Next Steps Recommendations

1. **High Priority Gaps**:
   - Implement password reset functionality
   - Add journey step completion tracking and focus areas
   - Implement step feedback UI and storage
   - Integrate Lean Canvas UI with main ideas list
   - Surface idea status in UI

2. **Cleanup/Refactor**:
   - Create a shared UI component library for consistency
   - Improve error messages for authentication flows
   - Enhance integration between journey map and task management

3. **Verification Needed**:
   - Document and verify enhanced idea hub features
   - Confirm AI task ingestion flow to Progress Tracker
   - Validate journey step/focus context awareness in AI backend

4. **Documentation**:
   - Create technical documentation for implemented features
   - Document data models and relationships
   - Create user guides for key features

---

## Role-Based Access Control (RBAC) Implementation Plan & Feature Set

This section outlines the plan for implementing a comprehensive, future-proof Role-Based Access Control (RBAC) system for The Wheel, designed to support multiple user types, contexts, and collaboration models, along with the resulting feature set.

### Part 1: RBAC Implementation Plan

This is a strategic approach to building the RBAC system, ensuring flexibility for future growth even while implementing a simpler version for the MVP.

#### Define Core Concepts

Establish clear, documented definitions for key RBAC entities within the system architecture:

- **User Account**: The individual identity.
- **Context**: A distinct workspace or entity (Platform, Company, Marketplace Profile, Community Space).
- **Mode**: The UI mechanism for switching active Contexts.
- **Permission**: Granular actions (e.g., idea.create, user.invite).
- **Role**: Named collections of Permissions (System or Contextual).
- **Assignment**: The link connecting a User, a Role, and optionally a specific Context instance.

#### Flexible Database Schema Design

Design database tables to represent these concepts, allowing for many-to-many relationships and context-specific assignments:
- users
- roles
- permissions
- contexts (or specific context tables)
- role_permissions
- user_role_assignments

#### Comprehensive Permission Definition

Catalogue all potential granular actions across all planned features and modules, assigning unique permission identifiers.

#### Full Role Definition

Define and implement the complete set of planned System Roles and Contextual Roles (Company, Marketplace, Community) and map the defined Permissions to each Role conceptually. All roles (including future roles) will be implemented in the MVP, even though only a subset will be actively used.

#### Context Implementation

Architect the application to recognize and manage different Context types as distinct operational environments.

#### Assignment Logic Implementation

Build the backend services to create, manage, and query user_role_assignments, correctly linking users to roles within the appropriate scope (system-wide or specific context instance).

#### Centralized Authorization Service

Implement a core authorization mechanism (e.g., middleware, dedicated service) that checks a user's resolved permissions (based on their active context role and system roles) against the permission required for any attempted action.

#### Mode Switching UI Design (Future)

Design the UI component allowing users to view and switch between their assigned roles/contexts. (Implementation deferred post-MVP).

#### Admin UI for RBAC Management (Future)

Plan for administrative interfaces allowing Platform Admins to manage roles, permissions, and potentially global assignments. (Implementation deferred post-MVP, except for MVP-specific admin needs).

#### Phased MVP Implementation

1. Implement all System Roles and Contextual Roles in the database, but only activate/use the essential ones (User, Platform Admin) for the initial launch.
2. Implement the Single Company Context logic, using the flexible backend schema but restricting users to one company context via application logic/UI.
3. Build only the MVP-required Admin functionality (Journey content management, feature flags, basic user lookup).

### Part 2: RBAC-Enabled Feature Set

This lists the user-facing and administrative features enabled by the comprehensive RBAC system. Features marked (MVP) are part of the initial launch scope; others are planned for future iterations.

#### A. Identity & Access Management Features

- **(MVP)** User Signup (Email/Password)
- **(MVP)** User Login (Email/Password)
- **(MVP)** Password Reset Mechanism
- **(MVP)** Basic User Profile Management (Name, Company)
- **(Future)** Multi-Factor Authentication (MFA) Setup & Management
- **(Future)** User API Key Management (for integrations)
- **(Future)** Account Deactivation/Deletion Request

#### B. Role & Permission Management Features (Admin Focus)

- **(MVP)** Platform Admin: Manage Journey Map Content (CRUD)
- **(MVP)** Platform Admin: Manage Tool Database (CRUD)
- **(MVP)** Platform Admin: Manage Feature Flags (View/Toggle)
- **(MVP)** Platform Admin: Basic User Lookup (View Profile)
- **(MVP)** Platform Admin: Access "Ask The Wheel" Request Queue
- **(Future)** Platform Admin: Define/Edit System Roles & Permissions
- **(Future)** Platform Admin: Assign/Revoke System Roles (e.g., Platform Admin, Support, Billing Admin)
- **(Future)** Platform Admin: Advanced User Management (Suspend, Impersonate with audit)
- **(Future)** Platform Admin: View Platform-Wide Audit Logs
- **(Future)** Billing Admin: Manage Platform Subscriptions & Billing
- **(Future)** Support Staff: View User/Company Data (Controlled Access)

#### C. Company Context Features

- **(MVP)** User: Operate within a single primary company context.
- **(MVP)** User: Access all core modules (Ideas, Journey, Tasks, Standup, Knowledge Hub, Community, Messaging) based on default User permissions within their company.
- **(MVP)** User: Complete Company Setup process.
- **(MVP)** User: View own Company Page (post-setup).
- **(Future)** Company Owner/Admin: Invite Team Members (Assigning Company Editor, Company Viewer roles).
- **(Future)** Company Owner/Admin: Remove Team Members from Company.
- **(Future)** Company Owner/Admin: Change Team Member Roles within Company.
- **(Future)** Company Owner/Admin: Manage Company-Specific Settings.
- **(Future)** Company Owner: Delete the Company.
- **(Future)** Company Owner: Transfer Company Ownership.
- **(Future)** Company Editor/Member: Create/Edit/Delete content (Ideas, Tasks, etc.) based on assigned permissions.
- **(Future)** Company Viewer: View company content based on assigned permissions.
- **(Future)** Company Owner/Admin: Invite External Advisors (Assigning Company Advisor role with configurable read/comment permissions).

#### D. Mode Switching Feature

- **(Future)** User: Access UI element (e.g., dropdown) listing all assigned Roles/Contexts (e.g., "Company A - Owner", "Company B - Editor", "My Advisor Profile").
- **(Future)** User: Select a Role/Context from the switcher to change the active operating mode and applied permissions.

#### E. Marketplace Provider Context Features

- **(Future)** Vendor Admin: Create/Edit/Manage Company Vendor Profile.
- **(Future)** Vendor Admin: Create/Edit/Manage Service/Product Listings.
- **(Future)** Vendor Admin: Invite/Manage Vendor Team Members & Roles.
- **(Future)** Individual Advisor: Create/Edit/Manage Personal Advisor Profile.
- **(Future)** Providers (Vendor/Advisor): Respond to RFPs/Service Requests.
- **(Future)** Providers (Vendor/Advisor): Manage Engagements/Contracts via platform.

#### F. Community Space Context Features

- **(MVP)** Community Member: View topics, create topics, post replies in general/public community areas.
- **(Future)** Space Admin: Manage Settings & Membership for a specific Community Space.
- **(Future)** Space Admin: Appoint/Remove Moderators for a specific Space.
- **(Future)** Moderator: Edit/Delete/Approve content within assigned Community Space(s).
- **(Future)** Community Member: Join/Leave specific Community Spaces (if applicable).

### Implementation Notes

1. **Future-Proofing Strategy**: By implementing all roles and permissions upfront but only activating the MVP subset, we ensure the system can grow without architectural changes.

2. **Database Considerations**: The schema should be designed to accommodate the full RBAC model from the start, even if only a portion is used initially.

3. **Migration Path**: As new features are added post-MVP, the corresponding roles and permissions can be activated without disrupting existing functionality.

4. **Security Implications**: The centralized authorization service ensures consistent permission enforcement across the application, reducing security risks.

5. **UI/UX Considerations**: The initial MVP will hide multi-context capabilities from users, presenting a simplified single-company experience while maintaining the technical foundation for future expansion.

================
File: netlify.toml
================
[build]
  command = "npm run build"
  publish = "dist"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

================
File: package.json
================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "db:migrate": "node scripts/migrate.js",
    "test": "jest"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@google-cloud/local-auth": "^2.1.0",
    "@headlessui/react": "^2.2.2",
    "@mui/icons-material": "^6.4.7",
    "@mui/material": "^6.4.7",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-progress": "^1.1.4",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@supabase/auth-ui-react": "^0.4.7",
    "@supabase/auth-ui-shared": "^0.1.8",
    "@supabase/supabase-js": "^2.39.3",
    "@types/canvas-confetti": "^1.9.0",
    "axios": "^1.8.3",
    "canvas-confetti": "^1.9.3",
    "chalk": "^5.4.1",
    "chart.js": "^4.4.9",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^16.5.0",
    "file-saver": "^2.0.5",
    "framer-motion": "^12.9.2",
    "googleapis": "^133.0.0",
    "html2canvas": "^1.4.1",
    "json5": "^2.2.3",
    "jspdf": "^3.0.1",
    "lucide-react": "^0.344.0",
    "node-fetch": "^3.3.2",
    "openai": "^4.28.0",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.0",
    "react-dnd": "^16.0.1",
    "react-dnd-html5-backend": "^16.0.1",
    "react-dom": "^18.3.1",
    "react-dropzone": "^14.3.8",
    "react-router-dom": "^6.22.2",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.2.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "xlsx": "^0.18.5",
    "zustand": "^4.5.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^14.3.1",
    "@types/file-saver": "^2.0.7",
    "@types/html2canvas": "^0.5.35",
    "@types/jest": "^29.5.14",
    "@types/pg": "^8.11.14",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "daisyui": "^5.0.28",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "jest": "^29.7.0",
    "pg": "^8.11.3",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^6.2.2",
    "vite-tsconfig-paths": "^5.1.4"
  }
}

================
File: postcss.config.js
================


================
File: pull_request_template_track_manually.md
================
# Replace "I'll Do This Myself" with "Track Manually" Button

## Description
This PR implements the MVP requirement to replace the "I'll Do This Myself" button with a "Track Manually" button in the Journey Map module. The key difference is that the new button doesn't change the step status in the database, making it a UI-only element that indicates the user is handling the step manually.

## Changes Made
- Removed the `handleMarkDiy` function from JourneyStepDetails component
- Replaced the "I'll Do This Myself" button with a "Track Manually" button
- Removed 'diy' from the journey_step_status type in TypeScript
- Removed the markStepDiy method from companyJourney.service.ts
- Added a migration script to update the database schema if needed

## Testing
- Verified that the "Track Manually" button appears correctly when a step is not completed or skipped
- Confirmed that clicking the button doesn't change the step status in the database
- Tested the migration script to ensure it handles both cases (whether 'diy' exists in the enum or not)

## Screenshots
[Add screenshots of the new "Track Manually" button here]

## Related Issues
- Closes #XXX (Replace with the actual issue number)

## Documentation
- Added journey_map_track_manually_implementation.md to document the changes and implementation details

================
File: README-HUGGINGFACE-REMOVAL.md
================
# Hugging Face Integration Removal

This document outlines the steps taken to completely remove both the Hugging Face Spaces and standard Hugging Face API integrations from the application.

## Background

The Hugging Face integration was initially added to provide alternative LLM capabilities through both the Hugging Face Inference API and Hugging Face Spaces. After evaluation, we've decided to standardize solely on OpenAI's API for LLM functionality, which offers better reliability, performance, and feature compatibility with our application.

## Archive Script

The `scripts/archive-huggingface-integration.cjs` script has been created to archive all Hugging Face related files. This script:

1. Moves all Hugging Face related source files, components, services, scripts, and documentation to an `archive/huggingface` directory
2. Preserves the file structure within the archive for potential future reference
3. Lists the core files that need manual modifications to remove remaining references

## Running the Archive Script

To archive all Hugging Face related files:

```bash
node scripts/archive-huggingface-integration.cjs
```

## Manual Code Modifications Required

After running the archive script, the following files need to be modified to remove remaining references to Hugging Face:

### 1. src/lib/services/general-llm.service.ts

Remove:
- Imports related to Hugging Face services
- The section in `getLLMService()` that checks for and returns Hugging Face services
- Any other references to Hugging Face in the code

### 2. src/lib/store.ts

Remove:
- Hugging Face related feature flags from the `defaultFeatureFlags` object:
  - `useHuggingFace`
  - `useHFCompanyModel`
  - `useHFAbstractionModel`

### 3. src/components/admin/FeatureFlagsSettings.tsx

Remove:
- The 'AI Providers' section from the `featureGroups` array that references Hugging Face

### 4. src/pages/SettingsPage.tsx

Remove:
- The import of `HuggingFaceSettings` component
- The `<HuggingFaceSettings />` component from the Integrations tab

## Database Cleanup (Optional)

For complete removal, you may want to remove Hugging Face related entries from the database:

1. The `huggingface_spaces` entry in the `app_settings` table
2. The `useHuggingFace`, `useHFCompanyModel`, and `useHFAbstractionModel` feature flags

## Verification Steps

After completing these changes, you can verify that the Hugging Face integration has been fully removed by:

1. Checking that no Hugging Face imports or references remain in the codebase
2. Confirming the application still functions normally
3. Verifying no Hugging Face options appear in the admin settings panels
4. Testing that the LLM service falls back to OpenAI or mock services as expected

## Impact on Application

Removing the Hugging Face integration simplifies the codebase and reduces dependencies. The application will now exclusively use:

- OpenAI's API for production LLM needs
- Mock services for testing and development

This change does not affect any core functionality, as OpenAI remains the primary LLM provider, with Hugging Face having been an optional alternative.

================
File: README-HUGGINGFACE-SPACES-FIX.md
================
you # Hugging Face Spaces Integration Fix

## Problem Diagnosis

We've identified the following issues with your Hugging Face Spaces integration:

1. **Space URL Format**: The URL format appears to be correct, but the Space is returning errors.
2. **Authentication Required**: Your Space at https://huggingface.co/spaces/alie354/company-base-expert-model is private (we received a 401 Unauthorized error), which means you need to provide an authentication token.
3. **API Endpoint**: The endpoint is correctly set to `/api/predict` but the Space is not responding to this endpoint.

## Solution

We've created several tools to help you fix these issues:

### 1. Add Authentication Token

Since your Space is private, you need to add a Hugging Face authentication token to access it:

```bash
node scripts/add-huggingface-auth-token.cjs YOUR_HUGGINGFACE_TOKEN
```

Replace `YOUR_HUGGINGFACE_TOKEN` with your actual Hugging Face token. You can get a token from the [Hugging Face settings page](https://huggingface.co/settings/tokens).

### 2. Test Different API Endpoints

If adding the authentication token doesn't solve the issue, your Space might be using a different API endpoint. Run the following script to test various endpoints:

```bash
node scripts/test-huggingface-spaces-connection.js
```

This script will try different common API endpoints and report which ones work.

### 3. Update API Endpoint

If the test script finds a working endpoint that's different from the current one, you can update it with:

```bash
node scripts/run-huggingface-fix.cjs
```

## Troubleshooting Steps

If you're still experiencing issues, here are some steps to troubleshoot:

1. **Verify Space Status**: Make sure your Space is running by visiting it in your browser at https://huggingface.co/spaces/alie354/company-base-expert-model. If it shows "This Space is currently paused", click the "Restart Space" button.

2. **Check Space API Documentation**: Your Space may have custom API endpoints. Check the documentation or source code of your Space to find the correct endpoint.

3. **Test Direct API Connection**: Use curl to directly test your Space API:

```bash
curl -X POST \
  https://alie354-company-base-expert-model.hf.space/api/predict \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"inputs": "Test query"}'
```

4. **Check the Space Implementation**: Your Space might be implemented with:
   - Gradio (common endpoints: `/api/predict`, `/run/predict`)
   - FastAPI (common endpoints: `/predict`, `/generate`)
   - Custom implementation with other endpoints

5. **Verify Input Format**: Different Spaces expect different input formats:
   - Standard: `{"inputs": "Your query", "parameters": {...}}`
   - Data array: `{"data": ["Your query"]}`

## Explanatory Documentation

For more detailed information about Hugging Face Spaces integration, refer to:

- [Troubleshooting Endpoints](docs/huggingface-spaces-integration/TROUBLESHOOTING_ENDPOINTS.md): Detailed guide to API endpoint issues and solutions
- [USER_GUIDE.md](docs/huggingface-spaces-integration/USER_GUIDE.md): General usage guide for the integration
- [API_KEY_SETUP_GUIDE.md](docs/huggingface-spaces-integration/API_KEY_SETUP_GUIDE.md): How to obtain and configure your Hugging Face API token

## Contact Space Owner

If all else fails, consider contacting the owner of the Space to ask about the correct API endpoint and input format.

================
File: README-HUGGINGFACE-SPACES-REMOVAL.md
================
# Hugging Face Spaces Integration Removal

This document outlines the steps taken to remove the Hugging Face Spaces integration from the application, while preserving the standard Hugging Face API functionality.

## Background

The Hugging Face Spaces integration was initially added to provide an alternative way to access LLM capabilities through Hugging Face's Spaces feature. After evaluation, we've decided to standardize on the direct Hugging Face API integration instead, which offers better reliability and performance.

## Changes Made

1. **UI Components Removed**
   - `HuggingFaceSpacesSettings.tsx` component removed from admin panel
   - References to Spaces removed from FeatureFlagsSettings (keeping standard HuggingFace API option)

2. **Service Layer Updates**
   - Removed `huggingface-spaces-client.ts` 
   - Removed `huggingface-spaces-llm.service.ts`
   - Updated `feature-flags.service.ts` to no longer check for Spaces-specific flags
   - Modified `general-llm.service.ts` to remove Spaces integration path

3. **Database Changes**
   - The `huggingface_spaces` entry in the `app_settings` table can remain for record-keeping
   - The `useHuggingFaceSpaces` feature flag in the feature flags table is no longer referenced in code

4. **Scripts and Migrations**
   - Archived scripts related to Hugging Face Spaces setup and configuration
   - Created `archive-huggingface-spaces.cjs` to safely archive related files

5. **Documentation**
   - Moved Spaces-specific documentation to the archive

## Files Moved to Archive

Files related to Hugging Face Spaces have been moved to the `archive/huggingface-spaces` directory, preserving their structure for potential future reference. This includes:

- Source code files (`src/lib/huggingface-spaces-client.ts`, `src/lib/services/huggingface-spaces-llm.service.ts`, etc.)
- Scripts for Spaces setup and configuration
- Documentation specific to Spaces integration

## Impact on Standard Hugging Face API Integration

The standard Hugging Face API integration through `huggingface-llm.service.ts` and `huggingface-client.ts` remains fully functional. Users can still enable the Hugging Face API as an alternative to OpenAI through the feature flags.

## How to Run the Archive Script

To remove and archive all Hugging Face Spaces related files:

```bash
node scripts/archive-huggingface-spaces.cjs
```

## Future Considerations

If reimplementing Hugging Face Spaces integration in the future, refer to the archived files for implementation details. The migration script (`scripts/run-huggingface-spaces-migration.js`) can also be used as a reference for setting up the necessary database entries.

================
File: README-ONBOARDING-FIX.md
================
# Onboarding Wizard Fix

## Overview

This repository contains fixes for the Wheel99 onboarding wizard that was experiencing a blinking/flickering issue when users navigated through the onboarding steps.

## Issue

The onboarding wizard screens were blinking and not progressing properly through the wizard steps. Users reported:

- Screens flashing/blinking rapidly between steps
- Wizard getting stuck on certain steps
- Needing to click buttons multiple times to progress

## Solution

We implemented several key fixes to address these issues:

1. Fixed infinite re-rendering loops in React component lifecycle
2. Added protection against race conditions in asynchronous operations
3. Implemented state stabilization to prevent UI flickering
4. Enhanced error handling for failed API calls
5. Added detailed logging for troubleshooting

The primary fix is in `src/components/onboarding/OnboardingController.tsx`, which now uses:

- React refs to track API call status
- useCallback for memoized function references
- Controlled fetch effects to prevent duplicate API calls
- Transition protection to prevent rapid state changes
- Debounced loading states to prevent flickering

## Testing

We've created testing tools to verify the onboarding flow works correctly:

- `scripts/test-onboarding-flow.js`: JavaScript test script that monitors the onboarding state
- `scripts/run-onboarding-test.sh`: Bash script to execute the test with proper Node.js options

### How to Test

1. Ensure you have Node.js installed
2. Configure your `.env` file with Supabase credentials
3. Run the test script:

```bash
./scripts/run-onboarding-test.sh
```

4. Log in with the test user credentials provided by the script
5. Go through the onboarding flow to verify it works smoothly
6. Press Ctrl+C in the terminal when done testing

## Documentation

For more detailed information about the fixes, refer to:

- [Blinking Fix Documentation](docs/onboarding-wizard/BLINKING_FIX.md): Technical details about the implemented fixes
- [Onboarding Controller Code](src/components/onboarding/OnboardingController.tsx): The main component that was fixed

## Implementation Summary

The key strategy was to prevent cascading state updates and provide better control over asynchronous operations. We used React's useRef, useCallback, and controlled effects to ensure that state updates happen in a predictable order and that API calls don't trigger unexpected re-renders.

These fixes should result in a much smoother onboarding experience for users, with no more blinking screens or navigation issues.

================
File: README.md
================
# Wheel99

Wheel99 is a platform for idea generation, refinement, and development. It provides tools for users to create, explore, and refine business ideas with AI assistance.

## Documentation

Comprehensive documentation for the project is available in the following files:

- [Comprehensive Documentation](./docs/COMPREHENSIVE_DOCUMENTATION.md) - Main documentation with overview and references to detailed docs
- [Core Features](./docs/CORE_FEATURES.md) - Detailed description of all implemented features
- [Technical Architecture](./docs/TECHNICAL_ARCHITECTURE.md) - System design and component architecture
- [AI Implementation](./docs/AI_IMPLEMENTATION.md) - AI integration details and context-aware features
- [Roadmap](./docs/ROADMAP.md) - Planned improvements and future features
- [User Stories](./docs/USER_STORIES.md) - Detailed user stories with acceptance criteria
- [Standup Bot](./docs/STANDUP_BOT.md) - Documentation for the Standup Bot feature
- [Task Generation](./docs/TASK_GENERATION.md) - Documentation for the Task Generation feature

## Project Structure

The project is organized as follows:

```
wheel99/
   src/                  # Source code
      components/       # React components
      lib/              # Utility functions and services
      pages/            # Page components
      ...
   public/               # Static assets
   supabase/             # Database schema and migrations
      schema.sql        # Consolidated database schema
   archive/              # Archived files (not included in git)
      scripts/          # Old scripts and utilities
      migrations/       # Old migration files
      components/       # Unused components
      docs/             # Documentation
   ...
```

## Database Schema

The database schema is consolidated in a single file: `supabase/schema.sql`. This file contains all the necessary tables, functions, and policies for the application.

To apply the schema to a new Supabase project:

1. Create a new Supabase project
2. Open the SQL Editor
3. Copy the contents of `supabase/schema.sql`
4. Paste into the SQL Editor and run

## Development

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- Supabase account

### Setup

1. Clone the repository
2. Install dependencies: `npm install`
3. Create a `.env` file with the following variables:
   ```
   VITE_SUPABASE_URL=your-supabase-url
   VITE_SUPABASE_ANON_KEY=your-supabase-anon-key
   VITE_OPENAI_API_KEY=your-openai-api-key
   ```
4. Start the development server: `npm run dev`

## Features

- Idea generation with AI assistance
- Multiple pathways for idea development
- Canvas-based idea organization
- Collaborative features
- AI-powered refinement and validation

## Recent Updates

### Dashboard Loading Fix

We've implemented a comprehensive fix for dashboard loading issues that includes:

- Enhanced error boundaries for better error isolation
- Improved component-level error handling
- Proper React.Suspense implementation for async components
- Better loading states and fallback UIs
- Detailed diagnostics for troubleshooting

For more information, see:
- [Dashboard Loading Fix](./docs/DASHBOARD_LOADING_FIX.md) - Overview of the fix
- [Detailed Fix Documentation](./docs/DASHBOARD_LOADING_FIX_DETAILS.md) - Technical implementation details

To run the dashboard diagnostics:

```bash
node scripts/run-dashboard-diagnostics.js
```

This will open a test runner that will help diagnose any dashboard loading issues.

## Cleanup Notes

This repository has been cleaned up to remove temporary fix scripts, old migrations, and unused files. All of these files have been moved to the `archive` directory, which is excluded from git.

A manifest of all archived files can be found in `archive/ARCHIVE_MANIFEST.md`.

Older documentation files have been archived and replaced with updated versions with a more organized structure.

================
File: steps1.csv
================
Phase_ID,name,order_index,need_explanation,has_tool,tool_explanation,steps_without_tool,effort_difficulty,staff_freelancers,key_considerations,bootstrap_mindset,founder_skills_needed
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Choose a Domain Name,1,"Establishes online presence, builds credibility, essential for website and email.",No,"Domain registrars (GoDaddy, Namecheap) provide all needed functionality.",1. Brainstorm names aligned with brand/product. 2. Check availability on registrar sites. 3. Register chosen domain.,Low,None,"Prioritize relevant, memorable names. Consider SEO impact.","Use free domain generators, look for registrar discounts.",Basic internet navigation
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Set Up Business Email,2,"Professionalism, credibility, separates personal and business communication.",No,Most providers allow using custom domains with free plans.,"1. Link domain to email provider (Gmail, Outlook, etc.). 2. Create accounts for team.",Low,None,"Choose provider with features you need (storage, calendar, etc.).",,Basic email setup
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Incorporate the Business,3,"Protects personal assets, provides legal legitimacy, required for certain financing and partnerships.",No (but recommended),"Online legal services streamline the process, but attorneys handle complex cases.","1. Choose business structure (LLC, S-Corp, etc.). 2. File paperwork with the state. 3. Obtain EIN.",Medium (High w/o tool),Attorney,"Research structures, registered agent optional.","Use online legal services, consult attorney if needed.","Basic legal understanding, research"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Set Up Equity Split,4,"Prevents future disputes, clarifies ownership, crucial for attracting investors and co-founders.",No,Basic agreements can be drafted without special tools.,1. Determine ownership percentages. 2. Draft formal agreement (with vesting if applicable).,Medium,Attorney (optional),"Transparency, fairness are key. Consider future dilution.","Use templates, spreadsheets, seek legal advice if complex.","Negotiation, basic legal understanding"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Create an Initial Budget,5,"Ensures financial control, guides spending decisions, essential for sustainability.",No,Spreadsheets or free software suffice initially.,1. Estimate startup costs. 2. Project revenue. 3. Create expense categories. 4. Track regularly.,Low,None,"Be conservative, prioritize essential costs. Regularly review and update.","Use free tools, review/update regularly.","Financial literacy, planning"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Open a Business Bank Account,6,"Separates finances, professional image, required for tax purposes.",No,"Banks handle this directly, no special tools needed.","1. Gather documents (EIN, incorporation papers). 2. Compare banks/credit unions. 3. Apply and fund account.",Low,None,"Shop around for low fees, features. Consider online banks for convenience.",,None (basic paperwork)
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Create a Landing Page,7,"Validates idea, collects leads early on, establishes online presence before full website.",No,"Many free builders exist, basic coding knowledge can help.","1. Choose platform (Wix, Squarespace, WordPress). 2. Design with clear message, call to action. 3. Include contact info. 4. Optimize for search engines.",Low-Medium,Web designer,"Focus on simplicity, clear message. Track visitor metrics.","Use templates, free builders, A/B test designs.","Basic web design, copywriting"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Set Up Accounting Software,8,"Streamlines finances, simplifies taxes, provides valuable insights.",Yes (free options exist),"Free options are limited, paid ones automate tasks, improve reporting.","1. Choose software (Wave, ZipBooks, etc.). 2. Connect bank accounts. 3. Categorize transactions. 4. Reconcile regularly.",Low (Higher w/o tool),Accountant (optional),"Start free, upgrade if needed. Consider outsourcing bookkeeping if budget allows.",Outsource bookkeeping if budget allows.,Financial literacy
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Insurance,9,"Protects against liability claims, property damage, and employee injuries.",No,"Insurance brokers can help you find the right coverage, but you can research and purchase policies directly from providers.","Research different types of business insurance (general liability, property, etc.). Obtain quotes from multiple providers.",Low-Medium,Insurance broker,Prioritize essential coverage based on your business risks.,Shop around for affordable policies with adequate coverage.,"Risk assessment, basic insurance knowledge"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Create a High-Level Business Plan,10,"Guides decisions, attracts potential investors, clarifies goals and strategies.",No,"Word processors, online templates suffice.","1. Outline problem, solution, market, competition. 2. Draft marketing/sales strategy. 3. Include financial projections.",Medium,Business consultant,"Focus on key elements, not excessive detail. Regularly review and update.","Utilize free resources, mentorship.","Strategic thinking, writing"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Secure Initial Funding (if needed),11,"Depends on business model, growth plans. If bootstrapping is sufficient, it can be skipped initially.",No,"Tools are for managing funds, not securing them.","1. Determine amount needed. 2. Explore personal funds, loans, crowdfunding, etc. 3. Prepare pitch if seeking investors.",Varies,N/A,Only if self-funding is insufficient. Consider different funding sources and their terms.,,"Fundraising, networking"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Register for Business Licenses and Permits,12,"Ensures legal operation, compliance with local/state regulations, and avoids potential fines.",Yes,"Tools streamline the process, ensure completeness, and help track renewal dates.",1. Research required licenses/permits. <br> 2. Obtain and fill out applications. <br> 3. Submit applications to appropriate agencies. <br> 4. Pay fees. <br> 5. Track renewal dates manually.,High,"Legal advisor, compliance specialist",Different licenses/permits required depending on location and business type.,Use online resources to understand requirements; handle applications personally to save costs.,"Research, attention to detail, understanding of legal requirements"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Set Up Payroll System,13,"Ensures employees are paid accurately and on time, compliance with tax laws.",Yes,"Tools automate calculations, tax withholdings, and filings, reducing errors and saving time.",1. Calculate payroll manually. <br> 2. Deduct taxes. <br> 3. Write and distribute paychecks. <br> 4. File taxes manually. <br> 5. Maintain records.,High,"Accountant, payroll specialist","Compliance with federal, state, and local tax laws; accurate record-keeping.",Use basic spreadsheets for tracking; hire part-time accountant or use free payroll tools initially.,"Financial literacy, attention to detail, basic accounting"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Set Up HR Management System,14,"Manages employee records, benefits, performance, compliance with labor laws.",Yes,"Tools centralize records, automate benefits management, and streamline compliance reporting.",1. Maintain employee records manually. <br> 2. Track benefits. <br> 3. Manage performance reviews manually. <br> 4. Ensure compliance with labor laws.,Medium,HR consultant,"Data privacy, legal compliance, employee engagement.",Use basic spreadsheets and manual processes initially; hire part-time HR consultant.,"Organizational skills, basic HR knowledge, attention to detail"
f2c8e9f6-dcd3-47d7-bab0-327d4cf358f9,Develop Basic Company Policies,15,"Establishes guidelines for behavior, operations, compliance, and creates a positive work culture.",No,"Policies can be drafted without special tools, using templates and legal advice as needed.",1. Research necessary policies. <br> 2. Draft policies. <br> 3. Review with legal advisor. <br> 4. Distribute to employees. <br> 5. Update as needed.,Medium,"Legal advisor, HR consultant","Ensure policies are comprehensive, clear, and legally compliant.",Use free online templates and resources; consult legal advisor for critical policies.,"Writing, research, understanding of legal requirements"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Competitor Analysis,16,"Provides insights into competitors' strengths, weaknesses, pricing, and marketing tactics. Helps refine your own strategies.",No,"Competitive analysis can be done through online research, social media monitoring, and customer interviews.","Research competitor websites, social media, and marketing materials. Conduct customer surveys and interviews.",Medium,Market research firm (optional),"Identify key differentiators, understand market positioning, and develop strategies to outperform competitors.",Leverage free tools like SimilarWeb and social media analytics.,"Research, analysis, strategic thinking"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Financial Modeling,17,"Forecasts revenue, expenses, and cash flow. Crucial for decision-making, securing funding, and ensuring long-term sustainability.",Partially,"Spreadsheets can be used for basic modeling, but dedicated tools offer more advanced features.","Create spreadsheets to project income, expenses, and cash flow. Use financial ratios to assess profitability and liquidity.",Medium (High without tool),Financial analyst (optional),Focus on realistic projections based on market research and industry benchmarks. Regularly update your model as your business evolves.,"Start with simple spreadsheets, consider free financial modeling tools like Google Sheets templates.","Financial literacy, forecasting"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Identify Problem/Opportunity,18,"Clearly defines the problem the product/service solves, ensures focus and alignment.",No,"This is a conceptual exercise, no tools needed.","Brainstorming sessions, customer interviews, market research.",Low,None,Deeply understand customer pain points and validate the problem exists.,"Talk to potential customers, research online forums and social media.","Critical thinking, problem-solving"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Market Research,19,"Understands target audience, their needs, and the competitive landscape. Essential for product-market fit.",No,Various free and low-cost research methods available.,"Online surveys, competitor analysis, social media listening, industry reports.",Medium,Market research firm (if budget allows),"Focus on primary research (surveys, interviews) and secondary research (existing data).","Use free online tools, attend industry events.","Research, analysis"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Refine Idea & Value Proposition,20,"Sharpens product concept, clearly articulates unique benefits, guides marketing and messaging.",No,"This is a collaborative, iterative process.","Whiteboarding, brainstorming sessions, feedback from potential customers.",Medium,None,Continuously iterate and refine based on feedback. Validate assumptions with potential users.,Get feedback from mentors and advisors.,"Creativity, communication"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Define MVP Scope,21,"Prioritizes essential features for the MVP, accelerates development and testing.",No,"This is a decision-making process, no tools needed.",Use prioritization frameworks like MoSCoW or Kano model. Gather feedback from potential users.,Medium,None,Focus on features that deliver most value to customers. Avoid feature creep.,"Get feedback from potential users, prioritize ruthlessly.","Decision-making, prioritization"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Develop a Minimum Viable Product (MVP),22,"Tests core value proposition with minimal investment, validates assumptions before full development.",Depends on the Product,"Some products can be built with no-code tools, others require specific frameworks or languages.","Build a basic version with essential features. Prioritize functionality over aesthetics. If using no-code, utilize platforms like Bubble or Webflow.",Varies Greatly (Low-High),"Developers, designers (depending on complexity)","Focus on core features, get feedback from users.",Consider outsourcing development to freelancers or using low-code/no-code platforms to reduce costs.,"Product management, project management"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Set Up Development Environment,23,Creates necessary tools and infrastructure for product development.,Depends on the Product,"Some products require specialized environments, others can use cloud-based options.",Set up local or cloud-based development environment. Ensure security and access for all team members.,Varies greatly,Developers,Use cloud-based environments for flexibility. Ensure version control (Git) is used.,Utilize free or open-source tools whenever possible. Invest in essential development tools that will streamline your workflow.,Technical expertise (or delegation)
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Design and Implement MVP,24,"This is the core of your product offering. It allows you to test your assumptions, gather feedback and iterate quickly.",Depends on the Product,"Some products can be built with no-code tools, others require specific frameworks or languages.","Coding, design, prototyping, depending on product type. If no-code, use platforms like Bubble or Webflow.",Varies Greatly (Low-High),"Developers, designers (depending on complexity)","Prioritize core features, ensure user-friendliness.","Utilize open-source libraries, frameworks, or no-code platforms where applicable.","Technical expertise, design skills (or delegation)"
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Set Up Continuous Integration/Deployment (CI/CD),25,"Automates testing and deployment, ensuring code quality and faster releases.",Yes (but free options exist),Free options like GitHub Actions or GitLab CI/CD can be sufficient for small teams.,Manually test and deploy code changes.,Medium (High for non-technical founders),DevOps engineer (optional),Choose a CI/CD tool that fits your tech stack and budget.,Leverage free CI/CD platforms and open-source tools.,Technical expertise (or delegation to a DevOps specialist)
d1a471e3-1ee6-481e-b445-cac5a9c2e5ea,Conduct Thorough Testing,26,"Ensures product stability, functionality, and user-friendliness before launch. Identifies and fixes bugs.",No (but tools can help),"Thorough testing can be done manually, but tools can automate some aspects and provide more comprehensive coverage.","Manual testing by team and beta users, user feedback collection.",Medium,None,Test on various devices and browsers. Collect feedback from diverse users.,Consider offering incentives to beta testers.,"Quality assurance, user experience, attention to detail"
531a1c37-1885-45b3-a14f-28fe163d84c5,Create a Full-Featured Website,27,"Showcases product, builds brand identity, provides information to potential customers, enables online sales.",No,Website builders or CMS platforms offer sufficient functionality for most startups.,"Use website builders (Wix, Squarespace) or WordPress, consider hiring a designer if needed.",Low-Medium,"Web designer, copywriter","Focus on clear navigation, compelling content, and strong calls to action. Optimize for search engines.","Use templates, free stock photos, and optimize for SEO.","Web design, copywriting, SEO"
531a1c37-1885-45b3-a14f-28fe163d84c5,Set Up a Payment Processor,28,"Enables transactions, essential for generating revenue.",Yes,Payment processors handle secure transactions and often offer fraud protection.,"Cash or check payments (less convenient, not scalable).",Low,None,"Choose a processor with low fees and features relevant to your business (e.g., recurring billing).",Compare fees and features before choosing.,"Basic integration, account setup"
531a1c37-1885-45b3-a14f-28fe163d84c5,Refine Marketing & Sales Strategy,29,"Defines how you'll reach target audience and generate sales, ensures effective resource allocation.",No,"Strategy development is a conceptual process, tools aid in execution later.","Market research, competitive analysis, outlining customer acquisition channels.",Medium,Marketing consultant (optional),"Adapt strategy based on market feedback. Consider different channels: social media, content marketing, SEO, paid ads.","Prioritize low-cost, high-impact channels. Experiment and measure results.","Marketing, sales, analytics"
531a1c37-1885-45b3-a14f-28fe163d84c5,Secure Initial Funding (if needed),30,"Can accelerate growth, enable hiring, expand marketing efforts and invest in new product development.",No,"Funding acquisition relies on relationships and pitch, not dedicated tools.","Prepare a pitch deck, network with investors, explore crowdfunding options.",Varies greatly,N/A,Only seek funding if absolutely necessary. Explore all options carefully. Understand the terms and implications of each funding source.,"Network with potential investors, advisors, and mentors. Attend pitch events and conferences.","Fundraising, networking, financial modeling, negotiation"
531a1c37-1885-45b3-a14f-28fe163d84c5,Beta Testing,31,"Allows for real-world testing, helps identify and fix bugs, gathers valuable user feedback before official launch.",No,"While some tools can aid in managing beta testing programs, it can be done without dedicated software.","Recruit beta testers, create feedback channels (surveys, forums), analyze usage data.",Medium,,Set clear goals and expectations for beta testers. Track and analyze feedback systematically.,"Offer incentives to beta testers (early access, discounts).","Project management, communication, data analysis"
531a1c37-1885-45b3-a14f-28fe163d84c5,Public Relations (PR),32,"Generates buzz, increases brand awareness, builds credibility and attracts customers.",No,"PR can be done through manual outreach to journalists, social media engagement, and press releases.","Build relationships with journalists, create press releases, engage on social media, attend industry events.",Medium-High,PR agency (optional),"Develop a compelling story, target relevant media outlets, and track media coverage.","Leverage free PR tools and resources, build relationships with journalists.","Communication, storytelling, relationship building"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Officially Launch!,33,"Marks the beginning of public availability, generates buzz and starts customer acquisition.",N/A,"Launching is an event, not a tool-based task.","Execute marketing plan, announce on all channels, track metrics.",Varies greatly,N/A,Prepare for increased customer support and website traffic. Celebrate your launch!,,"Marketing, customer service"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Customer Acquisition,34,"Essential for revenue and growth, validates product-market fit.",Partially,"Tools can help track leads and automate some marketing processes, but initial customer acquisition can be done through manual outreach and relationship building.","Utilize marketing channels (social media, content marketing, SEO, paid ads), engage with potential customers on social media and online communities, attend industry events, offer promotions or discounts, collect customer feedback.","Varies greatly (depends on the product, market, and chosen channels)","Marketing specialist, sales team","Focus on early adopters, gather feedback and iterate product. Experiment with different acquisition channels to find what works best. Track key metrics to measure success.","Prioritize low-cost, high-impact channels like content marketing, social media, and partnerships. Offer referral programs to incentivize existing customers to bring in new ones.","Marketing, sales, communication, networking, customer service"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Product Iteration,35,"Improves product based on feedback, keeps it competitive, addresses user needs, enhances user experience.",Depends on the Product,"Some products require specific development tools, others can be iterated with basic tools or no-code platforms.","Gather user feedback through surveys, interviews, and support channels. Analyze usage data, identify areas for improvement and prioritize feature development.",Varies greatly (depends on complexity of changes and development tools used),"Developers, designers","Establish a feedback loop with customers, track metrics, and regularly assess product-market fit. Be open to pivoting if necessary.",Prioritize the most impactful changes based on user feedback and data. Focus on continuous improvement.,"Product management, customer service, data analysis, adaptability"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Scaling Operations,36,"As customer base and revenue grow, operations need to scale to meet demand. This includes expanding production, improving efficiency, and potentially hiring.",Partially,"Tools can help automate and streamline processes, but initial scaling can be done manually.","Hire additional staff, implement more efficient processes, upgrade technology infrastructure. Outsource non-core tasks.",Varies greatly,"Varies depending on the nature of scaling (operations manager, customer support reps, etc.)","Focus on sustainable growth, don't overextend resources. Track key metrics to identify bottlenecks.",Utilize free or low-cost tools initially. Outsource tasks when feasible.,"Financial management, project management, leadership"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Financial Management,37,"Ensures financial health, tracks profitability, guides financial decision-making, and prepares for potential fundraising rounds.",Yes (but free options exist),"Free options are limited, dedicated tools offer more advanced features like forecasting and budgeting.","Use spreadsheets for basic tracking, seek guidance from an accountant if needed.",Medium (Higher w/o tool),Accountant (part-time or consultant),"Track key metrics, analyze profitability, create forecasts, plan for taxes.",Consider outsourcing complex financial tasks.,"Financial literacy, forecasting"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Fundraising (if needed),38,"Can fuel rapid growth, enable hiring, expand marketing efforts, and invest in new product development.",No,"Fundraising relies on relationships and pitch, not dedicated tools.","Prepare a pitch deck, network with investors, research funding options (VC, angel investors, crowdfunding).",Varies greatly,N/A,Only seek funding if absolutely necessary. Explore all options carefully. Understand the terms and implications of each funding source.,"Network with potential investors, advisors, and mentors. Attend pitch events and conferences.","Fundraising, networking, financial modeling, negotiation"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Exit Strategy,39,"Defines the ultimate goal of the business, provides a roadmap for the future, can influence early decisions.",No,"Exit strategy is a planning process, not a tool-based task.","Research different exit options (acquisition, IPO, etc.), create a plan for achieving the desired outcome, consult with advisors.",Medium,"Business consultant, M&A advisor",Consider the long-term vision for the company and align early decisions with that vision. Be realistic about potential outcomes.,Network with potential acquirers or investors. Seek advice from experienced entrepreneurs.,"Strategic planning, financial modeling, negotiation"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Customer Success/Support,40,"Ensures customers have a positive experience, increases customer retention, builds brand loyalty.",Partially,"Help desk software can streamline support, but initial support can be handled manually.","Set up email support channels, FAQs, knowledge base. Monitor social media for customer inquiries.",Low-Medium,Customer support reps,"Respond promptly to customer inquiries, address issues effectively, gather feedback.",Utilize free customer support tools like email and social media.,"Customer service, communication"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Data Analytics,41,"Tracks key metrics, provides insights into user behavior, informs decision-making for product and marketing.",Yes (but free options exist),"Free options like Google Analytics can suffice initially, but dedicated tools offer more advanced analysis.","Implement basic website analytics, track key metrics (traffic, conversion, retention).",Low-Medium,Data analyst (optional),Set up goals and track progress. Use data to inform product and marketing decisions.,Leverage free analytics tools initially.,"Data analysis, basic statistics"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Team Building,42,"As your startup grows, you'll need to build a strong team to handle various aspects of the business.",No,"Team building is a process, not a tool-based task.","Define roles and responsibilities, hire the right people, foster a positive culture.",Varies greatly,"HR consultant, recruiters",Hire people who share your vision and values. Focus on building a diverse and inclusive team.,Look for candidates who are passionate about your mission and willing to wear multiple hats.,"Leadership, communication, recruiting"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Investor Relations (if applicable),43,"Maintains relationships with investors, provides transparency and demonstrates progress towards goals.",Partially,"Investor relations software can streamline communication, but personal outreach is crucial.","Regular updates (email, meetings), transparent reporting, showcasing milestones.",Medium,Investor relations specialist (optional),"Build trust with investors, be proactive in communication, address concerns promptly.",Be transparent and honest about challenges and successes.,"Communication, relationship management, financial reporting"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Legal Compliance,44,"Ensures business operations adhere to laws and regulations, avoids legal penalties.",No,"Legal services can aid, but compliance can be maintained with thorough research and record-keeping.","Stay updated on relevant laws and regulations, maintain proper documentation, file necessary reports.",Medium-High,Legal advisor,"Regularly review compliance requirements, keep detailed records.","Utilize free legal resources and templates, consult with a legal advisor as needed.","Legal knowledge, attention to detail"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Product Roadmap,45,"Provides a strategic plan outlining future product features and development phases, aligns team efforts.",No,"Roadmapping tools help, but can be done with basic planning tools.","Outline key milestones and features, prioritize based on customer feedback and business goals.",Medium,Product manager,"Keep the roadmap flexible to adapt to changes, align with overall business strategy.",Use free planning tools like Trello or Google Sheets.,"Strategic planning, adaptability"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Security Measures,46,"Protects business data and customer information, ensures trust and compliance with regulations.",Yes (free options exist),"Basic security measures can be implemented with free tools, advanced measures may require dedicated solutions.","Implement strong passwords, data encryption, regular backups, and access controls.",Medium,IT security specialist,"Regularly update security protocols, educate team on best practices.","Leverage free security tools initially, upgrade as needed.","Cybersecurity knowledge, vigilance"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Performance Metrics,47,"Tracks business performance, helps in making data-driven decisions, measures success against goals.",Yes (free options exist),"Basic metrics tracking can be done with free tools, advanced analysis may require dedicated software.","Define key performance indicators (KPIs), set up tracking tools, analyze data regularly.",Medium,Data analyst (optional),"Focus on the most impactful metrics, adjust strategies based on insights.","Use free tools for initial tracking, upgrade as necessary.","Data analysis, strategic thinking"
8e4706b2-bdd1-46af-acc0-1ab8025d5fbf,Intellectual Property Protection,48,"Protects your unique inventions, designs, or branding elements, provides a competitive advantage.",No (but recommended),"While DIY options exist, legal counsel is crucial for proper filing and protection.","Research patent, trademark, and copyright options. Consult an attorney for guidance.",Varies (High without attorney),Intellectual property attorney,Prioritize protecting core intellectual property. Consider provisional patents for early-stage protection.,Explore free or low-cost resources for initial research.,"Legal understanding, research"

================
File: tailwind.config.js
================


================
File: the_wheel_adaptation_plan.md
================
# The Wheel: Adaptation Plan for New Schema

This document outlines a detailed plan for adapting the existing codebase to work with the new database schema (`the_wheel_full_schema.sql`), while preserving working components and only building or refactoring where necessary.

## Core Principles

1. **Preserve Working Code**: Adapt existing, functional components rather than rewriting them.
2. **Targeted Refactoring**: Only refactor where there are gaps, bugs, or schema mismatches.
3. **Maintain Functionality**: Ensure all existing features continue to work with the new schema.
4. **Enhance for Requirements**: Add new features and improvements as specified in the MVP requirements.

## Important Clarification

The single venture/company concept means **each user can be part of only one company** (or none), not that each company can only have one user. Companies can have multiple members, but users cannot be members of multiple companies in the MVP.

## Module-by-Module Adaptation Plan

### 1. Identity & Authentication

#### 1.1 Login []
- **Status**: Functionally Complete
- **Adaptation Strategy**: 
  - Keep existing Login.tsx component
  - Update backend service calls to use new schema if needed
  - Improve error messages for clarity
- **Specific Changes**:
  - Update auth service to use new users table structure
  - Ensure proper redirection after login
  - Enhance error handling for specific error cases

#### 1.2 Signup [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Enhance existing signup form in Login.tsx
  - Add password confirmation field
  - Implement specific error handling
- **Specific Changes**:
  - Add password confirmation field and validation
  - Add specific error handling for "email already exists"
  - Update backend service to use new schema
  - Ensure proper user record creation in the new users table

#### 1.3 Password Reset [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Implement as a new feature
  - Use Supabase Auth and the new password_reset_requests table
- **Specific Changes**:
  - Create ForgotPasswordPage component
  - Create ResetPasswordPage component
  - Implement backend service for password reset token generation and validation
  - Add email sending functionality (or use Supabase's built-in functionality)

#### 1.4 Profile Data Storage [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Adapt ProfileSetup.tsx and CompanySetup.tsx
  - Ensure data is stored in the correct tables/fields
- **Specific Changes**:
  - Update profile service to use new users table structure
  - Ensure company name is clearly stored as the venture name
  - Improve validation for required fields
  - Update UI to reflect new data structure

### 2. Company Context Management

#### 2.1 Single Venture Context []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep current logic that restricts users to one company
  - Ensure companies can have multiple members
- **Specific Changes**:
  - Verify CompanySetup.tsx correctly checks if user is already a member of a company
  - Update backend service to use new company_members table
  - Add explicit backend API enforcement for security if needed
  - Ensure proper handling of company-user relationships

#### 2.2 Company Formation & Flag [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Add explicit "company formed" flag
  - Implement trigger mechanism from journey step completion
- **Specific Changes**:
  - Use the is_formed field in the companies table
  - Implement backend logic to update flag when designated journey step is completed
  - Update UI to check this flag for conditional elements (like Company Page link)

#### 2.3 Company Page [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Build new page component
  - Reuse existing company data fetching logic
- **Specific Changes**:
  - Create CompanyPage component
  - Implement route definition and navigation
  - Add conditional access logic based on company formed flag
  - Build UI for displaying company details
  - Handle missing data gracefully

### 3. Core Application Framework

#### 3.1 UI Shell / Container []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep Layout.tsx and navigation structure
  - Update conditional rendering logic if needed
- **Specific Changes**:
  - Verify Layout.tsx works with new schema
  - Update navigation conditional rendering to use new fields/flags
  - Ensure Knowledge Hub link is removed or points to "Coming Soon" for MVP

#### 3.2 UI Components/Styling [~]
- **Status**: Built - Needs Cleanup/Refactor
- **Adaptation Strategy**:
  - Abstract common elements into reusable components
  - Improve consistency and accessibility
- **Specific Changes**:
  - Create shared Button component
  - Create shared Input component
  - Create shared Select component
  - Update existing forms to use new components
  - Implement accessibility attributes (ARIA, labels, etc.)
  - Ensure responsive design across all components

### 4. Journey Map Module

#### 4.1 Journey Map Core []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep CompanyStages.tsx and related UI
  - Update backend services to use new schema
- **Specific Changes**:
  - Update journey service to use new journey_phases and journey_steps tables
  - Ensure proper loading of phases, steps, and their relationships
  - Update UI to display journey map correctly with new data structure

#### 4.2 Step Completion Tracking [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Implement backend logic for tracking completed steps
  - Add UI for marking steps complete
- **Specific Changes**:
  - Create service for updating company_progress records
  - Add "Mark as Complete" button/checkbox to step details view
  - Implement visual indicators for completed steps on the map
  - Handle special case for company formation step

#### 4.3 Focus Areas [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Implement backend logic for tracking focus areas
  - Add UI for setting/clearing focus areas
- **Specific Changes**:
  - Create service for managing company_focus_areas records
  - Add UI controls for setting/clearing focus areas
  - Implement visual indicators for focus areas on the map
  - Ensure focus areas are passed to AI context

#### 4.4 Step Details View []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing step details UI
  - Integrate with new action choices and feedback
- **Specific Changes**:
  - Update service to load step details from new schema
  - Ensure guidance, options, tools, etc. are displayed correctly
  - Add action choices UI (Use Tool, DIY, Ask Expert, Ask Wheel)
  - Add step feedback input form

#### 4.5 Step Feedback [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Implement backend logic for storing feedback
  - Add UI for submitting feedback
- **Specific Changes**:
  - Create service for storing journey_step_feedback records
  - Add rating and comment input UI to step details view
  - Implement submission and confirmation logic
  - Handle validation and error cases

#### 4.6 Action Choices UI [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Enhance existing UI with explicit action choices
  - Implement conditional display based on flags
- **Specific Changes**:
  - Add "Use a Tool", "DIY", "Ask Expert", "Ask Wheel" buttons
  - Implement conditional display based on step flags
  - Connect buttons to appropriate functionality
  - Handle disabled/unavailable actions gracefully

### 5. Tool Recommendation & Custom Tools

#### 5.1 Tool Recommendation Logic [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Implement backend logic for ranking tools
  - Create service for personalized recommendations
- **Specific Changes**:
  - Create service for filtering/ranking tools based on profile data
  - Implement default ranking logic for when profile data is insufficient
  - Ensure proper handling of steps with fewer than 3 tools

#### 5.2 Tool Display UI [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Enhance existing tool display UI
  - Add "Top 3" section and "See All" option
- **Specific Changes**:
  - Update tool display to show top 3 recommendations prominently
  - Add "See All" button/link to view all tools for the step
  - Implement tool cards with consistent styling
  - Ensure proper display of tool details

#### 5.3 Custom Tool Addition [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Implement UI for adding custom tools
  - Create backend logic for storing custom tools
- **Specific Changes**:
  - Add "Add Custom Tool" button to tool display
  - Create form for entering tool name, URL, and functionality
  - Implement backend service for storing custom tools
  - Connect to AI description generation service

#### 5.4 AI Tool Description Generation [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Implement AI service for generating tool descriptions
  - Create UI for reviewing and accepting generated content
- **Specific Changes**:
  - Create AI service that extracts information from tool URLs
  - Implement preview card for generated descriptions
  - Add accept/reject/regenerate buttons
  - Implement backend storage for accepted descriptions

### 6. Idea Hub

#### 6.1 Idea List/Dashboard []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep SavedIdeasPage.tsx and related UI
  - Update data fetching to use new schema
- **Specific Changes**:
  - Update idea service to use new ideas table structure
  - Ensure proper filtering and sorting with new schema
  - Add status display to idea list items
  - Verify company association works correctly

#### 6.2 Lean Canvas [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Verify/refactor IdeaCanvas.tsx to use new schema
  - Ensure data is stored in the correct fields
- **Specific Changes**:
  - Update canvas service to use consolidated idea fields
  - Verify all Lean Canvas fields are saved correctly
  - Ensure proper loading and display of saved data
  - Handle validation and error cases

#### 6.3 Status Tracking [ ]
- **Status**: Not Started
- **Adaptation Strategy**:
  - Add status dropdown to existing UI
  - Implement backend logic for updating status
- **Specific Changes**:
  - Add status dropdown to idea details/canvas view
  - Create service for updating idea status
  - Ensure status changes are reflected in the UI
  - Update idea list filtering to use status field

### 7. Task Management

#### 7.1 General Task List []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing UI and logic
  - Update data access to use new schema
- **Specific Changes**:
  - Update task service to use new tasks table structure
  - Ensure proper filtering and sorting with new schema
  - Verify task creation, editing, and completion work correctly

#### 7.2 Journey Step Task List [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Enhance UI for displaying tasks associated with steps
  - Implement integration with journey map
- **Specific Changes**:
  - Add task list section to step details view
  - Update task service to filter by journey_step_id
  - Ensure proper display and management of step-specific tasks

#### 7.3 Task Association [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Enhance UI for associating tasks with steps
  - Implement backend logic for updating associations
- **Specific Changes**:
  - Add UI for linking general tasks to journey steps
  - Create service for updating task-step associations
  - Ensure tasks appear in the correct lists after association
  - Handle task context changes gracefully

#### 7.4 AI Task Ingestion [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Verify and adapt end-to-end flow
  - Ensure proper handling of AI-generated tasks
- **Specific Changes**:
  - Update standup task service to use new schema
  - Verify task ingestion from AI output to general tasks list
  - Implement duplicate detection/handling
  - Ensure proper display of AI-generated tasks in the UI

### 8. AI Cofounder (Standup Bot)

#### 8.1 Standup Input []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing UI and logic
  - Update data access to use new schema
- **Specific Changes**:
  - Update standup service to use new standup_entries table
  - Verify form submission and data storage work correctly
  - Ensure proper handling of user/company context

#### 8.2 AI Feedback Display []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing UI and logic
  - Update data access to use new schema
- **Specific Changes**:
  - Update feedback service to use new standup_feedback table
  - Verify proper display of AI-generated feedback
  - Ensure loading states and error handling work correctly

#### 8.3 Journey Context Integration [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Enhance standup service to include journey context
  - Update AI prompt to use focus areas
- **Specific Changes**:
  - Update standup service to include focus_step_id
  - Modify AI prompt to incorporate journey context
  - Ensure context is passed correctly to the AI service
  - Verify AI feedback reflects journey context

### 9. Community & Messaging

#### 9.1 Community Forum []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing UI and logic
  - Update data access to use new schema
- **Specific Changes**:
  - Update community service to use new communities and related tables
  - Verify post creation, viewing, and replying work correctly
  - Ensure proper handling of user/company context

#### 9.2 Messaging []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing UI and logic
  - Update data access to use new schema
- **Specific Changes**:
  - Update messaging service to use new conversations and messages tables
  - Verify conversation listing, message sending, and reading work correctly
  - Ensure proper handling of user context

### 10. Administration

#### 10.1 User Lookup []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing UI and logic
  - Update data access to use new schema
- **Specific Changes**:
  - Update user service to use new users table structure
  - Verify search functionality works correctly
  - Ensure proper display of user details

#### 10.2 Feature Flag Management []
- **Status**: Functionally Complete
- **Adaptation Strategy**:
  - Keep existing UI and logic
  - Update data access to use new schema
- **Specific Changes**:
  - Update feature flag service to use new feature_flags table
  - Verify toggle functionality works correctly
  - Ensure changes are reflected throughout the application

#### 10.3 Journey Content Management [+/-]
- **Status**: Partially Built
- **Adaptation Strategy**:
  - Build admin UI for journey/tool content
  - Reuse any existing scripts/services
- **Specific Changes**:
  - Create AdminJourneyPage component
  - Implement journey structure editor
  - Add step content editor
  - Create tool management UI
  - Implement backend services for content CRUD operations

## Technical Implementation Steps

### 1. Data Model & Type Updates

1. Create TypeScript interfaces for all new database tables
2. Update existing interfaces to match new schema
3. Create type guards and validation functions
4. Update API response/request types

### 2. Service Layer Updates

1. Update authentication service to use new schema
2. Update user/profile service to use new schema
3. Update company service to use new schema
4. Update journey service to use new schema
5. Update idea service to use new schema
6. Update task service to use new schema
7. Update standup service to use new schema
8. Update community service to use new schema
9. Update messaging service to use new schema
10. Update admin services to use new schema

### 3. UI Component Updates

1. Update authentication components
2. Update profile components
3. Update company components
4. Update journey map components
5. Update idea hub components
6. Update task management components
7. Update standup components
8. Update community components
9. Update messaging components
10. Update admin components

### 4. New Feature Implementation

1. Implement password reset
2. Implement step completion tracking
3. Implement focus areas
4. Implement step feedback
5. Implement action choices
6. Implement tool recommendation
7. Implement custom tool addition
8. Implement AI tool description generation
9. Implement idea status tracking
10. Implement company page

### 5. Cross-Cutting Concerns

1. Implement accessibility enhancements
   - Add ARIA attributes
   - Ensure keyboard navigation
   - Implement focus management
   - Add screen reader support
   - Ensure color contrast compliance

2. Implement responsive design
   - Use mobile-first approach
   - Add breakpoints for different screen sizes
   - Ensure touch-friendly UI elements
   - Test on multiple device sizes

3. Implement detailed logging
   - Add frontend event logging
   - Add API request/response logging
   - Add error logging
   - Add business event logging
   - Implement sensitive data masking

## Implementation Timeline

### Week 1: Core Identity & Data Models
- Update all TypeScript interfaces and types
- Update authentication and profile services
- Implement password reset
- Update company service and context management

### Week 2: Journey Map & Company
- Update journey service and map components
- Implement step completion and focus areas
- Implement company page
- Implement step feedback

### Week 3: Tools & Actions
- Implement action choices UI
- Implement tool recommendation
- Implement custom tool addition
- Implement AI tool description generation

### Week 4: Idea Hub & Tasks
- Update idea service and components
- Implement idea status tracking
- Update task service and components
- Enhance task-journey integration

### Week 5: AI Integration & Community
- Update standup service and components
- Enhance journey context integration
- Update community and messaging services
- Implement cross-cutting concerns

### Week 6: Administration & Testing
- Update admin services and components
- Implement journey content management
- Comprehensive testing and bug fixing
- Performance optimization

## Testing Strategy

### Unit Testing
- Test all updated services
- Test new components
- Test utility functions

### Integration Testing
- Test authentication flows
- Test journey map interactions
- Test idea hub workflows
- Test task management workflows
- Test standup bot end-to-end

### Accessibility Testing
- Automated testing with axe-core
- Manual keyboard navigation testing
- Screen reader testing

### Responsive Testing
- Test on mobile, tablet, and desktop viewports
- Test touch interactions
- Verify layout at different breakpoints

## Conclusion

This adaptation plan provides a comprehensive roadmap for updating the existing codebase to work with the new database schema while preserving working components and implementing new features as required. By following this plan, we can ensure a smooth transition to the new schema and deliver a high-quality MVP that meets all the specified requirements.

================
File: the_wheel_data_migration_plan.md
================
# The Wheel: Data Migration Plan

This document outlines the plan for migrating data from the "tools and steps (1).xlsx" file into the new database schema, ensuring that all journey phases, steps, tools, and related content are properly loaded.

## Overview

The "tools and steps (1).xlsx" file contains essential content for the Journey Map, including:
- Phases and their sequence
- Steps within each phase
- Guidance text for each step
- Options for completing steps
- Tools recommended for each step
- Action flags for steps

This data needs to be imported into the appropriate tables in the new database schema to populate the Journey Map.

## Database Tables for Journey Content

The following tables will store the journey content:

1. `journey_phases` - Phases of the startup journey
2. `journey_steps` - Steps within each phase
3. `journey_step_options` - Options for completing each step
4. `journey_step_tools` - Tools recommended for each step
5. `journey_step_resources` - Resources related to each step
6. `journey_step_tips` - Tips for each step
7. `journey_step_checklists` - Checklist items for each step

## Data Migration Process

### 1. Excel File Parsing

Create a script to parse the Excel file and extract structured data:

```typescript
// parse-journey-data.ts
import * as XLSX from 'xlsx';
import * as fs from 'fs';

// Load the Excel file
const workbook = XLSX.readFile('tools and steps (1).xlsx');

// Get the first sheet
const worksheet = workbook.Sheets[workbook.SheetNames[0]];

// Convert to JSON
const data = XLSX.utils.sheet_to_json(worksheet);

// Process and structure the data
const phases = [];
const steps = [];
const options = [];
const tools = [];

// Process each row
data.forEach(row => {
  // Extract phase data
  if (row.PhaseID && !phases.some(p => p.id === row.PhaseID)) {
    phases.push({
      id: row.PhaseID,
      name: row.PhaseName,
      description: row.PhaseDescription,
      order_index: row.PhaseOrder
    });
  }
  
  // Extract step data
  if (row.StepID) {
    steps.push({
      id: row.StepID,
      phase_id: row.PhaseID,
      name: row.StepName,
      description: row.StepDescription,
      guidance: row.StepGuidance,
      order_index: row.StepOrder,
      ask_wheel_enabled: row.AskWheelEnabled === 'Yes',
      ask_expert_enabled: row.AskExpertEnabled === 'Yes',
      use_tool_enabled: row.UseToolEnabled === 'Yes',
      diy_enabled: row.DIYEnabled === 'Yes',
      is_company_formation_step: row.IsCompanyFormationStep === 'Yes'
    });
    
    // Extract options
    if (row.Options) {
      const stepOptions = row.Options.split(';');
      stepOptions.forEach((option, index) => {
        options.push({
          step_id: row.StepID,
          name: option.trim(),
          order_index: index
        });
      });
    }
    
    // Extract tools
    if (row.Tools) {
      const stepTools = row.Tools.split(';');
      stepTools.forEach((tool, index) => {
        const [name, url] = tool.split('|').map(s => s.trim());
        tools.push({
          step_id: row.StepID,
          name,
          url: url || '#',
          ranking: index
        });
      });
    }
  }
});

// Write structured data to JSON files
fs.writeFileSync('journey_phases.json', JSON.stringify(phases, null, 2));
fs.writeFileSync('journey_steps.json', JSON.stringify(steps, null, 2));
fs.writeFileSync('journey_step_options.json', JSON.stringify(options, null, 2));
fs.writeFileSync('journey_step_tools.json', JSON.stringify(tools, null, 2));

console.log('Data extraction complete!');
```

### 2. SQL Generation

Create a script to generate SQL insert statements from the structured data:

```typescript
// generate-sql.ts
import * as fs from 'fs';

// Load the structured data
const phases = JSON.parse(fs.readFileSync('journey_phases.json', 'utf8'));
const steps = JSON.parse(fs.readFileSync('journey_steps.json', 'utf8'));
const options = JSON.parse(fs.readFileSync('journey_step_options.json', 'utf8'));
const tools = JSON.parse(fs.readFileSync('journey_step_tools.json', 'utf8'));

// Generate SQL for phases
let sql = '-- Journey Phases\n';
phases.forEach(phase => {
  sql += `INSERT INTO journey_phases (id, name, description, order_index) VALUES 
  ('${phase.id}', '${phase.name.replace(/'/g, "''")}', '${phase.description?.replace(/'/g, "''") || ''}', ${phase.order_index});\n`;
});

// Generate SQL for steps
sql += '\n-- Journey Steps\n';
steps.forEach(step => {
  sql += `INSERT INTO journey_steps (id, phase_id, name, description, guidance, order_index, ask_wheel_enabled, ask_expert_enabled, use_tool_enabled, diy_enabled, is_company_formation_step) VALUES 
  ('${step.id}', '${step.phase_id}', '${step.name.replace(/'/g, "''")}', '${step.description?.replace(/'/g, "''") || ''}', '${step.guidance?.replace(/'/g, "''") || ''}', ${step.order_index}, ${step.ask_wheel_enabled}, ${step.ask_expert_enabled}, ${step.use_tool_enabled}, ${step.diy_enabled}, ${step.is_company_formation_step});\n`;
});

// Generate SQL for options
sql += '\n-- Journey Step Options\n';
options.forEach(option => {
  sql += `INSERT INTO journey_step_options (step_id, name, order_index) VALUES 
  ('${option.step_id}', '${option.name.replace(/'/g, "''")}', ${option.order_index});\n`;
});

// Generate SQL for tools
sql += '\n-- Journey Step Tools\n';
tools.forEach(tool => {
  sql += `INSERT INTO journey_step_tools (step_id, name, url, ranking) VALUES 
  ('${tool.step_id}', '${tool.name.replace(/'/g, "''")}', '${tool.url}', ${tool.ranking});\n`;
});

// Write SQL to file
fs.writeFileSync('journey_data_migration.sql', sql);
console.log('SQL generation complete!');
```

### 3. Database Migration Script

Create a migration script to execute the SQL:

```typescript
// migrate-journey-data.ts
import { supabase } from './supabase-client';
import * as fs from 'fs';

async function migrateJourneyData() {
  try {
    console.log('Starting journey data migration...');
    
    // Read the SQL file
    const sql = fs.readFileSync('journey_data_migration.sql', 'utf8');
    
    // Split into individual statements
    const statements = sql.split(';\n').filter(s => s.trim());
    
    // Execute each statement
    for (const statement of statements) {
      console.log(`Executing: ${statement.substring(0, 50)}...`);
      const { error } = await supabase.rpc('exec_sql', { sql: statement });
      if (error) {
        console.error('Error executing statement:', error);
        throw error;
      }
    }
    
    console.log('Journey data migration completed successfully!');
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}

migrateJourneyData();
```

## Alternative Approach: Admin UI

As an alternative to scripts, we can implement the Journey Content Management admin UI early in the development process and use it to import the data:

1. Build the admin UI for managing journey content
2. Add an "Import from Excel" feature
3. Upload the Excel file through the UI
4. Process and validate the data
5. Save to the database

This approach has the advantage of providing a user-friendly way to manage journey content going forward.

## Implementation Steps

1. **Prepare the Data**
   - Review the Excel file structure
   - Map columns to database fields
   - Identify any data cleaning or transformation needed

2. **Create Migration Scripts**
   - Implement the Excel parsing script
   - Implement the SQL generation script
   - Implement the database migration script

3. **Execute Migration**
   - Run the scripts in a staging environment
   - Verify data integrity
   - Fix any issues
   - Run in production

4. **Verify Migration**
   - Check that all phases, steps, options, and tools are correctly imported
   - Verify relationships between entities
   - Test the Journey Map UI with the imported data

## Timeline

- **Day 1**: Prepare data and create migration scripts
- **Day 2**: Test migration in staging environment
- **Day 3**: Execute migration in production and verify

## Conclusion

This data migration plan ensures that all journey content from the "tools and steps (1).xlsx" file is properly imported into the new database schema. By following this plan, we can populate the Journey Map with the necessary content to provide users with a comprehensive startup journey experience.

================
File: the_wheel_design_system_guidelines.md
================
# The Wheel: Design System & Architecture Guidelines

This document outlines the design system and architecture guidelines for The Wheel MVP implementation, focusing on modularity, reusability, and making it easy to update the look and feel.

## Design System Principles

### 1. Modularity & Reusability

- **Component-Based Design**: Build small, reusable components that can be combined to create complex interfaces.
- **Single Responsibility**: Each component should do one thing and do it well.
- **Composition Over Inheritance**: Prefer composing components together rather than creating complex inheritance hierarchies.
- **Consistent APIs**: Components should have consistent prop interfaces and behavior patterns.

### 2. Themability & Customization

- **Design Token System**: Use design tokens for colors, typography, spacing, etc. that can be easily updated.
- **Theme Provider**: Implement a theme provider that allows for runtime theme switching.
- **Separation of Concerns**: Keep styling separate from component logic.
- **Brand Adaptability**: Make it easy to update logos, colors, and other brand elements.

### 3. Accessibility & Inclusivity

- **WCAG 2.1 AA Compliance**: Ensure all components meet accessibility standards.
- **Keyboard Navigation**: All interactive elements must be keyboard accessible.
- **Screen Reader Support**: Provide appropriate ARIA attributes and semantic HTML.
- **Color Contrast**: Maintain sufficient contrast ratios for text and interactive elements.

### 4. Responsive Design

- **Mobile-First Approach**: Design for mobile first, then enhance for larger screens.
- **Fluid Typography**: Use responsive font sizes that scale with viewport width.
- **Flexible Layouts**: Create layouts that adapt to different screen sizes.
- **Touch-Friendly**: Ensure interactive elements are sized appropriately for touch.

## Design Token System

Design tokens are the visual design atoms of the design system. They're named entities that store visual design attributes.

### Color Tokens

```scss
// Primary colors
--color-primary: #3B82F6;
--color-primary-light: #DBEAFE;
--color-primary-dark: #2563EB;

// Secondary colors
--color-secondary: #10B981;
--color-secondary-light: #D1FAE5;
--color-secondary-dark: #059669;

// Neutral colors
--color-background: #FFFFFF;
--color-background-alt: #F9FAFB;
--color-text: #1F2937;
--color-text-light: #6B7280;
--color-border: #E5E7EB;

// Semantic colors
--color-success: #10B981;
--color-warning: #F59E0B;
--color-error: #EF4444;
--color-info: #3B82F6;
```

### Typography Tokens

```scss
// Font families
--font-family-body: 'Inter', system-ui, sans-serif;
--font-family-heading: 'Inter', system-ui, sans-serif;
--font-family-mono: 'Roboto Mono', monospace;

// Font sizes
--font-size-xs: 0.75rem;
--font-size-sm: 0.875rem;
--font-size-md: 1rem;
--font-size-lg: 1.125rem;
--font-size-xl: 1.25rem;
--font-size-2xl: 1.5rem;
--font-size-3xl: 1.875rem;
--font-size-4xl: 2.25rem;

// Font weights
--font-weight-normal: 400;
--font-weight-medium: 500;
--font-weight-semibold: 600;
--font-weight-bold: 700;

// Line heights
--line-height-tight: 1.25;
--line-height-normal: 1.5;
--line-height-loose: 1.75;
```

### Spacing Tokens

```scss
--spacing-0: 0;
--spacing-1: 0.25rem;
--spacing-2: 0.5rem;
--spacing-3: 0.75rem;
--spacing-4: 1rem;
--spacing-5: 1.25rem;
--spacing-6: 1.5rem;
--spacing-8: 2rem;
--spacing-10: 2.5rem;
--spacing-12: 3rem;
--spacing-16: 4rem;
--spacing-20: 5rem;
--spacing-24: 6rem;
--spacing-32: 8rem;
```

### Border & Shadow Tokens

```scss
// Borders
--border-width-thin: 1px;
--border-width-medium: 2px;
--border-width-thick: 4px;
--border-radius-sm: 0.125rem;
--border-radius-md: 0.25rem;
--border-radius-lg: 0.5rem;
--border-radius-xl: 1rem;
--border-radius-full: 9999px;

// Shadows
--shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
--shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
--shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
--shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
```

## Component Library Structure

The component library should be structured in a way that promotes reusability and composition.

### 1. Atoms (Basic Building Blocks)

- Button
- Input
- Checkbox
- Radio
- Select
- Switch
- Icon
- Text
- Heading
- Link
- Badge
- Avatar
- Spinner

### 2. Molecules (Combinations of Atoms)

- Form Field (Label + Input + Error Message)
- Search Bar (Input + Button)
- Card (Container + Heading + Text + Actions)
- Alert (Icon + Text + Close Button)
- Tooltip (Trigger + Content)
- Modal (Overlay + Container + Header + Body + Footer)
- Dropdown (Trigger + Menu)
- Tabs (Tab List + Tab + Tab Panel)

### 3. Organisms (Complex UI Patterns)

- Navigation (Logo + Links + User Menu)
- Form (Multiple Form Fields + Submit Button)
- Table (Header + Rows + Pagination)
- List (Header + Items + Actions)
- Step Indicator (Multiple Steps + Progress)
- Journey Map (Phases + Steps + Indicators)
- Idea Canvas (Multiple Sections + Inputs)
- Task List (Header + Tasks + Filters)

### 4. Templates (Page Layouts)

- Dashboard Layout
- Authentication Layout
- Journey Step Layout
- Idea Hub Layout
- Settings Layout
- Admin Layout

## Implementation Guidelines

### 1. Component Structure

Each component should follow a consistent structure:

```tsx
// Button.tsx
import React from 'react';
import { cn } from '@/lib/utils';

export type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'ghost' | 'link' | 'danger';
export type ButtonSize = 'sm' | 'md' | 'lg';

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  isLoading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ 
    variant = 'primary', 
    size = 'md', 
    isLoading = false, 
    leftIcon, 
    rightIcon, 
    className, 
    children, 
    disabled, 
    ...props 
  }, ref) => {
    return (
      <button
        ref={ref}
        className={cn(
          'inline-flex items-center justify-center font-medium transition-colors',
          'focus:outline-none focus:ring-2 focus:ring-offset-2',
          {
            'primary': 'bg-primary text-white hover:bg-primary-dark',
            'secondary': 'bg-secondary text-white hover:bg-secondary-dark',
            'outline': 'border border-gray-300 bg-transparent hover:bg-gray-50',
            'ghost': 'bg-transparent hover:bg-gray-50',
            'link': 'bg-transparent underline hover:no-underline',
            'danger': 'bg-error text-white hover:bg-error-dark',
          }[variant],
          {
            'sm': 'px-3 py-1.5 text-sm rounded',
            'md': 'px-4 py-2 text-base rounded-md',
            'lg': 'px-6 py-3 text-lg rounded-lg',
          }[size],
          isLoading && 'opacity-70 cursor-not-allowed',
          disabled && 'opacity-50 cursor-not-allowed',
          className
        )}
        disabled={isLoading || disabled}
        {...props}
      >
        {isLoading && <Spinner className="mr-2" size="sm" />}
        {!isLoading && leftIcon && <span className="mr-2">{leftIcon}</span>}
        {children}
        {!isLoading && rightIcon && <span className="ml-2">{rightIcon}</span>}
      </button>
    );
  }
);

Button.displayName = 'Button';
```

### 2. Theme Implementation

Create a theme provider that allows for easy theme switching:

```tsx
// ThemeProvider.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { lightTheme, darkTheme } from './themes';

type ThemeMode = 'light' | 'dark' | 'system';

interface ThemeContextType {
  theme: typeof lightTheme;
  mode: ThemeMode;
  setMode: (mode: ThemeMode) => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mode, setMode] = useState<ThemeMode>('system');
  const [theme, setTheme] = useState(lightTheme);
  
  useEffect(() => {
    // Load saved preference
    const savedMode = localStorage.getItem('theme-mode') as ThemeMode | null;
    if (savedMode) {
      setMode(savedMode);
    }
  }, []);
  
  useEffect(() => {
    // Save preference
    localStorage.setItem('theme-mode', mode);
    
    // Determine theme
    if (mode === 'system') {
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setTheme(isDark ? darkTheme : lightTheme);
    } else {
      setTheme(mode === 'dark' ? darkTheme : lightTheme);
    }
  }, [mode]);
  
  return (
    <ThemeContext.Provider value={{ theme, mode, setMode }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
```

### 3. CSS Variables Integration

Apply theme tokens as CSS variables:

```tsx
// ThemeInjector.tsx
import { useTheme } from './ThemeProvider';
import { useEffect } from 'react';

export const ThemeInjector = () => {
  const { theme, mode } = useTheme();
  
  useEffect(() => {
    // Set data-theme attribute
    document.documentElement.setAttribute('data-theme', mode);
    
    // Set CSS variables
    Object.entries(theme.colors).forEach(([key, value]) => {
      document.documentElement.style.setProperty(`--color-${key}`, value);
    });
    
    Object.entries(theme.fonts).forEach(([key, value]) => {
      document.documentElement.style.setProperty(`--font-${key}`, value);
    });
    
    // ... set other token categories
  }, [theme, mode]);
  
  return null;
};
```

## Microservices Architecture

The application should be built using a microservices approach, with clear separation of concerns and modular components.

### 1. Service Layer

Each domain should have its own service module:

```tsx
// auth.service.ts
import { supabase } from '@/lib/supabase';
import { User, LoginCredentials, SignupCredentials } from '@/types';
import { logger } from '@/lib/logger';

export const authService = {
  async login({ email, password }: LoginCredentials): Promise<User> {
    try {
      logger.info('Attempting login', { email });
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      
      if (error) {
        logger.error('Login failed', { error: error.message });
        throw new Error(error.message);
      }
      
      logger.info('Login successful', { userId: data.user.id });
      return data.user as User;
    } catch (error) {
      logger.error('Login exception', { error });
      throw error;
    }
  },
  
  async signup({ email, password, name }: SignupCredentials): Promise<User> {
    // Implementation
  },
  
  async resetPassword(email: string): Promise<void> {
    // Implementation
  },
  
  async logout(): Promise<void> {
    // Implementation
  },
  
  async getCurrentUser(): Promise<User | null> {
    // Implementation
  }
};
```

### 2. Custom Hooks

Create custom hooks for each service to provide a clean API for components:

```tsx
// useAuth.ts
import { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { authService } from '@/services/auth.service';
import { useUserStore } from '@/stores/user.store';
import { LoginCredentials, SignupCredentials, User } from '@/types';

export function useAuth() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  const { setUser, clearUser } = useUserStore();
  
  const login = useCallback(async (credentials: LoginCredentials) => {
    setIsLoading(true);
    setError(null);
    try {
      const user = await authService.login(credentials);
      setUser(user);
      navigate('/dashboard');
      return user;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [navigate, setUser]);
  
  // Other auth methods...
  
  return {
    isLoading,
    error,
    login,
    // Other methods...
  };
}
```

### 3. State Management

Use Zustand for global state management, with separate stores for different domains:

```tsx
// user.store.ts
import { create } from 'zustand';
import { User } from '@/types';

interface UserState {
  user: User | null;
  isAuthenticated: boolean;
  setUser: (user: User) => void;
  clearUser: () => void;
}

export const useUserStore = create<UserState>((set) => ({
  user: null,
  isAuthenticated: false,
  setUser: (user) => set({ user, isAuthenticated: true }),
  clearUser: () => set({ user: null, isAuthenticated: false }),
}));
```

## File Structure

Organize the codebase by feature/domain rather than by type:

```
src/
  features/
    auth/
      components/
        LoginForm.tsx
        SignupForm.tsx
        PasswordResetForm.tsx
      hooks/
        useAuth.ts
      services/
        auth.service.ts
      types/
        auth.types.ts
      utils/
        auth.utils.ts
      index.ts
    
    journey/
      components/
        JourneyMap.tsx
        StepDetails.tsx
        StepCompletion.tsx
      hooks/
        useJourney.ts
      services/
        journey.service.ts
      types/
        journey.types.ts
      utils/
        journey.utils.ts
      index.ts
    
    ideas/
      components/
        IdeaList.tsx
        IdeaCanvas.tsx
        IdeaStatus.tsx
      hooks/
        useIdeas.ts
      services/
        idea.service.ts
      types/
        idea.types.ts
      utils/
        idea.utils.ts
      index.ts
    
    // Other features...
  
  ui/
    atoms/
      Button.tsx
      Input.tsx
      Checkbox.tsx
      // Other atoms...
    
    molecules/
      FormField.tsx
      Card.tsx
      Modal.tsx
      // Other molecules...
    
    organisms/
      Navigation.tsx
      Table.tsx
      Form.tsx
      // Other organisms...
    
    templates/
      DashboardLayout.tsx
      AuthLayout.tsx
      // Other templates...
    
    theme/
      ThemeProvider.tsx
      ThemeInjector.tsx
      themes.ts
      tokens.ts
  
  lib/
    supabase.ts
    logger.ts
    utils.ts
    // Other utilities...
  
  App.tsx
  main.tsx
```

## Updating Look and Feel

With this architecture, updating the look and feel of the application is straightforward:

1. **Update Theme Tokens**: Modify the color, typography, and other tokens in the theme files.
2. **Replace Logo/Brand Assets**: Update the logo and other brand assets in a single location.
3. **Adjust Component Styles**: If needed, update the component styles to match the new design.

For example, to update the brand colors:

```tsx
// themes.ts
export const lightTheme = {
  colors: {
    // Update primary color from blue to purple
    primary: '#8B5CF6',
    'primary-light': '#EDE9FE',
    'primary-dark': '#6D28D9',
    
    // Update secondary color from green to orange
    secondary: '#F97316',
    'secondary-light': '#FFEDD5',
    'secondary-dark': '#EA580C',
    
    // Other colors...
  },
  // Other tokens...
};
```

## Conclusion

By following these design system and architecture guidelines, The Wheel will be built with modularity, reusability, and easy customization in mind. The component-based approach, combined with a robust theming system and microservices architecture, will make it straightforward to maintain and extend the application over time.

The clear separation of concerns and modular structure will also make it easier to update the look and feel of the application, whether it's changing colors, fonts, or logos, without having to modify multiple files or components.

================
File: the_wheel_implementation_master_plan.md
================
# The Wheel: Implementation Master Plan

This document serves as the master reference for implementing The Wheel MVP with the new database schema. It provides an overview of all key documents and the overall implementation approach.

## Key Documents

1. **`the_wheel_full_schema.sql`**
   - The core database schema with all tables, relationships, and base functionality
   - Includes the RBAC system, user management, company profiles, journey map, idea hub, tasks, etc.

2. **`supabase/migrations/20250427_mvp_enhancements.sql`**
   - Additional database changes to support MVP requirements
   - Focuses on accessibility, logging, and feature enhancements

3. **`the_wheel_mvp_implementation_plan.md`**
   - Detailed phased implementation plan for the MVP
   - Organized into 7 phases with clear dependencies and requirements
   - Includes technical architecture, testing strategy, and deployment approach

4. **`the_wheel_adaptation_plan.md`**
   - Module-by-module plan for adapting existing code to the new schema
   - Preserves working components while implementing new features
   - Includes specific changes needed for each component

5. **`the_wheel_mvp_implementation_summary.md`**
   - High-level overview of the implementation approach
   - Summary of database enhancements
   - Timeline and next steps

## Implementation Philosophy

Our implementation approach is guided by these core principles:

1. **Preserve Working Code**: We will adapt existing, functional components rather than rewriting them. Components that are already working (like the standup bot) will be preserved and only updated to work with the new schema.

2. **Targeted Refactoring**: We will only refactor where there are gaps, bugs, or schema mismatches. This minimizes risk and development time.

3. **Maintain Functionality**: All existing features will continue to work with the new schema. We will ensure backward compatibility where possible.

4. **Enhance for Requirements**: We will add new features and improvements as specified in the MVP requirements, focusing on delivering value quickly.

5. **Cross-Cutting Excellence**: Throughout the implementation, we will ensure:
   - Perfect responsiveness across all device sizes
   - WCAG 2.1 AA accessibility compliance
   - Comprehensive logging for debugging and analytics

## Important Clarifications

- **Single Venture Context**: Each user can be part of only one company (or none), not that each company can only have one user. Companies can have multiple members, but users cannot be members of multiple companies in the MVP.

- **Existing vs. New Components**: The status indicators in the adaptation plan ([], [+/-], [~], [ ]) reflect the current state of each component and guide our approach to updating or implementing it.

## Implementation Process

### Step 1: Database Setup
1. Run the base schema (`the_wheel_full_schema.sql`) in your Supabase instance
2. Apply the enhancements migration (`20250427_mvp_enhancements.sql`)
3. Verify all tables, views, and functions are created correctly

### Step 2: Data Model & Type Updates
1. Create TypeScript interfaces for all new database tables
2. Update existing interfaces to match new schema
3. Create type guards and validation functions
4. Update API response/request types

### Step 3: Service Layer Updates
1. Update authentication service to use new schema
2. Update user/profile service to use new schema
3. Update company service to use new schema
4. Update journey service to use new schema
5. Update idea service to use new schema
6. Update task service to use new schema
7. Update standup service to use new schema
8. Update community service to use new schema
9. Update messaging service to use new schema
10. Update admin services to use new schema

### Step 4: UI Component Updates
1. Update authentication components
2. Update profile components
3. Update company components
4. Update journey map components
5. Update idea hub components
6. Update task management components
7. Update standup components
8. Update community components
9. Update messaging components
10. Update admin components

### Step 5: New Feature Implementation
1. Implement password reset
2. Implement step completion tracking
3. Implement focus areas
4. Implement step feedback
5. Implement action choices
6. Implement tool recommendation
7. Implement custom tool addition
8. Implement AI tool description generation
9. Implement idea status tracking
10. Implement company page

### Step 6: Cross-Cutting Concerns
1. Implement accessibility enhancements
2. Implement responsive design
3. Implement detailed logging

### Step 7: Testing & Deployment
1. Comprehensive testing of all components
2. Performance optimization
3. Deployment to staging environment
4. Final QA and acceptance testing
5. Production deployment

## Module-by-Module Implementation

For each module, follow this process:

1. **Assessment**: Review the current status and gap analysis in the adaptation plan
2. **Data Model**: Update or create the necessary TypeScript interfaces
3. **Services**: Update or implement the required backend services
4. **UI Components**: Update or implement the required UI components
5. **Testing**: Verify the module works correctly with the new schema
6. **Integration**: Ensure the module integrates properly with other modules

## Implementation Timeline

### Week 1: Core Identity & Data Models
- Update all TypeScript interfaces and types
- Update authentication and profile services
- Implement password reset
- Update company service and context management

### Week 2: Journey Map & Company
- Update journey service and map components
- Implement step completion and focus areas
- Implement company page
- Implement step feedback

### Week 3: Tools & Actions
- Implement action choices UI
- Implement tool recommendation
- Implement custom tool addition
- Implement AI tool description generation

### Week 4: Idea Hub & Tasks
- Update idea service and components
- Implement idea status tracking
- Update task service and components
- Enhance task-journey integration

### Week 5: AI Integration & Community
- Update standup service and components
- Enhance journey context integration
- Update community and messaging services
- Implement cross-cutting concerns

### Week 6: Administration & Testing
- Update admin services and components
- Implement journey content management
- Comprehensive testing and bug fixing
- Performance optimization

## Success Criteria

The implementation will be considered successful when:

1. All existing functionality works correctly with the new schema
2. All new features are implemented according to the requirements
3. The application is fully responsive across all device sizes
4. The application meets WCAG 2.1 AA accessibility standards
5. Comprehensive logging is implemented for debugging and analytics
6. All tests pass and the application is stable
7. The application performs well under expected load

## Next Steps

1. Review all documentation and ensure understanding of the implementation approach
2. Set up the development environment with the new database schema
3. Begin implementation following the timeline and process outlined above
4. Regular progress reviews and adjustments as needed
5. Continuous testing and quality assurance throughout the implementation

## Conclusion

This master plan provides a comprehensive roadmap for implementing The Wheel MVP with the new database schema. By following this plan, we can ensure a successful implementation that meets all requirements and delivers a high-quality product.

================
File: the_wheel_mvp_implementation_plan.md
================
# The Wheel: MVP Implementation Plan

This document outlines the detailed implementation plan for The Wheel MVP, based on the requirements analysis and feature review. The plan is structured in phases, with each phase focusing on a set of related features and their dependencies.

## Core Requirements (Cross-Cutting Concerns)

These requirements apply to all phases and features:

### Responsive Design
- Mobile-first approach using Tailwind CSS
- Breakpoints for mobile, tablet, and desktop
- Touch-friendly UI elements
- Flexible layouts that adapt to different screen sizes
- Testing on multiple device sizes

### Accessibility (WCAG 2.1 AA)
- Semantic HTML structure
- Proper ARIA attributes
- Keyboard navigation
- Focus management
- Color contrast compliance
- Screen reader compatibility
- Alt text for images
- Form labels and error handling

### Detailed Logging
- Structured logging format
- User action tracking
- Error logging
- API call logging
- Business event logging
- Performance metrics
- Sensitive data masking

## Phase 1: Core Identity & Authentication

### 1.1 User Authentication System

**Features:**
- Secure User Signup
- Secure User Login
- Password Reset

**Backend Requirements:**
- Implement Supabase Auth integration
- Create user profile creation flow
- Implement password reset token generation and validation

**Frontend Requirements:**
- Create AuthPage component with login/signup toggle
- Add password confirmation field to signup
- Implement specific error handling for common cases
- Create ForgotPasswordPage and ResetPasswordPage components

**Integration Points:**
- Auth state management with user store
- Redirect logic based on authentication state

**Testing:**
- Test all authentication flows
- Verify error handling for edge cases
- Test responsive design on all device sizes

### 1.2 User Profile Management

**Features:**
- Basic Profile Data Storage
- Profile Setup Flow

**Backend Requirements:**
- Implement profile update service
- Create profile completion tracking

**Frontend Requirements:**
- Create ProfileSetupPage component
- Implement profile edit form
- Add profile completion indicator

**Integration Points:**
- Auth system integration
- Navigation conditional rendering

**Testing:**
- Test profile data persistence
- Verify form validation
- Test responsive design on all device sizes

### 1.3 Company Context Management

**Features:**
- Single Company Context Logic
- Company Setup Flow

**Backend Requirements:**
- Implement company creation service
- Create company-user association logic
- Enforce single company constraint

**Frontend Requirements:**
- Create CompanySetupPage component
- Implement company creation form
- Add company context indicator in UI

**Integration Points:**
- User profile integration
- Navigation conditional rendering

**Testing:**
- Test company creation flow
- Verify single company constraint
- Test responsive design on all device sizes

## Phase 2: Core Application Framework

### 2.1 Application Shell

**Features:**
- Basic UI Shell / Container
- Main Navigation Structure
- Foundational UI Components

**Backend Requirements:**
- Implement navigation permission checks
- Create feature flag service for conditional navigation

**Frontend Requirements:**
- Create Layout component with responsive design
- Implement sidebar/header navigation
- Create reusable UI component library
- Add conditional navigation based on company status

**Integration Points:**
- Auth system integration
- Company context integration

**Testing:**
- Test navigation flows
- Verify responsive design on all device sizes
- Test accessibility of navigation

### 2.2 Company Formation & Page

**Features:**
- Company Formation Step Trigger
- Company Page
- Conditional Access Logic

**Backend Requirements:**
- Implement company formation status update
- Create company details retrieval service

**Frontend Requirements:**
- Create CompanyPage component
- Implement company formation trigger UI
- Add conditional navigation to company page

**Integration Points:**
- Journey step completion integration
- Navigation conditional rendering

**Testing:**
- Test company formation flow
- Verify conditional access logic
- Test responsive design on all device sizes

## Phase 3: Journey Map & Tools

### 3.1 Journey Map Core

**Features:**
- Journey Map Data Model
- Journey Map UI
- Step Completion Tracking

**Backend Requirements:**
- Implement journey phase/step retrieval service
- Create step completion tracking service
- Implement focus area management

**Frontend Requirements:**
- Create JourneyMapPage component
- Implement phase/step visualization
- Add step completion UI
- Create focus area selection UI

**Integration Points:**
- Company context integration
- Step completion triggers company formation

**Testing:**
- Test journey map navigation
- Verify step completion tracking
- Test responsive design on all device sizes

### 3.2 Journey Step Details

**Features:**
- Step Details View
- Step Feedback Input
- Action Choices UI

**Backend Requirements:**
- Implement step details retrieval service
- Create step feedback storage service
- Implement action choice availability logic

**Frontend Requirements:**
- Create StepDetailsPage component
- Implement feedback input form
- Add action choice buttons with conditional display
- Create step completion button

**Integration Points:**
- Journey map integration
- Tool recommendation integration

**Testing:**
- Test step details display
- Verify feedback submission
- Test action choice conditional display
- Test responsive design on all device sizes

### 3.3 Tool Recommendation & Tracking

**Features:**
- Tool Recommendation Logic
- Tool Display UI
- Custom Tool Addition

**Backend Requirements:**
- Implement tool recommendation service
- Create custom tool storage service
- Implement AI description generation service

**Frontend Requirements:**
- Create ToolRecommendationComponent
- Implement tool card display
- Add custom tool input form
- Create AI-generated description review UI

**Integration Points:**
- Journey step integration
- AI service integration

**Testing:**
- Test tool recommendation logic
- Verify custom tool addition flow
- Test AI description generation
- Test responsive design on all device sizes

## Phase 4: Task Management & AI Integration

### 4.1 Task Management System

**Features:**
- General Task List
- Journey Step Task List
- Task Creation & Completion

**Backend Requirements:**
- Implement task CRUD services
- Create task-journey step association service
- Implement task filtering/sorting logic

**Frontend Requirements:**
- Create TaskManagerPage component
- Implement general task list view
- Add journey step task list view
- Create task creation/editing forms
- Implement task completion UI

**Integration Points:**
- Journey step integration
- AI task ingestion integration

**Testing:**
- Test task CRUD operations
- Verify task-journey step association
- Test task completion flow
- Test responsive design on all device sizes

### 4.2 AI Cofounder Integration

**Features:**
- Standup Input Section
- AI Feedback Display
- AI Task Generation

**Backend Requirements:**
- Implement standup entry service
- Create AI feedback generation service
- Implement AI task generation service
- Create task ingestion service

**Frontend Requirements:**
- Create StandupPage component
- Implement standup input form
- Add AI feedback display
- Create AI task review UI

**Integration Points:**
- Task management integration
- Journey context integration

**Testing:**
- Test standup submission flow
- Verify AI feedback generation
- Test AI task generation and ingestion
- Test responsive design on all device sizes

## Phase 5: Idea Hub Integration

### 5.1 Idea Hub Core

**Features:**
- Idea List/Dashboard View
- Lean Canvas View/Edit
- Status Tracking

**Backend Requirements:**
- Implement idea CRUD services
- Create lean canvas data service
- Implement status tracking service

**Frontend Requirements:**
- Create IdeaHubPage component
- Implement idea list view
- Add lean canvas editor
- Create status update UI

**Integration Points:**
- Company context integration
- User profile integration

**Testing:**
- Test idea CRUD operations
- Verify lean canvas data persistence
- Test status updates
- Test responsive design on all device sizes

## Phase 6: Community & Messaging

### 6.1 Community Integration

**Features:**
- Forum Browse/Post/Reply Interface

**Backend Requirements:**
- Implement community post CRUD services
- Create post reply service
- Implement community membership service

**Frontend Requirements:**
- Create CommunityPage component
- Implement post list view
- Add post detail view with replies
- Create post creation form

**Integration Points:**
- User profile integration
- Notification integration (if applicable)

**Testing:**
- Test post CRUD operations
- Verify reply functionality
- Test responsive design on all device sizes

### 6.2 Messaging Integration

**Features:**
- Basic Inbox/Chat Interface

**Backend Requirements:**
- Implement conversation service
- Create message CRUD service
- Implement message read status service

**Frontend Requirements:**
- Create MessagesPage component
- Implement conversation list view
- Add message thread view
- Create message composition UI

**Integration Points:**
- User profile integration
- Notification integration (if applicable)

**Testing:**
- Test message CRUD operations
- Verify conversation management
- Test responsive design on all device sizes

## Phase 7: Administration

### 7.1 User Administration

**Features:**
- User Lookup
- Feature Flag Management

**Backend Requirements:**
- Implement user search service
- Create feature flag management service

**Frontend Requirements:**
- Create AdminUserPage component
- Implement user search UI
- Add user detail view
- Create feature flag toggle UI

**Integration Points:**
- User profile integration
- Feature flag system integration

**Testing:**
- Test user search functionality
- Verify feature flag management
- Test responsive design on all device sizes

### 7.2 Journey Content Management

**Features:**
- Journey Map Content Management
- Tool Database Management

**Backend Requirements:**
- Implement journey content CRUD services
- Create tool database management service

**Frontend Requirements:**
- Create AdminJourneyPage component
- Implement journey structure editor
- Add step content editor
- Create tool management UI

**Integration Points:**
- Journey map integration
- Tool recommendation integration

**Testing:**
- Test journey content CRUD operations
- Verify tool database management
- Test responsive design on all device sizes

## Implementation Timeline

### Week 1-2: Core Identity & Framework
- Phase 1: Core Identity & Authentication
- Phase 2: Core Application Framework

### Week 3-4: Journey & Tools
- Phase 3: Journey Map & Tools

### Week 5-6: Tasks & AI
- Phase 4: Task Management & AI Integration

### Week 7-8: Ideas, Community & Admin
- Phase 5: Idea Hub Integration
- Phase 6: Community & Messaging
- Phase 7: Administration

## Technical Architecture

### Frontend Architecture
- React with TypeScript
- Tailwind CSS for styling
- React Router for navigation
- Zustand for state management
- React Query for data fetching
- Axios for API calls
- React Hook Form for form handling
- Zod for validation
- React Testing Library for testing

### Backend Architecture
- Supabase for authentication and database
- PostgreSQL for data storage
- RESTful API endpoints
- TypeScript for type safety
- Structured logging with context

### Integration Architecture
- OpenAI API for AI features
- Supabase Realtime for messaging
- Supabase Storage for file uploads
- Email service for notifications

## Monitoring & Logging Strategy

### Frontend Logging
- User interactions
- Page views
- Form submissions
- Error boundaries
- Performance metrics

### Backend Logging
- API requests/responses
- Database operations
- Authentication events
- Business logic events
- Error handling

### Log Storage
- Structured JSON format
- Timestamp and context
- User ID (when authenticated)
- Session ID
- Device information

## Testing Strategy

### Unit Testing
- Component tests
- Service tests
- Utility function tests

### Integration Testing
- API endpoint tests
- Authentication flow tests
- Form submission tests

### End-to-End Testing
- Critical user journeys
- Authentication flows
- Data persistence

### Accessibility Testing
- Automated tests with axe-core
- Manual keyboard navigation testing
- Screen reader testing

### Responsive Testing
- Mobile, tablet, and desktop viewports
- Touch interaction testing
- Layout verification

## Deployment Strategy

### Development Environment
- Local development with Supabase local
- Feature branch deployments

### Staging Environment
- Integrated testing environment
- QA and acceptance testing

### Production Environment
- Phased rollout
- Monitoring and alerting
- Backup and recovery plan

================
File: the_wheel_mvp_implementation_summary.md
================
# The Wheel: MVP Implementation Summary

This document provides a summary of the MVP implementation plan and database enhancements for The Wheel platform.

## Overview

The MVP implementation is structured as a complete rebuild using the new database schema (`the_wheel_full_schema.sql`), with additional enhancements (`20250427_mvp_enhancements.sql`) to support accessibility, detailed logging, and other MVP requirements.

## Key Documents

1. **`the_wheel_full_schema.sql`**
   - The core database schema with all tables, relationships, and base functionality
   - Includes the RBAC system, user management, company profiles, journey map, idea hub, tasks, etc.

2. **`the_wheel_mvp_implementation_plan.md`**
   - Detailed phased implementation plan for the MVP
   - Organized into 7 phases with clear dependencies and requirements
   - Includes technical architecture, testing strategy, and deployment approach

3. **`supabase/migrations/20250427_mvp_enhancements.sql`**
   - Additional database changes to support MVP requirements
   - Focuses on accessibility, logging, and feature enhancements

## Implementation Phases

1. **Core Identity & Authentication**
   - User authentication system
   - Profile management
   - Company context management

2. **Core Application Framework**
   - Application shell
   - Navigation structure
   - Company formation & page

3. **Journey Map & Tools**
   - Journey map core
   - Step details
   - Tool recommendation & tracking

4. **Task Management & AI Integration**
   - Task management system
   - AI cofounder integration

5. **Idea Hub Integration**
   - Idea list/dashboard
   - Lean canvas editor
   - Status tracking

6. **Community & Messaging**
   - Community forum
   - Messaging system

7. **Administration**
   - User administration
   - Feature flag management
   - Journey content management

## Database Enhancements

The `20250427_mvp_enhancements.sql` migration adds:

### Accessibility Support
- `user_accessibility_preferences` table for storing user preferences
- Fields for high contrast, large text, reduced motion, etc.

### Enhanced Logging
- Additional fields in `audit_logs` table
- New `frontend_logs` table for client-side events
- New `api_logs` table for API request tracking

### Password Reset Improvements
- Additional fields in `password_reset_requests` table
- Indexes for better performance

### Journey Map Enhancements
- Action flags for journey steps
- Tool ranking support
- `ask_wheel_requests` table for expert assistance

### Idea Hub Improvements
- Status field for ideas
- Index for idea status filtering

### Task Management Improvements
- Journey step association for tasks
- Index for task-step filtering

### AI Integration Improvements
- Focus step context for standups
- Index for standup-step filtering

### Views for Analytics
- `user_journey_progress` view
- `user_task_summary` view
- `user_activity_summary` view

## Next Steps

1. Run the base schema (`the_wheel_full_schema.sql`) in your Supabase instance
2. Apply the enhancements migration (`20250427_mvp_enhancements.sql`)
3. Begin implementation following the phased approach in the implementation plan
4. Start with Phase 1 (Core Identity & Authentication)

## Cross-Cutting Requirements

Throughout the implementation, ensure:

- **Responsive Design**: Mobile-first approach with Tailwind CSS
- **Accessibility**: WCAG 2.1 AA compliance
- **Detailed Logging**: Structured logging of user actions, errors, and system events

## Timeline

The estimated timeline for the complete MVP implementation is 8 weeks:

- Weeks 1-2: Core Identity & Framework
- Weeks 3-4: Journey & Tools
- Weeks 5-6: Tasks & AI
- Weeks 7-8: Ideas, Community & Admin

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: update-ai-components.sh
================
BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$BASE_DIR"
mkdir -p ./backup
echo "Creating backups of original files..."
cp ./src/lib/services/ai/ai-context-provider.tsx ./backup/ai-context-provider.tsx.bak
cp ./src/components/ui/forms/AIAssistedInput.tsx ./backup/AIAssistedInput.tsx.bak
cp ./src/components/ui/forms/AIAssistedTextArea.tsx ./backup/AIAssistedTextArea.tsx.bak
echo "Creating BaseAIContextProvider.tsx..."
mkdir -p ./src/lib/services/ai/shared
cat > ./src/lib/services/ai/shared/BaseAIContextProvider.tsx << 'EOL'
import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';
/**
 * Props for the BaseAIContextProvider component
 */
export interface BaseAIContextProviderProps {
  /** Children to render inside the provider */
  children: ReactNode;
  /** Service to use for AI operations */
  service: AIService;
  /** Context name for debugging */
  contextName?: string;
}
/**
 * Interface for AI service
 */
export interface AIService {
  /** Generate a response based on the prompt */
  generateResponse: (prompt: string) => Promise<string>;
  /** Generate suggestions based on the prompt */
  generateSuggestions?: (prompt: string) => Promise<string[]>;
  /** Analyze text and provide feedback */
  analyzeText?: (text: string) => Promise<string>;
}
/**
 * Context for AI operations
 */
export interface BaseAIContext {
  /** Generate a response based on the prompt */
  generateResponse: (prompt: string) => Promise<string>;
  /** Generate suggestions based on the prompt */
  generateSuggestions: (prompt: string) => Promise<string[]>;
  /** Analyze text and provide feedback */
  analyzeText: (text: string) => Promise<string>;
  /** Whether the AI is currently loading */
  isLoading: boolean;
  /** Error message if any */
  error: string | null;
  /** Clear the error message */
  clearError: () => void;
}
/**
 * Create a context for AI operations
 */
export function createAIContext() {
  return createContext<BaseAIContext | null>(null);
}
/**
 * Base component for AI context providers
 * This component provides the common functionality for AI context providers
 */
export function BaseAIContextProvider({
  children,
  service,
  contextName = 'BaseAIContext'
}: BaseAIContextProviderProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const clearError = useCallback(() => {
    setError(null);
  }, []);
  const generateResponse = useCallback(
    async (prompt: string) => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await service.generateResponse(prompt);
        return response;
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(`Error generating response: ${errorMessage}`);
        return '';
      } finally {
        setIsLoading(false);
      }
    },
    [service]
  );
  const generateSuggestions = useCallback(
    async (prompt: string) => {
      setIsLoading(true);
      setError(null);
      try {
        if (service.generateSuggestions) {
          const suggestions = await service.generateSuggestions(prompt);
          return suggestions;
        }
        // Fallback to generating a single response and splitting it
        const response = await service.generateResponse(prompt);
        return response.split('\n').filter(Boolean);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(`Error generating suggestions: ${errorMessage}`);
        return [];
      } finally {
        setIsLoading(false);
      }
    },
    [service]
  );
  const analyzeText = useCallback(
    async (text: string) => {
      setIsLoading(true);
      setError(null);
      try {
        if (service.analyzeText) {
          const analysis = await service.analyzeText(text);
          return analysis;
        }
        // Fallback to generating a response with a prompt
        const response = await service.generateResponse(`Analyze the following text:\n${text}`);
        return response;
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(`Error analyzing text: ${errorMessage}`);
        return '';
      } finally {
        setIsLoading(false);
      }
    },
    [service]
  );
  // Create the context value
  const contextValue: BaseAIContext = {
    generateResponse,
    generateSuggestions,
    analyzeText,
    isLoading,
    error,
    clearError
  };
  // Create a dynamic context
  const Context = createAIContext();
  return <Context.Provider value={contextValue}>{children}</Context.Provider>;
}
/**
 * Create a hook to use the AI context
 */
export function createUseAIContext(Context: React.Context<BaseAIContext | null>) {
  return function useAIContext() {
    const context = useContext(Context);
    if (!context) {
      throw new Error('useAIContext must be used within an AIContextProvider');
    }
    return context;
  };
}
EOL
echo "Creating README.md for AI shared components..."
cat > ./src/lib/services/ai/shared/README.md << 'EOL'
This directory contains shared components for AI-related functionality. The goal is to reduce code duplication and ensure consistency in the AI-related code.
- `BaseAIContextProvider.tsx`: A base component for AI context providers
A base component for AI context providers. This component provides the common functionality for AI context providers, including:
- Creating a context for AI operations
- Providing methods for generating responses, suggestions, and analyzing text
- Handling loading and error states
- Providing a hook for consuming the context
To create a new AI context provider, you can use the `BaseAIContextProvider` component:
```tsx
import { BaseAIContextProvider, createAIContext, createUseAIContext } from './shared/BaseAIContextProvider';
// Create a context
const MyAIContext = createAIContext();
// Create a provider component
export function MyAIContextProvider({ children }) {
  const service = {
    generateResponse: async (prompt) => {
      // Implement your AI service here
      return 'Response';
    },
    generateSuggestions: async (prompt) => {
      // Implement your AI service here
      return ['Suggestion 1', 'Suggestion 2'];
    },
    analyzeText: async (text) => {
      // Implement your AI service here
      return 'Analysis';
    }
  };
  return (
    <BaseAIContextProvider service={service} contextName="MyAIContext">
      {children}
    </BaseAIContextProvider>
  );
}
// Create a hook to use the context
export const useMyAIContext = createUseAIContext(MyAIContext);
```
Then, you can use the provider and hook in your components:
```tsx
import { MyAIContextProvider, useMyAIContext } from './MyAIContextProvider';
function MyComponent() {
  const { generateResponse, isLoading, error } = useMyAIContext();
  const handleClick = async () => {
    const response = await generateResponse('Hello, AI!');
    console.log(response);
  };
  return (
    <div>
      <button onClick={handleClick}>Generate Response</button>
      {isLoading && <p>Loading...</p>}
      {error && <p>Error: {error}</p>}
    </div>
  );
}
function App() {
  return (
    <MyAIContextProvider>
      <MyComponent />
    </MyAIContextProvider>
  );
}
```
EOL
echo "Creating BaseAIAssistedInput.tsx..."
mkdir -p ./src/components/shared/ui/forms
cat > ./src/components/shared/ui/forms/BaseAIAssistedInput.tsx << 'EOL'
import React, { useState, useCallback, InputHTMLAttributes } from 'react';
/**
 * Props for the BaseAIAssistedInput component
 */
export interface BaseAIAssistedInputProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'onChange'> {
  /** Value of the input */
  value: string;
  /** Callback when the value changes */
  onChange: (value: string) => void;
  /** Callback to generate AI suggestions */
  onGenerateSuggestions: (prompt: string) => Promise<string[]>;
  /** Placeholder text */
  placeholder?: string;
  /** Label for the input */
  label?: string;
  /** Whether the AI is currently loading */
  isLoading?: boolean;
  /** Error message if any */
  error?: string | null;
  /** Additional CSS classes */
  className?: string;
  /** Button text for generating suggestions */
  buttonText?: string;
}
/**
 * Base component for AI-assisted inputs
 * This component provides the common functionality for AI-assisted inputs
 */
export function BaseAIAssistedInput({
  value,
  onChange,
  onGenerateSuggestions,
  placeholder = 'Type here...',
  label,
  isLoading = false,
  error = null,
  className = '',
  buttonText = 'Get Suggestions',
  ...props
}: BaseAIAssistedInputProps) {
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const handleChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      onChange(e.target.value);
    },
    [onChange]
  );
  const handleGenerateSuggestions = useCallback(async () => {
    try {
      const newSuggestions = await onGenerateSuggestions(value);
      setSuggestions(newSuggestions);
      setShowSuggestions(true);
    } catch (err) {
      console.error('Error generating suggestions:', err);
    }
  }, [value, onGenerateSuggestions]);
  const handleSelectSuggestion = useCallback(
    (suggestion: string) => {
      onChange(suggestion);
      setShowSuggestions(false);
    },
    [onChange]
  );
  return (
    <div className={`relative ${className}`}>
      {label && (
        <label className="block text-sm font-medium text-gray-700 mb-1">{label}</label>
      )}
      <div className="flex">
        <input
          type="text"
          value={value}
          onChange={handleChange}
          placeholder={placeholder}
          className={`block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
            error ? 'border-red-300' : ''
          }`}
          {...props}
        />
        <button
          type="button"
          onClick={handleGenerateSuggestions}
          disabled={isLoading}
          className="ml-2 inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
        >
          {isLoading ? 'Loading...' : buttonText}
        </button>
      </div>
      {error && <p className="mt-1 text-sm text-red-600">{error}</p>}
      {showSuggestions && suggestions.length > 0 && (
        <div className="absolute z-10 mt-1 w-full bg-white shadow-lg rounded-md border border-gray-300 max-h-60 overflow-auto">
          <ul className="py-1">
            {suggestions.map((suggestion, index) => (
              <li
                key={index}
                onClick={() => handleSelectSuggestion(suggestion)}
                className="px-4 py-2 hover:bg-gray-100 cursor-pointer text-sm"
              >
                {suggestion}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}
EOL
echo "Creating AIAssistedInput.tsx..."
cat > ./src/components/shared/ui/forms/AIAssistedInput.tsx << 'EOL'
import React, { useCallback } from 'react';
import { BaseAIAssistedInput, BaseAIAssistedInputProps } from './BaseAIAssistedInput';
/**
 * Props for the AIAssistedInput component
 */
export interface AIAssistedInputProps extends Omit<BaseAIAssistedInputProps, 'onGenerateSuggestions' | 'isLoading' | 'error'> {
  /** Context hook to use for AI operations */
  useAIContext: () => {
    generateSuggestions: (prompt: string) => Promise<string[]>;
    isLoading: boolean;
    error: string | null;
  };
  /** Prompt template to use for generating suggestions */
  promptTemplate?: string;
}
/**
 * A component for AI-assisted inputs
 * This component uses the BaseAIAssistedInput component for common functionality
 */
export function AIAssistedInput({
  value,
  onChange,
  useAIContext,
  promptTemplate = 'Suggest some options for: {input}',
  ...props
}: AIAssistedInputProps) {
  const { generateSuggestions, isLoading, error } = useAIContext();
  const handleGenerateSuggestions = useCallback(
    async (input: string) => {
      const prompt = promptTemplate.replace('{input}', input);
      return generateSuggestions(prompt);
    },
    [generateSuggestions, promptTemplate]
  );
  return (
    <BaseAIAssistedInput
      value={value}
      onChange={onChange}
      onGenerateSuggestions={handleGenerateSuggestions}
      isLoading={isLoading}
      error={error}
      {...props}
    />
  );
}
EOL
echo "Creating AIAssistedTextArea.tsx..."
cat > ./src/components/shared/ui/forms/AIAssistedTextArea.tsx << 'EOL'
import React, { useState, useCallback, TextareaHTMLAttributes } from 'react';
/**
 * Props for the AIAssistedTextArea component
 */
export interface AIAssistedTextAreaProps extends Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, 'onChange'> {
  /** Value of the textarea */
  value: string;
  /** Callback when the value changes */
  onChange: (value: string) => void;
  /** Context hook to use for AI operations */
  useAIContext: () => {
    generateResponse: (prompt: string) => Promise<string>;
    isLoading: boolean;
    error: string | null;
  };
  /** Prompt template to use for generating responses */
  promptTemplate?: string;
  /** Placeholder text */
  placeholder?: string;
  /** Label for the textarea */
  label?: string;
  /** Additional CSS classes */
  className?: string;
  /** Button text for generating responses */
  buttonText?: string;
  /** Button text for completing the text */
  completeButtonText?: string;
  /** Button text for improving the text */
  improveButtonText?: string;
}
/**
 * A component for AI-assisted textareas
 */
export function AIAssistedTextArea({
  value,
  onChange,
  useAIContext,
  promptTemplate = 'Complete the following text:\n{input}',
  placeholder = 'Type here...',
  label,
  className = '',
  buttonText = 'AI Assist',
  completeButtonText = 'Complete',
  improveButtonText = 'Improve',
  ...props
}: AIAssistedTextAreaProps) {
  const { generateResponse, isLoading, error } = useAIContext();
  const [showOptions, setShowOptions] = useState(false);
  const handleChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      onChange(e.target.value);
    },
    [onChange]
  );
  const handleComplete = useCallback(async () => {
    try {
      const prompt = promptTemplate.replace('{input}', value);
      const response = await generateResponse(prompt);
      onChange(value + response);
      setShowOptions(false);
    } catch (err) {
      console.error('Error completing text:', err);
    }
  }, [value, onChange, generateResponse, promptTemplate]);
  const handleImprove = useCallback(async () => {
    try {
      const prompt = `Improve the following text:\n${value}`;
      const response = await generateResponse(prompt);
      onChange(response);
      setShowOptions(false);
    } catch (err) {
      console.error('Error improving text:', err);
    }
  }, [value, onChange, generateResponse]);
  return (
    <div className={`relative ${className}`}>
      {label && (
        <label className="block text-sm font-medium text-gray-700 mb-1">{label}</label>
      )}
      <div>
        <textarea
          value={value}
          onChange={handleChange}
          placeholder={placeholder}
          className={`block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
            error ? 'border-red-300' : ''
          }`}
          {...props}
        />
        <div className="mt-2 flex justify-end">
          <button
            type="button"
            onClick={() => setShowOptions(!showOptions)}
            disabled={isLoading}
            className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            {isLoading ? 'Loading...' : buttonText}
          </button>
        </div>
      </div>
      {error && <p className="mt-1 text-sm text-red-600">{error}</p>}
      {showOptions && (
        <div className="absolute z-10 mt-1 right-0 bg-white shadow-lg rounded-md border border-gray-300">
          <div className="p-2">
            <button
              type="button"
              onClick={handleComplete}
              disabled={isLoading}
              className="w-full mb-2 inline-flex items-center justify-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
            >
              {completeButtonText}
            </button>
            <button
              type="button"
              onClick={handleImprove}
              disabled={isLoading}
              className="w-full inline-flex items-center justify-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
            >
              {improveButtonText}
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
EOL
echo "Creating README.md for UI shared components..."
cat > ./src/components/shared/ui/README.md << 'EOL'
This directory contains shared UI components that can be used across the application. The goal is to reduce code duplication and ensure consistency in the UI.
```
/ui
  /forms     - Form-related components
```
The forms components are located at:
```
/ui/forms/
```
This directory contains the following components:
- `BaseAIAssistedInput.tsx`: A base component for AI-assisted inputs
- `AIAssistedInput.tsx`: A wrapper component for AI-assisted inputs
- `AIAssistedTextArea.tsx`: A component for AI-assisted textareas
A base component for AI-assisted inputs. This component provides the common functionality for AI-assisted inputs, including:
- Displaying an input field with a button to generate suggestions
- Displaying a list of suggestions
- Handling loading and error states
A wrapper component for AI-assisted inputs. This component uses the BaseAIAssistedInput component for common functionality and adds integration with the AI context.
A component for AI-assisted textareas. This component provides functionality for AI-assisted textareas, including:
- Displaying a textarea with a button to generate AI assistance
- Providing options to complete or improve the text
- Handling loading and error states
To use the AI-assisted input components, you need to provide an AI context hook:
```tsx
import { AIAssistedInput } from './shared/ui/forms/AIAssistedInput';
import { useMyAIContext } from './MyAIContextProvider';
function MyComponent() {
  const [value, setValue] = useState('');
  return (
    <AIAssistedInput
      value={value}
      onChange={setValue}
      useAIContext={useMyAIContext}
      label="My Input"
      placeholder="Type here..."
    />
  );
}
```
To use the AI-assisted textarea component:
```tsx
import { AIAssistedTextArea } from './shared/ui/forms/AIAssistedTextArea';
import { useMyAIContext } from './MyAIContextProvider';
function MyComponent() {
  const [value, setValue] = useState('');
  return (
    <AIAssistedTextArea
      value={value}
      onChange={setValue}
      useAIContext={useMyAIContext}
      label="My Textarea"
      placeholder="Type here..."
    />
  );
}
```
EOL
echo "AI component updates completed successfully!"
echo "Original files have been backed up to ./backup/"
echo ""
echo "To revert changes, run:"
echo "cp ./backup/ai-context-provider.tsx.bak ./src/lib/services/ai/ai-context-provider.tsx"
echo "cp ./backup/AIAssistedInput.tsx.bak ./src/components/ui/forms/AIAssistedInput.tsx"
echo "cp ./backup/AIAssistedTextArea.tsx.bak ./src/components/ui/forms/AIAssistedTextArea.tsx"

================
File: update-components.sh
================
BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$BASE_DIR"
mkdir -p ./backup
echo "Creating backups of original files..."
cp ./src/components/idea-playground/IdeaCard.tsx ./backup/IdeaCard.tsx.bak
cp ./src/components/idea-playground/IdeaList.tsx ./backup/IdeaList.tsx.bak
cp ./src/components/idea-playground/pathway1/SuggestionCard.tsx ./backup/SuggestionCard.tsx.bak
cp ./src/components/idea-playground/pathway1/SuggestionEditor.tsx ./backup/SuggestionEditor.tsx.bak
cp ./src/components/idea-playground/pathway1/SuggestionMerger.tsx ./backup/SuggestionMerger.tsx.bak
echo "Creating BaseIdeaCard.tsx..."
cat > ./src/components/shared/idea/BaseIdeaCard.tsx << 'EOL'
import React from 'react';
/**
 * Props for the BaseIdeaCard component
 */
export interface BaseIdeaCardProps {
  /** Idea title */
  title: string;
  /** Idea description */
  description: string;
  /** Idea status */
  status?: 'draft' | 'published' | 'archived';
  /** Idea tags */
  tags?: string[];
  /** Idea actions */
  actions?: React.ReactNode;
  /** Additional CSS classes */
  className?: string;
  /** Children to render inside the card */
  children?: React.ReactNode;
}
/**
 * Base component for idea cards
 * This component provides the common functionality for idea cards
 */
export function BaseIdeaCard({
  title,
  description,
  status = 'draft',
  tags = [],
  actions,
  className = '',
  children
}: BaseIdeaCardProps) {
  return (
    <div className={`bg-white shadow rounded-lg p-4 ${className}`}>
      <div className="flex justify-between items-start">
        <h3 className="text-lg font-medium text-gray-900">{title}</h3>
        <div className="flex items-center">
          <span className={`px-2 py-1 text-xs rounded-full ${
            status === 'published' ? 'bg-green-100 text-green-800' :
            status === 'archived' ? 'bg-gray-100 text-gray-800' :
            'bg-blue-100 text-blue-800'
          }`}>
            {status}
          </span>
        </div>
      </div>
      <p className="mt-2 text-sm text-gray-500">{description}</p>
      {tags.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {tags.map((tag, index) => (
            <span key={index} className="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded-full">
              {tag}
            </span>
          ))}
        </div>
      )}
      {children}
      {actions && (
        <div className="mt-4 flex justify-end">
          {actions}
        </div>
      )}
    </div>
  );
}
EOL
# Create BaseSuggestionCard.tsx
echo "Creating BaseSuggestionCard.tsx..."
cat > ./src/components/shared/idea/BaseSuggestionCard.tsx << 'EOL'
import React from 'react';
/**
 * Props for the BaseSuggestionCard component
 */
export interface BaseSuggestionCardProps {
  /** Suggestion title */
  title: string;
  /** Suggestion description */
  description: string;
  /** Suggestion status */
  status?: 'pending' | 'accepted' | 'rejected';
  /** Suggestion tags */
  tags?: string[];
  /** Suggestion actions */
  actions?: React.ReactNode;
  /** Additional CSS classes */
  className?: string;
  /** Children to render inside the card */
  children?: React.ReactNode;
}
/**
 * Base component for suggestion cards
 * This component provides the common functionality for suggestion cards
 */
export function BaseSuggestionCard({
  title,
  description,
  status = 'pending',
  tags = [],
  actions,
  className = '',
  children
}: BaseSuggestionCardProps) {
  return (
    <div className={`bg-white shadow rounded-lg p-4 ${className}`}>
      <div className="flex justify-between items-start">
        <h3 className="text-lg font-medium text-gray-900">{title}</h3>
        <div className="flex items-center">
          <span className={`px-2 py-1 text-xs rounded-full ${
            status === 'accepted' ? 'bg-green-100 text-green-800' :
            status === 'rejected' ? 'bg-red-100 text-red-800' :
            'bg-yellow-100 text-yellow-800'
          }`}>
            {status}
          </span>
        </div>
      </div>
      <p className="mt-2 text-sm text-gray-500">{description}</p>
      {tags.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {tags.map((tag, index) => (
            <span key={index} className="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded-full">
              {tag}
            </span>
          ))}
        </div>
      )}
      {children}
      {actions && (
        <div className="mt-4 flex justify-end">
          {actions}
        </div>
      )}
    </div>
  );
}
EOL
echo "Creating IdeaCard.tsx..."
cat > ./src/components/shared/idea/IdeaCard.tsx << 'EOL'
import React from 'react';
import { BaseIdeaCard, BaseIdeaCardProps } from './BaseIdeaCard';
/**
 * Props for the IdeaCard component
 */
export interface IdeaCardProps extends Omit<BaseIdeaCardProps, 'actions'> {
  /** Callback when the edit button is clicked */
  onEdit?: () => void;
  /** Callback when the delete button is clicked */
  onDelete?: () => void;
  /** Callback when the view button is clicked */
  onView?: () => void;
}
/**
 * A card component for displaying an idea
 * This component uses the BaseIdeaCard component for common functionality
 */
export function IdeaCard({
  title,
  description,
  status,
  tags,
  className,
  onEdit,
  onDelete,
  onView,
  children
}: IdeaCardProps) {
  // Create actions based on the callbacks
  const actions = (
    <>
      {onView && (
        <button
          type="button"
          onClick={onView}
          className="ml-2 inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
        >
          View
        </button>
      )}
      {onEdit && (
        <button
          type="button"
          onClick={onEdit}
          className="ml-2 inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-blue-700 bg-blue-100 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        >
          Edit
        </button>
      )}
      {onDelete && (
        <button
          type="button"
          onClick={onDelete}
          className="ml-2 inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-red-700 bg-red-100 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
        >
          Delete
        </button>
      )}
    </>
  );
  return (
    <BaseIdeaCard
      title={title}
      description={description}
      status={status}
      tags={tags}
      className={className}
      actions={actions}
    >
      {children}
    </BaseIdeaCard>
  );
}
EOL
echo "Creating SuggestionCard.tsx..."
cat > ./src/components/shared/idea/SuggestionCard.tsx << 'EOL'
import React from 'react';
import { BaseSuggestionCard, BaseSuggestionCardProps } from './BaseSuggestionCard';
/**
 * Props for the SuggestionCard component
 */
export interface SuggestionCardProps extends Omit<BaseSuggestionCardProps, 'actions'> {
  /** Callback when the accept button is clicked */
  onAccept?: () => void;
  /** Callback when the reject button is clicked */
  onReject?: () => void;
  /** Callback when the edit button is clicked */
  onEdit?: () => void;
}
/**
 * A card component for displaying a suggestion
 * This component uses the BaseSuggestionCard component for common functionality
 */
export function SuggestionCard({
  title,
  description,
  status,
  tags,
  className,
  onAccept,
  onReject,
  onEdit,
  children
}: SuggestionCardProps) {
  // Create actions based on the callbacks
  const actions = (
    <>
      {onAccept && status !== 'accepted' && (
        <button
          type="button"
          onClick={onAccept}
          className="ml-2 inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-green-700 bg-green-100 hover:bg-green-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
        >
          Accept
        </button>
      )}
      {onReject && status !== 'rejected' && (
        <button
          type="button"
          onClick={onReject}
          className="ml-2 inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-red-700 bg-red-100 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
        >
          Reject
        </button>
      )}
      {onEdit && (
        <button
          type="button"
          onClick={onEdit}
          className="ml-2 inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-blue-700 bg-blue-100 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        >
          Edit
        </button>
      )}
    </>
  );
  return (
    <BaseSuggestionCard
      title={title}
      description={description}
      status={status}
      tags={tags}
      className={className}
      actions={actions}
    >
      {children}
    </BaseSuggestionCard>
  );
}
EOL
echo "Component updates completed successfully!"
echo "Original files have been backed up to ./backup/"
echo ""
echo "To revert changes, run:"
echo "cp ./backup/IdeaCard.tsx.bak ./src/components/idea-playground/IdeaCard.tsx"
echo "cp ./backup/IdeaList.tsx.bak ./src/components/idea-playground/IdeaList.tsx"
echo "cp ./backup/SuggestionCard.tsx.bak ./src/components/idea-playground/pathway1/SuggestionCard.tsx"
echo "cp ./backup/SuggestionEditor.tsx.bak ./src/components/idea-playground/pathway1/SuggestionEditor.tsx"
echo "cp ./backup/SuggestionMerger.tsx.bak ./src/components/idea-playground/pathway1/SuggestionMerger.tsx"

================
File: vite.config.ts
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tsconfigPaths from 'vite-tsconfig-paths';



================================================================
End of Codebase
================================================================
